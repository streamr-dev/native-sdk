// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: packages/dht/protos/DhtRpc.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_packages_2fdht_2fprotos_2fDhtRpc_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_packages_2fdht_2fprotos_2fDhtRpc_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/empty.pb.h"
#include "google/protobuf/any.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "packages/proto-rpc/protos/ProtoRpc.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_packages_2fdht_2fprotos_2fDhtRpc_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
namespace dht {
class ClosestPeersRequest;
struct ClosestPeersRequestDefaultTypeInternal;
extern ClosestPeersRequestDefaultTypeInternal _ClosestPeersRequest_default_instance_;
class ClosestPeersResponse;
struct ClosestPeersResponseDefaultTypeInternal;
extern ClosestPeersResponseDefaultTypeInternal _ClosestPeersResponse_default_instance_;
class ClosestRingPeersRequest;
struct ClosestRingPeersRequestDefaultTypeInternal;
extern ClosestRingPeersRequestDefaultTypeInternal _ClosestRingPeersRequest_default_instance_;
class ClosestRingPeersResponse;
struct ClosestRingPeersResponseDefaultTypeInternal;
extern ClosestRingPeersResponseDefaultTypeInternal _ClosestRingPeersResponse_default_instance_;
class ConnectivityMethod;
struct ConnectivityMethodDefaultTypeInternal;
extern ConnectivityMethodDefaultTypeInternal _ConnectivityMethod_default_instance_;
class ConnectivityRequest;
struct ConnectivityRequestDefaultTypeInternal;
extern ConnectivityRequestDefaultTypeInternal _ConnectivityRequest_default_instance_;
class ConnectivityResponse;
struct ConnectivityResponseDefaultTypeInternal;
extern ConnectivityResponseDefaultTypeInternal _ConnectivityResponse_default_instance_;
class DataEntry;
struct DataEntryDefaultTypeInternal;
extern DataEntryDefaultTypeInternal _DataEntry_default_instance_;
class DisconnectNotice;
struct DisconnectNoticeDefaultTypeInternal;
extern DisconnectNoticeDefaultTypeInternal _DisconnectNotice_default_instance_;
class ExternalFetchDataRequest;
struct ExternalFetchDataRequestDefaultTypeInternal;
extern ExternalFetchDataRequestDefaultTypeInternal _ExternalFetchDataRequest_default_instance_;
class ExternalFetchDataResponse;
struct ExternalFetchDataResponseDefaultTypeInternal;
extern ExternalFetchDataResponseDefaultTypeInternal _ExternalFetchDataResponse_default_instance_;
class ExternalStoreDataRequest;
struct ExternalStoreDataRequestDefaultTypeInternal;
extern ExternalStoreDataRequestDefaultTypeInternal _ExternalStoreDataRequest_default_instance_;
class ExternalStoreDataResponse;
struct ExternalStoreDataResponseDefaultTypeInternal;
extern ExternalStoreDataResponseDefaultTypeInternal _ExternalStoreDataResponse_default_instance_;
class HandshakeRequest;
struct HandshakeRequestDefaultTypeInternal;
extern HandshakeRequestDefaultTypeInternal _HandshakeRequest_default_instance_;
class HandshakeResponse;
struct HandshakeResponseDefaultTypeInternal;
extern HandshakeResponseDefaultTypeInternal _HandshakeResponse_default_instance_;
class IceCandidate;
struct IceCandidateDefaultTypeInternal;
extern IceCandidateDefaultTypeInternal _IceCandidate_default_instance_;
class LeaveNotice;
struct LeaveNoticeDefaultTypeInternal;
extern LeaveNoticeDefaultTypeInternal _LeaveNotice_default_instance_;
class LockRequest;
struct LockRequestDefaultTypeInternal;
extern LockRequestDefaultTypeInternal _LockRequest_default_instance_;
class LockResponse;
struct LockResponseDefaultTypeInternal;
extern LockResponseDefaultTypeInternal _LockResponse_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class PeerDescriptor;
struct PeerDescriptorDefaultTypeInternal;
extern PeerDescriptorDefaultTypeInternal _PeerDescriptor_default_instance_;
class PingRequest;
struct PingRequestDefaultTypeInternal;
extern PingRequestDefaultTypeInternal _PingRequest_default_instance_;
class PingResponse;
struct PingResponseDefaultTypeInternal;
extern PingResponseDefaultTypeInternal _PingResponse_default_instance_;
class RecursiveOperationRequest;
struct RecursiveOperationRequestDefaultTypeInternal;
extern RecursiveOperationRequestDefaultTypeInternal _RecursiveOperationRequest_default_instance_;
class RecursiveOperationResponse;
struct RecursiveOperationResponseDefaultTypeInternal;
extern RecursiveOperationResponseDefaultTypeInternal _RecursiveOperationResponse_default_instance_;
class ReplicateDataRequest;
struct ReplicateDataRequestDefaultTypeInternal;
extern ReplicateDataRequestDefaultTypeInternal _ReplicateDataRequest_default_instance_;
class RouteMessageAck;
struct RouteMessageAckDefaultTypeInternal;
extern RouteMessageAckDefaultTypeInternal _RouteMessageAck_default_instance_;
class RouteMessageWrapper;
struct RouteMessageWrapperDefaultTypeInternal;
extern RouteMessageWrapperDefaultTypeInternal _RouteMessageWrapper_default_instance_;
class RtcAnswer;
struct RtcAnswerDefaultTypeInternal;
extern RtcAnswerDefaultTypeInternal _RtcAnswer_default_instance_;
class RtcOffer;
struct RtcOfferDefaultTypeInternal;
extern RtcOfferDefaultTypeInternal _RtcOffer_default_instance_;
class StoreDataRequest;
struct StoreDataRequestDefaultTypeInternal;
extern StoreDataRequestDefaultTypeInternal _StoreDataRequest_default_instance_;
class StoreDataResponse;
struct StoreDataResponseDefaultTypeInternal;
extern StoreDataResponseDefaultTypeInternal _StoreDataResponse_default_instance_;
class UnlockRequest;
struct UnlockRequestDefaultTypeInternal;
extern UnlockRequestDefaultTypeInternal _UnlockRequest_default_instance_;
class WebrtcConnectionRequest;
struct WebrtcConnectionRequestDefaultTypeInternal;
extern WebrtcConnectionRequestDefaultTypeInternal _WebrtcConnectionRequest_default_instance_;
class WebsocketConnectionRequest;
struct WebsocketConnectionRequestDefaultTypeInternal;
extern WebsocketConnectionRequestDefaultTypeInternal _WebsocketConnectionRequest_default_instance_;
}  // namespace dht
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace dht {
enum RecursiveOperation : int {
  FIND_CLOSEST_NODES = 0,
  FETCH_DATA = 1,
  DELETE_DATA = 2,
  RecursiveOperation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RecursiveOperation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RecursiveOperation_IsValid(int value);
extern const uint32_t RecursiveOperation_internal_data_[];
constexpr RecursiveOperation RecursiveOperation_MIN = static_cast<RecursiveOperation>(0);
constexpr RecursiveOperation RecursiveOperation_MAX = static_cast<RecursiveOperation>(2);
constexpr int RecursiveOperation_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
RecursiveOperation_descriptor();
template <typename T>
const std::string& RecursiveOperation_Name(T value) {
  static_assert(std::is_same<T, RecursiveOperation>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RecursiveOperation_Name().");
  return RecursiveOperation_Name(static_cast<RecursiveOperation>(value));
}
template <>
inline const std::string& RecursiveOperation_Name(RecursiveOperation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RecursiveOperation_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool RecursiveOperation_Parse(absl::string_view name, RecursiveOperation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecursiveOperation>(
      RecursiveOperation_descriptor(), name, value);
}
enum NodeType : int {
  NODEJS = 0,
  BROWSER = 1,
  NodeType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NodeType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NodeType_IsValid(int value);
extern const uint32_t NodeType_internal_data_[];
constexpr NodeType NodeType_MIN = static_cast<NodeType>(0);
constexpr NodeType NodeType_MAX = static_cast<NodeType>(1);
constexpr int NodeType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
NodeType_descriptor();
template <typename T>
const std::string& NodeType_Name(T value) {
  static_assert(std::is_same<T, NodeType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NodeType_Name().");
  return NodeType_Name(static_cast<NodeType>(value));
}
template <>
inline const std::string& NodeType_Name(NodeType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NodeType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool NodeType_Parse(absl::string_view name, NodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeType>(
      NodeType_descriptor(), name, value);
}
enum RpcResponseError : int {
  SERVER_TIMOUT = 0,
  CLIENT_TIMEOUT = 1,
  SERVER_ERROR = 2,
  UNKNOWN_RPC_METHOD = 3,
  RpcResponseError_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RpcResponseError_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RpcResponseError_IsValid(int value);
extern const uint32_t RpcResponseError_internal_data_[];
constexpr RpcResponseError RpcResponseError_MIN = static_cast<RpcResponseError>(0);
constexpr RpcResponseError RpcResponseError_MAX = static_cast<RpcResponseError>(3);
constexpr int RpcResponseError_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
RpcResponseError_descriptor();
template <typename T>
const std::string& RpcResponseError_Name(T value) {
  static_assert(std::is_same<T, RpcResponseError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RpcResponseError_Name().");
  return RpcResponseError_Name(static_cast<RpcResponseError>(value));
}
template <>
inline const std::string& RpcResponseError_Name(RpcResponseError value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RpcResponseError_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool RpcResponseError_Parse(absl::string_view name, RpcResponseError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcResponseError>(
      RpcResponseError_descriptor(), name, value);
}
enum RouteMessageError : int {
  NO_TARGETS = 0,
  DUPLICATE = 1,
  STOPPED = 2,
  RouteMessageError_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RouteMessageError_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RouteMessageError_IsValid(int value);
extern const uint32_t RouteMessageError_internal_data_[];
constexpr RouteMessageError RouteMessageError_MIN = static_cast<RouteMessageError>(0);
constexpr RouteMessageError RouteMessageError_MAX = static_cast<RouteMessageError>(2);
constexpr int RouteMessageError_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
RouteMessageError_descriptor();
template <typename T>
const std::string& RouteMessageError_Name(T value) {
  static_assert(std::is_same<T, RouteMessageError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RouteMessageError_Name().");
  return RouteMessageError_Name(static_cast<RouteMessageError>(value));
}
template <>
inline const std::string& RouteMessageError_Name(RouteMessageError value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RouteMessageError_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool RouteMessageError_Parse(absl::string_view name, RouteMessageError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RouteMessageError>(
      RouteMessageError_descriptor(), name, value);
}
enum HandshakeError : int {
  DUPLICATE_CONNECTION = 0,
  INVALID_TARGET_PEER_DESCRIPTOR = 1,
  UNSUPPORTED_VERSION = 2,
  HandshakeError_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  HandshakeError_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool HandshakeError_IsValid(int value);
extern const uint32_t HandshakeError_internal_data_[];
constexpr HandshakeError HandshakeError_MIN = static_cast<HandshakeError>(0);
constexpr HandshakeError HandshakeError_MAX = static_cast<HandshakeError>(2);
constexpr int HandshakeError_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
HandshakeError_descriptor();
template <typename T>
const std::string& HandshakeError_Name(T value) {
  static_assert(std::is_same<T, HandshakeError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to HandshakeError_Name().");
  return HandshakeError_Name(static_cast<HandshakeError>(value));
}
template <>
inline const std::string& HandshakeError_Name(HandshakeError value) {
  return ::google::protobuf::internal::NameOfDenseEnum<HandshakeError_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool HandshakeError_Parse(absl::string_view name, HandshakeError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HandshakeError>(
      HandshakeError_descriptor(), name, value);
}
enum DisconnectMode : int {
  NORMAL = 0,
  LEAVING = 1,
  DisconnectMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DisconnectMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DisconnectMode_IsValid(int value);
extern const uint32_t DisconnectMode_internal_data_[];
constexpr DisconnectMode DisconnectMode_MIN = static_cast<DisconnectMode>(0);
constexpr DisconnectMode DisconnectMode_MAX = static_cast<DisconnectMode>(1);
constexpr int DisconnectMode_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
DisconnectMode_descriptor();
template <typename T>
const std::string& DisconnectMode_Name(T value) {
  static_assert(std::is_same<T, DisconnectMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DisconnectMode_Name().");
  return DisconnectMode_Name(static_cast<DisconnectMode>(value));
}
template <>
inline const std::string& DisconnectMode_Name(DisconnectMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DisconnectMode_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool DisconnectMode_Parse(absl::string_view name, DisconnectMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DisconnectMode>(
      DisconnectMode_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class WebsocketConnectionRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:dht.WebsocketConnectionRequest) */ {
 public:
  inline WebsocketConnectionRequest() : WebsocketConnectionRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WebsocketConnectionRequest(::google::protobuf::internal::ConstantInitialized);

  inline WebsocketConnectionRequest(const WebsocketConnectionRequest& from)
      : WebsocketConnectionRequest(nullptr, from) {}
  WebsocketConnectionRequest(WebsocketConnectionRequest&& from) noexcept
    : WebsocketConnectionRequest() {
    *this = ::std::move(from);
  }

  inline WebsocketConnectionRequest& operator=(const WebsocketConnectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebsocketConnectionRequest& operator=(WebsocketConnectionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WebsocketConnectionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WebsocketConnectionRequest* internal_default_instance() {
    return reinterpret_cast<const WebsocketConnectionRequest*>(
               &_WebsocketConnectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(WebsocketConnectionRequest& a, WebsocketConnectionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WebsocketConnectionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebsocketConnectionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WebsocketConnectionRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WebsocketConnectionRequest>(arena);
  }

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.WebsocketConnectionRequest";
  }
  protected:
  explicit WebsocketConnectionRequest(::google::protobuf::Arena* arena);
  WebsocketConnectionRequest(::google::protobuf::Arena* arena, const WebsocketConnectionRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dht.WebsocketConnectionRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class WebrtcConnectionRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:dht.WebrtcConnectionRequest) */ {
 public:
  inline WebrtcConnectionRequest() : WebrtcConnectionRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WebrtcConnectionRequest(::google::protobuf::internal::ConstantInitialized);

  inline WebrtcConnectionRequest(const WebrtcConnectionRequest& from)
      : WebrtcConnectionRequest(nullptr, from) {}
  WebrtcConnectionRequest(WebrtcConnectionRequest&& from) noexcept
    : WebrtcConnectionRequest() {
    *this = ::std::move(from);
  }

  inline WebrtcConnectionRequest& operator=(const WebrtcConnectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebrtcConnectionRequest& operator=(WebrtcConnectionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WebrtcConnectionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WebrtcConnectionRequest* internal_default_instance() {
    return reinterpret_cast<const WebrtcConnectionRequest*>(
               &_WebrtcConnectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(WebrtcConnectionRequest& a, WebrtcConnectionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WebrtcConnectionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebrtcConnectionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WebrtcConnectionRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WebrtcConnectionRequest>(arena);
  }

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.WebrtcConnectionRequest";
  }
  protected:
  explicit WebrtcConnectionRequest(::google::protobuf::Arena* arena);
  WebrtcConnectionRequest(::google::protobuf::Arena* arena, const WebrtcConnectionRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dht.WebrtcConnectionRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class UnlockRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.UnlockRequest) */ {
 public:
  inline UnlockRequest() : UnlockRequest(nullptr) {}
  ~UnlockRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UnlockRequest(::google::protobuf::internal::ConstantInitialized);

  inline UnlockRequest(const UnlockRequest& from)
      : UnlockRequest(nullptr, from) {}
  UnlockRequest(UnlockRequest&& from) noexcept
    : UnlockRequest() {
    *this = ::std::move(from);
  }

  inline UnlockRequest& operator=(const UnlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockRequest& operator=(UnlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockRequest* internal_default_instance() {
    return reinterpret_cast<const UnlockRequest*>(
               &_UnlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(UnlockRequest& a, UnlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlockRequest>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UnlockRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.UnlockRequest";
  }
  protected:
  explicit UnlockRequest(::google::protobuf::Arena* arena);
  UnlockRequest(::google::protobuf::Arena* arena, const UnlockRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLockIdFieldNumber = 1,
  };
  // string lockId = 1;
  void clear_lockid() ;
  const std::string& lockid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lockid(Arg_&& arg, Args_... args);
  std::string* mutable_lockid();
  PROTOBUF_NODISCARD std::string* release_lockid();
  void set_allocated_lockid(std::string* value);

  private:
  const std::string& _internal_lockid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lockid(
      const std::string& value);
  std::string* _internal_mutable_lockid();

  public:
  // @@protoc_insertion_point(class_scope:dht.UnlockRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr lockid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class StoreDataResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:dht.StoreDataResponse) */ {
 public:
  inline StoreDataResponse() : StoreDataResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StoreDataResponse(::google::protobuf::internal::ConstantInitialized);

  inline StoreDataResponse(const StoreDataResponse& from)
      : StoreDataResponse(nullptr, from) {}
  StoreDataResponse(StoreDataResponse&& from) noexcept
    : StoreDataResponse() {
    *this = ::std::move(from);
  }

  inline StoreDataResponse& operator=(const StoreDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreDataResponse& operator=(StoreDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreDataResponse* internal_default_instance() {
    return reinterpret_cast<const StoreDataResponse*>(
               &_StoreDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StoreDataResponse& a, StoreDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreDataResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreDataResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreDataResponse>(arena);
  }

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.StoreDataResponse";
  }
  protected:
  explicit StoreDataResponse(::google::protobuf::Arena* arena);
  StoreDataResponse(::google::protobuf::Arena* arena, const StoreDataResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dht.StoreDataResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class RtcOffer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.RtcOffer) */ {
 public:
  inline RtcOffer() : RtcOffer(nullptr) {}
  ~RtcOffer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RtcOffer(::google::protobuf::internal::ConstantInitialized);

  inline RtcOffer(const RtcOffer& from)
      : RtcOffer(nullptr, from) {}
  RtcOffer(RtcOffer&& from) noexcept
    : RtcOffer() {
    *this = ::std::move(from);
  }

  inline RtcOffer& operator=(const RtcOffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtcOffer& operator=(RtcOffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtcOffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtcOffer* internal_default_instance() {
    return reinterpret_cast<const RtcOffer*>(
               &_RtcOffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(RtcOffer& a, RtcOffer& b) {
    a.Swap(&b);
  }
  inline void Swap(RtcOffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtcOffer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtcOffer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtcOffer>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RtcOffer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.RtcOffer";
  }
  protected:
  explicit RtcOffer(::google::protobuf::Arena* arena);
  RtcOffer(::google::protobuf::Arena* arena, const RtcOffer& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 1,
    kConnectionIdFieldNumber = 2,
  };
  // string description = 1;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string connectionId = 2;
  void clear_connectionid() ;
  const std::string& connectionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_connectionid(Arg_&& arg, Args_... args);
  std::string* mutable_connectionid();
  PROTOBUF_NODISCARD std::string* release_connectionid();
  void set_allocated_connectionid(std::string* value);

  private:
  const std::string& _internal_connectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectionid(
      const std::string& value);
  std::string* _internal_mutable_connectionid();

  public:
  // @@protoc_insertion_point(class_scope:dht.RtcOffer)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr connectionid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class RtcAnswer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.RtcAnswer) */ {
 public:
  inline RtcAnswer() : RtcAnswer(nullptr) {}
  ~RtcAnswer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RtcAnswer(::google::protobuf::internal::ConstantInitialized);

  inline RtcAnswer(const RtcAnswer& from)
      : RtcAnswer(nullptr, from) {}
  RtcAnswer(RtcAnswer&& from) noexcept
    : RtcAnswer() {
    *this = ::std::move(from);
  }

  inline RtcAnswer& operator=(const RtcAnswer& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtcAnswer& operator=(RtcAnswer&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtcAnswer& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtcAnswer* internal_default_instance() {
    return reinterpret_cast<const RtcAnswer*>(
               &_RtcAnswer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(RtcAnswer& a, RtcAnswer& b) {
    a.Swap(&b);
  }
  inline void Swap(RtcAnswer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtcAnswer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtcAnswer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtcAnswer>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RtcAnswer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.RtcAnswer";
  }
  protected:
  explicit RtcAnswer(::google::protobuf::Arena* arena);
  RtcAnswer(::google::protobuf::Arena* arena, const RtcAnswer& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 1,
    kConnectionIdFieldNumber = 2,
  };
  // string description = 1;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string connectionId = 2;
  void clear_connectionid() ;
  const std::string& connectionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_connectionid(Arg_&& arg, Args_... args);
  std::string* mutable_connectionid();
  PROTOBUF_NODISCARD std::string* release_connectionid();
  void set_allocated_connectionid(std::string* value);

  private:
  const std::string& _internal_connectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectionid(
      const std::string& value);
  std::string* _internal_mutable_connectionid();

  public:
  // @@protoc_insertion_point(class_scope:dht.RtcAnswer)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr connectionid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class RouteMessageAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.RouteMessageAck) */ {
 public:
  inline RouteMessageAck() : RouteMessageAck(nullptr) {}
  ~RouteMessageAck() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouteMessageAck(::google::protobuf::internal::ConstantInitialized);

  inline RouteMessageAck(const RouteMessageAck& from)
      : RouteMessageAck(nullptr, from) {}
  RouteMessageAck(RouteMessageAck&& from) noexcept
    : RouteMessageAck() {
    *this = ::std::move(from);
  }

  inline RouteMessageAck& operator=(const RouteMessageAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteMessageAck& operator=(RouteMessageAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteMessageAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteMessageAck* internal_default_instance() {
    return reinterpret_cast<const RouteMessageAck*>(
               &_RouteMessageAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RouteMessageAck& a, RouteMessageAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteMessageAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteMessageAck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteMessageAck* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteMessageAck>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouteMessageAck* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.RouteMessageAck";
  }
  protected:
  explicit RouteMessageAck(::google::protobuf::Arena* arena);
  RouteMessageAck(::google::protobuf::Arena* arena, const RouteMessageAck& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string requestId = 1;
  void clear_requestid() ;
  const std::string& requestid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestid(Arg_&& arg, Args_... args);
  std::string* mutable_requestid();
  PROTOBUF_NODISCARD std::string* release_requestid();
  void set_allocated_requestid(std::string* value);

  private:
  const std::string& _internal_requestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestid(
      const std::string& value);
  std::string* _internal_mutable_requestid();

  public:
  // optional .dht.RouteMessageError error = 2;
  bool has_error() const;
  void clear_error() ;
  ::dht::RouteMessageError error() const;
  void set_error(::dht::RouteMessageError value);

  private:
  ::dht::RouteMessageError _internal_error() const;
  void _internal_set_error(::dht::RouteMessageError value);

  public:
  // @@protoc_insertion_point(class_scope:dht.RouteMessageAck)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr requestid_;
    int error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class RecursiveOperationRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.RecursiveOperationRequest) */ {
 public:
  inline RecursiveOperationRequest() : RecursiveOperationRequest(nullptr) {}
  ~RecursiveOperationRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecursiveOperationRequest(::google::protobuf::internal::ConstantInitialized);

  inline RecursiveOperationRequest(const RecursiveOperationRequest& from)
      : RecursiveOperationRequest(nullptr, from) {}
  RecursiveOperationRequest(RecursiveOperationRequest&& from) noexcept
    : RecursiveOperationRequest() {
    *this = ::std::move(from);
  }

  inline RecursiveOperationRequest& operator=(const RecursiveOperationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecursiveOperationRequest& operator=(RecursiveOperationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecursiveOperationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecursiveOperationRequest* internal_default_instance() {
    return reinterpret_cast<const RecursiveOperationRequest*>(
               &_RecursiveOperationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RecursiveOperationRequest& a, RecursiveOperationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecursiveOperationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecursiveOperationRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecursiveOperationRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecursiveOperationRequest>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecursiveOperationRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.RecursiveOperationRequest";
  }
  protected:
  explicit RecursiveOperationRequest(::google::protobuf::Arena* arena);
  RecursiveOperationRequest(::google::protobuf::Arena* arena, const RecursiveOperationRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kOperationFieldNumber = 2,
  };
  // string sessionId = 1;
  void clear_sessionid() ;
  const std::string& sessionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sessionid(Arg_&& arg, Args_... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* value);

  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(
      const std::string& value);
  std::string* _internal_mutable_sessionid();

  public:
  // .dht.RecursiveOperation operation = 2;
  void clear_operation() ;
  ::dht::RecursiveOperation operation() const;
  void set_operation(::dht::RecursiveOperation value);

  private:
  ::dht::RecursiveOperation _internal_operation() const;
  void _internal_set_operation(::dht::RecursiveOperation value);

  public:
  // @@protoc_insertion_point(class_scope:dht.RecursiveOperationRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr sessionid_;
    int operation_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class PingResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.PingResponse) */ {
 public:
  inline PingResponse() : PingResponse(nullptr) {}
  ~PingResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PingResponse(::google::protobuf::internal::ConstantInitialized);

  inline PingResponse(const PingResponse& from)
      : PingResponse(nullptr, from) {}
  PingResponse(PingResponse&& from) noexcept
    : PingResponse() {
    *this = ::std::move(from);
  }

  inline PingResponse& operator=(const PingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingResponse& operator=(PingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingResponse* internal_default_instance() {
    return reinterpret_cast<const PingResponse*>(
               &_PingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PingResponse& a, PingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingResponse>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PingResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.PingResponse";
  }
  protected:
  explicit PingResponse(::google::protobuf::Arena* arena);
  PingResponse(::google::protobuf::Arena* arena, const PingResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
  };
  // string requestId = 1;
  void clear_requestid() ;
  const std::string& requestid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestid(Arg_&& arg, Args_... args);
  std::string* mutable_requestid();
  PROTOBUF_NODISCARD std::string* release_requestid();
  void set_allocated_requestid(std::string* value);

  private:
  const std::string& _internal_requestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestid(
      const std::string& value);
  std::string* _internal_mutable_requestid();

  public:
  // @@protoc_insertion_point(class_scope:dht.PingResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr requestid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class PingRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.PingRequest) */ {
 public:
  inline PingRequest() : PingRequest(nullptr) {}
  ~PingRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PingRequest(::google::protobuf::internal::ConstantInitialized);

  inline PingRequest(const PingRequest& from)
      : PingRequest(nullptr, from) {}
  PingRequest(PingRequest&& from) noexcept
    : PingRequest() {
    *this = ::std::move(from);
  }

  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingRequest& operator=(PingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingRequest* internal_default_instance() {
    return reinterpret_cast<const PingRequest*>(
               &_PingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PingRequest& a, PingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingRequest>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PingRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.PingRequest";
  }
  protected:
  explicit PingRequest(::google::protobuf::Arena* arena);
  PingRequest(::google::protobuf::Arena* arena, const PingRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
  };
  // string requestId = 1;
  void clear_requestid() ;
  const std::string& requestid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestid(Arg_&& arg, Args_... args);
  std::string* mutable_requestid();
  PROTOBUF_NODISCARD std::string* release_requestid();
  void set_allocated_requestid(std::string* value);

  private:
  const std::string& _internal_requestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestid(
      const std::string& value);
  std::string* _internal_mutable_requestid();

  public:
  // @@protoc_insertion_point(class_scope:dht.PingRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr requestid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class LockResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.LockResponse) */ {
 public:
  inline LockResponse() : LockResponse(nullptr) {}
  ~LockResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LockResponse(::google::protobuf::internal::ConstantInitialized);

  inline LockResponse(const LockResponse& from)
      : LockResponse(nullptr, from) {}
  LockResponse(LockResponse&& from) noexcept
    : LockResponse() {
    *this = ::std::move(from);
  }

  inline LockResponse& operator=(const LockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LockResponse& operator=(LockResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LockResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LockResponse* internal_default_instance() {
    return reinterpret_cast<const LockResponse*>(
               &_LockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(LockResponse& a, LockResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LockResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LockResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LockResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LockResponse>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LockResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.LockResponse";
  }
  protected:
  explicit LockResponse(::google::protobuf::Arena* arena);
  LockResponse(::google::protobuf::Arena* arena, const LockResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAcceptedFieldNumber = 1,
  };
  // bool accepted = 1;
  void clear_accepted() ;
  bool accepted() const;
  void set_accepted(bool value);

  private:
  bool _internal_accepted() const;
  void _internal_set_accepted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dht.LockResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool accepted_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class LockRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.LockRequest) */ {
 public:
  inline LockRequest() : LockRequest(nullptr) {}
  ~LockRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LockRequest(::google::protobuf::internal::ConstantInitialized);

  inline LockRequest(const LockRequest& from)
      : LockRequest(nullptr, from) {}
  LockRequest(LockRequest&& from) noexcept
    : LockRequest() {
    *this = ::std::move(from);
  }

  inline LockRequest& operator=(const LockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LockRequest& operator=(LockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LockRequest* internal_default_instance() {
    return reinterpret_cast<const LockRequest*>(
               &_LockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(LockRequest& a, LockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LockRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LockRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LockRequest>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LockRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.LockRequest";
  }
  protected:
  explicit LockRequest(::google::protobuf::Arena* arena);
  LockRequest(::google::protobuf::Arena* arena, const LockRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLockIdFieldNumber = 1,
  };
  // string lockId = 1;
  void clear_lockid() ;
  const std::string& lockid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lockid(Arg_&& arg, Args_... args);
  std::string* mutable_lockid();
  PROTOBUF_NODISCARD std::string* release_lockid();
  void set_allocated_lockid(std::string* value);

  private:
  const std::string& _internal_lockid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lockid(
      const std::string& value);
  std::string* _internal_mutable_lockid();

  public:
  // @@protoc_insertion_point(class_scope:dht.LockRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr lockid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class LeaveNotice final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:dht.LeaveNotice) */ {
 public:
  inline LeaveNotice() : LeaveNotice(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LeaveNotice(::google::protobuf::internal::ConstantInitialized);

  inline LeaveNotice(const LeaveNotice& from)
      : LeaveNotice(nullptr, from) {}
  LeaveNotice(LeaveNotice&& from) noexcept
    : LeaveNotice() {
    *this = ::std::move(from);
  }

  inline LeaveNotice& operator=(const LeaveNotice& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveNotice& operator=(LeaveNotice&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaveNotice& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaveNotice* internal_default_instance() {
    return reinterpret_cast<const LeaveNotice*>(
               &_LeaveNotice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(LeaveNotice& a, LeaveNotice& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaveNotice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveNotice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaveNotice* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaveNotice>(arena);
  }

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.LeaveNotice";
  }
  protected:
  explicit LeaveNotice(::google::protobuf::Arena* arena);
  LeaveNotice(::google::protobuf::Arena* arena, const LeaveNotice& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dht.LeaveNotice)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class IceCandidate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.IceCandidate) */ {
 public:
  inline IceCandidate() : IceCandidate(nullptr) {}
  ~IceCandidate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IceCandidate(::google::protobuf::internal::ConstantInitialized);

  inline IceCandidate(const IceCandidate& from)
      : IceCandidate(nullptr, from) {}
  IceCandidate(IceCandidate&& from) noexcept
    : IceCandidate() {
    *this = ::std::move(from);
  }

  inline IceCandidate& operator=(const IceCandidate& from) {
    CopyFrom(from);
    return *this;
  }
  inline IceCandidate& operator=(IceCandidate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IceCandidate& default_instance() {
    return *internal_default_instance();
  }
  static inline const IceCandidate* internal_default_instance() {
    return reinterpret_cast<const IceCandidate*>(
               &_IceCandidate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(IceCandidate& a, IceCandidate& b) {
    a.Swap(&b);
  }
  inline void Swap(IceCandidate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IceCandidate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IceCandidate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IceCandidate>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IceCandidate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.IceCandidate";
  }
  protected:
  explicit IceCandidate(::google::protobuf::Arena* arena);
  IceCandidate(::google::protobuf::Arena* arena, const IceCandidate& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidateFieldNumber = 1,
    kMidFieldNumber = 2,
    kConnectionIdFieldNumber = 3,
  };
  // string candidate = 1;
  void clear_candidate() ;
  const std::string& candidate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_candidate(Arg_&& arg, Args_... args);
  std::string* mutable_candidate();
  PROTOBUF_NODISCARD std::string* release_candidate();
  void set_allocated_candidate(std::string* value);

  private:
  const std::string& _internal_candidate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_candidate(
      const std::string& value);
  std::string* _internal_mutable_candidate();

  public:
  // string mid = 2;
  void clear_mid() ;
  const std::string& mid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mid(Arg_&& arg, Args_... args);
  std::string* mutable_mid();
  PROTOBUF_NODISCARD std::string* release_mid();
  void set_allocated_mid(std::string* value);

  private:
  const std::string& _internal_mid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mid(
      const std::string& value);
  std::string* _internal_mutable_mid();

  public:
  // string connectionId = 3;
  void clear_connectionid() ;
  const std::string& connectionid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_connectionid(Arg_&& arg, Args_... args);
  std::string* mutable_connectionid();
  PROTOBUF_NODISCARD std::string* release_connectionid();
  void set_allocated_connectionid(std::string* value);

  private:
  const std::string& _internal_connectionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectionid(
      const std::string& value);
  std::string* _internal_mutable_connectionid();

  public:
  // @@protoc_insertion_point(class_scope:dht.IceCandidate)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr candidate_;
    ::google::protobuf::internal::ArenaStringPtr mid_;
    ::google::protobuf::internal::ArenaStringPtr connectionid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class ExternalFetchDataRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.ExternalFetchDataRequest) */ {
 public:
  inline ExternalFetchDataRequest() : ExternalFetchDataRequest(nullptr) {}
  ~ExternalFetchDataRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExternalFetchDataRequest(::google::protobuf::internal::ConstantInitialized);

  inline ExternalFetchDataRequest(const ExternalFetchDataRequest& from)
      : ExternalFetchDataRequest(nullptr, from) {}
  ExternalFetchDataRequest(ExternalFetchDataRequest&& from) noexcept
    : ExternalFetchDataRequest() {
    *this = ::std::move(from);
  }

  inline ExternalFetchDataRequest& operator=(const ExternalFetchDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalFetchDataRequest& operator=(ExternalFetchDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExternalFetchDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternalFetchDataRequest* internal_default_instance() {
    return reinterpret_cast<const ExternalFetchDataRequest*>(
               &_ExternalFetchDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ExternalFetchDataRequest& a, ExternalFetchDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExternalFetchDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalFetchDataRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExternalFetchDataRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExternalFetchDataRequest>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExternalFetchDataRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.ExternalFetchDataRequest";
  }
  protected:
  explicit ExternalFetchDataRequest(::google::protobuf::Arena* arena);
  ExternalFetchDataRequest(::google::protobuf::Arena* arena, const ExternalFetchDataRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // bytes key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // @@protoc_insertion_point(class_scope:dht.ExternalFetchDataRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class DisconnectNotice final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.DisconnectNotice) */ {
 public:
  inline DisconnectNotice() : DisconnectNotice(nullptr) {}
  ~DisconnectNotice() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DisconnectNotice(::google::protobuf::internal::ConstantInitialized);

  inline DisconnectNotice(const DisconnectNotice& from)
      : DisconnectNotice(nullptr, from) {}
  DisconnectNotice(DisconnectNotice&& from) noexcept
    : DisconnectNotice() {
    *this = ::std::move(from);
  }

  inline DisconnectNotice& operator=(const DisconnectNotice& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisconnectNotice& operator=(DisconnectNotice&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisconnectNotice& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisconnectNotice* internal_default_instance() {
    return reinterpret_cast<const DisconnectNotice*>(
               &_DisconnectNotice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(DisconnectNotice& a, DisconnectNotice& b) {
    a.Swap(&b);
  }
  inline void Swap(DisconnectNotice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisconnectNotice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisconnectNotice* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisconnectNotice>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DisconnectNotice* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.DisconnectNotice";
  }
  protected:
  explicit DisconnectNotice(::google::protobuf::Arena* arena);
  DisconnectNotice(::google::protobuf::Arena* arena, const DisconnectNotice& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisconnectModeFieldNumber = 1,
  };
  // .dht.DisconnectMode disconnectMode = 1;
  void clear_disconnectmode() ;
  ::dht::DisconnectMode disconnectmode() const;
  void set_disconnectmode(::dht::DisconnectMode value);

  private:
  ::dht::DisconnectMode _internal_disconnectmode() const;
  void _internal_set_disconnectmode(::dht::DisconnectMode value);

  public:
  // @@protoc_insertion_point(class_scope:dht.DisconnectNotice)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int disconnectmode_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class ConnectivityRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.ConnectivityRequest) */ {
 public:
  inline ConnectivityRequest() : ConnectivityRequest(nullptr) {}
  ~ConnectivityRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConnectivityRequest(::google::protobuf::internal::ConstantInitialized);

  inline ConnectivityRequest(const ConnectivityRequest& from)
      : ConnectivityRequest(nullptr, from) {}
  ConnectivityRequest(ConnectivityRequest&& from) noexcept
    : ConnectivityRequest() {
    *this = ::std::move(from);
  }

  inline ConnectivityRequest& operator=(const ConnectivityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectivityRequest& operator=(ConnectivityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectivityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectivityRequest* internal_default_instance() {
    return reinterpret_cast<const ConnectivityRequest*>(
               &_ConnectivityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ConnectivityRequest& a, ConnectivityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectivityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectivityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectivityRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectivityRequest>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConnectivityRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.ConnectivityRequest";
  }
  protected:
  explicit ConnectivityRequest(::google::protobuf::Arena* arena);
  ConnectivityRequest(::google::protobuf::Arena* arena, const ConnectivityRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 3,
    kPortFieldNumber = 1,
    kTlsFieldNumber = 2,
    kAllowSelfSignedCertificateFieldNumber = 4,
  };
  // optional string host = 3;
  bool has_host() const;
  void clear_host() ;
  const std::string& host() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_host(Arg_&& arg, Args_... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* value);

  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(
      const std::string& value);
  std::string* _internal_mutable_host();

  public:
  // uint32 port = 1;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // bool tls = 2;
  void clear_tls() ;
  bool tls() const;
  void set_tls(bool value);

  private:
  bool _internal_tls() const;
  void _internal_set_tls(bool value);

  public:
  // bool allowSelfSignedCertificate = 4;
  void clear_allowselfsignedcertificate() ;
  bool allowselfsignedcertificate() const;
  void set_allowselfsignedcertificate(bool value);

  private:
  bool _internal_allowselfsignedcertificate() const;
  void _internal_set_allowselfsignedcertificate(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dht.ConnectivityRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr host_;
    ::uint32_t port_;
    bool tls_;
    bool allowselfsignedcertificate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class ConnectivityMethod final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.ConnectivityMethod) */ {
 public:
  inline ConnectivityMethod() : ConnectivityMethod(nullptr) {}
  ~ConnectivityMethod() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConnectivityMethod(::google::protobuf::internal::ConstantInitialized);

  inline ConnectivityMethod(const ConnectivityMethod& from)
      : ConnectivityMethod(nullptr, from) {}
  ConnectivityMethod(ConnectivityMethod&& from) noexcept
    : ConnectivityMethod() {
    *this = ::std::move(from);
  }

  inline ConnectivityMethod& operator=(const ConnectivityMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectivityMethod& operator=(ConnectivityMethod&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectivityMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectivityMethod* internal_default_instance() {
    return reinterpret_cast<const ConnectivityMethod*>(
               &_ConnectivityMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ConnectivityMethod& a, ConnectivityMethod& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectivityMethod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectivityMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectivityMethod* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectivityMethod>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConnectivityMethod* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.ConnectivityMethod";
  }
  protected:
  explicit ConnectivityMethod(::google::protobuf::Arena* arena);
  ConnectivityMethod(::google::protobuf::Arena* arena, const ConnectivityMethod& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 2,
    kPortFieldNumber = 1,
    kTlsFieldNumber = 3,
  };
  // string host = 2;
  void clear_host() ;
  const std::string& host() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_host(Arg_&& arg, Args_... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* value);

  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(
      const std::string& value);
  std::string* _internal_mutable_host();

  public:
  // uint32 port = 1;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // bool tls = 3;
  void clear_tls() ;
  bool tls() const;
  void set_tls(bool value);

  private:
  bool _internal_tls() const;
  void _internal_set_tls(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dht.ConnectivityMethod)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr host_;
    ::uint32_t port_;
    bool tls_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class ClosestRingPeersRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.ClosestRingPeersRequest) */ {
 public:
  inline ClosestRingPeersRequest() : ClosestRingPeersRequest(nullptr) {}
  ~ClosestRingPeersRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ClosestRingPeersRequest(::google::protobuf::internal::ConstantInitialized);

  inline ClosestRingPeersRequest(const ClosestRingPeersRequest& from)
      : ClosestRingPeersRequest(nullptr, from) {}
  ClosestRingPeersRequest(ClosestRingPeersRequest&& from) noexcept
    : ClosestRingPeersRequest() {
    *this = ::std::move(from);
  }

  inline ClosestRingPeersRequest& operator=(const ClosestRingPeersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClosestRingPeersRequest& operator=(ClosestRingPeersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClosestRingPeersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClosestRingPeersRequest* internal_default_instance() {
    return reinterpret_cast<const ClosestRingPeersRequest*>(
               &_ClosestRingPeersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ClosestRingPeersRequest& a, ClosestRingPeersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClosestRingPeersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClosestRingPeersRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClosestRingPeersRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClosestRingPeersRequest>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ClosestRingPeersRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.ClosestRingPeersRequest";
  }
  protected:
  explicit ClosestRingPeersRequest(::google::protobuf::Arena* arena);
  ClosestRingPeersRequest(::google::protobuf::Arena* arena, const ClosestRingPeersRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRingIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
  };
  // bytes ringId = 1;
  void clear_ringid() ;
  const std::string& ringid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ringid(Arg_&& arg, Args_... args);
  std::string* mutable_ringid();
  PROTOBUF_NODISCARD std::string* release_ringid();
  void set_allocated_ringid(std::string* value);

  private:
  const std::string& _internal_ringid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ringid(
      const std::string& value);
  std::string* _internal_mutable_ringid();

  public:
  // string requestId = 2;
  void clear_requestid() ;
  const std::string& requestid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestid(Arg_&& arg, Args_... args);
  std::string* mutable_requestid();
  PROTOBUF_NODISCARD std::string* release_requestid();
  void set_allocated_requestid(std::string* value);

  private:
  const std::string& _internal_requestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestid(
      const std::string& value);
  std::string* _internal_mutable_requestid();

  public:
  // @@protoc_insertion_point(class_scope:dht.ClosestRingPeersRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr ringid_;
    ::google::protobuf::internal::ArenaStringPtr requestid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class ClosestPeersRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.ClosestPeersRequest) */ {
 public:
  inline ClosestPeersRequest() : ClosestPeersRequest(nullptr) {}
  ~ClosestPeersRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ClosestPeersRequest(::google::protobuf::internal::ConstantInitialized);

  inline ClosestPeersRequest(const ClosestPeersRequest& from)
      : ClosestPeersRequest(nullptr, from) {}
  ClosestPeersRequest(ClosestPeersRequest&& from) noexcept
    : ClosestPeersRequest() {
    *this = ::std::move(from);
  }

  inline ClosestPeersRequest& operator=(const ClosestPeersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClosestPeersRequest& operator=(ClosestPeersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClosestPeersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClosestPeersRequest* internal_default_instance() {
    return reinterpret_cast<const ClosestPeersRequest*>(
               &_ClosestPeersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ClosestPeersRequest& a, ClosestPeersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClosestPeersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClosestPeersRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClosestPeersRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClosestPeersRequest>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ClosestPeersRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.ClosestPeersRequest";
  }
  protected:
  explicit ClosestPeersRequest(::google::protobuf::Arena* arena);
  ClosestPeersRequest(::google::protobuf::Arena* arena, const ClosestPeersRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
  };
  // bytes nodeId = 1;
  void clear_nodeid() ;
  const std::string& nodeid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nodeid(Arg_&& arg, Args_... args);
  std::string* mutable_nodeid();
  PROTOBUF_NODISCARD std::string* release_nodeid();
  void set_allocated_nodeid(std::string* value);

  private:
  const std::string& _internal_nodeid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nodeid(
      const std::string& value);
  std::string* _internal_mutable_nodeid();

  public:
  // string requestId = 2;
  void clear_requestid() ;
  const std::string& requestid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestid(Arg_&& arg, Args_... args);
  std::string* mutable_requestid();
  PROTOBUF_NODISCARD std::string* release_requestid();
  void set_allocated_requestid(std::string* value);

  private:
  const std::string& _internal_requestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestid(
      const std::string& value);
  std::string* _internal_mutable_requestid();

  public:
  // @@protoc_insertion_point(class_scope:dht.ClosestPeersRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr nodeid_;
    ::google::protobuf::internal::ArenaStringPtr requestid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class StoreDataRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.StoreDataRequest) */ {
 public:
  inline StoreDataRequest() : StoreDataRequest(nullptr) {}
  ~StoreDataRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StoreDataRequest(::google::protobuf::internal::ConstantInitialized);

  inline StoreDataRequest(const StoreDataRequest& from)
      : StoreDataRequest(nullptr, from) {}
  StoreDataRequest(StoreDataRequest&& from) noexcept
    : StoreDataRequest() {
    *this = ::std::move(from);
  }

  inline StoreDataRequest& operator=(const StoreDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreDataRequest& operator=(StoreDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreDataRequest* internal_default_instance() {
    return reinterpret_cast<const StoreDataRequest*>(
               &_StoreDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StoreDataRequest& a, StoreDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreDataRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreDataRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreDataRequest>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StoreDataRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.StoreDataRequest";
  }
  protected:
  explicit StoreDataRequest(::google::protobuf::Arena* arena);
  StoreDataRequest(::google::protobuf::Arena* arena, const StoreDataRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kCreatorFieldNumber = 3,
    kDataFieldNumber = 2,
    kCreatedAtFieldNumber = 4,
    kTtlFieldNumber = 5,
  };
  // bytes key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes creator = 3;
  void clear_creator() ;
  const std::string& creator() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creator(Arg_&& arg, Args_... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* value);

  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(
      const std::string& value);
  std::string* _internal_mutable_creator();

  public:
  // .google.protobuf.Any data = 2;
  bool has_data() const;
  void clear_data() ;
  const ::google::protobuf::Any& data() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_data();
  ::google::protobuf::Any* mutable_data();
  void set_allocated_data(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_data(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_data();

  private:
  const ::google::protobuf::Any& _internal_data() const;
  ::google::protobuf::Any* _internal_mutable_data();

  public:
  // .google.protobuf.Timestamp createdAt = 4;
  bool has_createdat() const;
  void clear_createdat() ;
  const ::google::protobuf::Timestamp& createdat() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_createdat();
  ::google::protobuf::Timestamp* mutable_createdat();
  void set_allocated_createdat(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_createdat(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_createdat();

  private:
  const ::google::protobuf::Timestamp& _internal_createdat() const;
  ::google::protobuf::Timestamp* _internal_mutable_createdat();

  public:
  // uint32 ttl = 5;
  void clear_ttl() ;
  ::uint32_t ttl() const;
  void set_ttl(::uint32_t value);

  private:
  ::uint32_t _internal_ttl() const;
  void _internal_set_ttl(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dht.StoreDataRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr creator_;
    ::google::protobuf::Any* data_;
    ::google::protobuf::Timestamp* createdat_;
    ::uint32_t ttl_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class PeerDescriptor final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.PeerDescriptor) */ {
 public:
  inline PeerDescriptor() : PeerDescriptor(nullptr) {}
  ~PeerDescriptor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PeerDescriptor(::google::protobuf::internal::ConstantInitialized);

  inline PeerDescriptor(const PeerDescriptor& from)
      : PeerDescriptor(nullptr, from) {}
  PeerDescriptor(PeerDescriptor&& from) noexcept
    : PeerDescriptor() {
    *this = ::std::move(from);
  }

  inline PeerDescriptor& operator=(const PeerDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerDescriptor& operator=(PeerDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerDescriptor* internal_default_instance() {
    return reinterpret_cast<const PeerDescriptor*>(
               &_PeerDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PeerDescriptor& a, PeerDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerDescriptor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerDescriptor* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerDescriptor>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PeerDescriptor* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.PeerDescriptor";
  }
  protected:
  explicit PeerDescriptor(::google::protobuf::Arena* arena);
  PeerDescriptor(::google::protobuf::Arena* arena, const PeerDescriptor& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kPublicKeyFieldNumber = 8,
    kSignatureFieldNumber = 9,
    kUdpFieldNumber = 3,
    kTcpFieldNumber = 4,
    kWebsocketFieldNumber = 5,
    kTypeFieldNumber = 2,
    kRegionFieldNumber = 6,
    kIpAddressFieldNumber = 7,
  };
  // bytes nodeId = 1;
  void clear_nodeid() ;
  const std::string& nodeid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nodeid(Arg_&& arg, Args_... args);
  std::string* mutable_nodeid();
  PROTOBUF_NODISCARD std::string* release_nodeid();
  void set_allocated_nodeid(std::string* value);

  private:
  const std::string& _internal_nodeid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nodeid(
      const std::string& value);
  std::string* _internal_mutable_nodeid();

  public:
  // optional bytes publicKey = 8;
  bool has_publickey() const;
  void clear_publickey() ;
  const std::string& publickey() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_publickey(Arg_&& arg, Args_... args);
  std::string* mutable_publickey();
  PROTOBUF_NODISCARD std::string* release_publickey();
  void set_allocated_publickey(std::string* value);

  private:
  const std::string& _internal_publickey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publickey(
      const std::string& value);
  std::string* _internal_mutable_publickey();

  public:
  // optional bytes signature = 9;
  bool has_signature() const;
  void clear_signature() ;
  const std::string& signature() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signature(Arg_&& arg, Args_... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* value);

  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(
      const std::string& value);
  std::string* _internal_mutable_signature();

  public:
  // .dht.ConnectivityMethod udp = 3;
  bool has_udp() const;
  void clear_udp() ;
  const ::dht::ConnectivityMethod& udp() const;
  PROTOBUF_NODISCARD ::dht::ConnectivityMethod* release_udp();
  ::dht::ConnectivityMethod* mutable_udp();
  void set_allocated_udp(::dht::ConnectivityMethod* value);
  void unsafe_arena_set_allocated_udp(::dht::ConnectivityMethod* value);
  ::dht::ConnectivityMethod* unsafe_arena_release_udp();

  private:
  const ::dht::ConnectivityMethod& _internal_udp() const;
  ::dht::ConnectivityMethod* _internal_mutable_udp();

  public:
  // .dht.ConnectivityMethod tcp = 4;
  bool has_tcp() const;
  void clear_tcp() ;
  const ::dht::ConnectivityMethod& tcp() const;
  PROTOBUF_NODISCARD ::dht::ConnectivityMethod* release_tcp();
  ::dht::ConnectivityMethod* mutable_tcp();
  void set_allocated_tcp(::dht::ConnectivityMethod* value);
  void unsafe_arena_set_allocated_tcp(::dht::ConnectivityMethod* value);
  ::dht::ConnectivityMethod* unsafe_arena_release_tcp();

  private:
  const ::dht::ConnectivityMethod& _internal_tcp() const;
  ::dht::ConnectivityMethod* _internal_mutable_tcp();

  public:
  // .dht.ConnectivityMethod websocket = 5;
  bool has_websocket() const;
  void clear_websocket() ;
  const ::dht::ConnectivityMethod& websocket() const;
  PROTOBUF_NODISCARD ::dht::ConnectivityMethod* release_websocket();
  ::dht::ConnectivityMethod* mutable_websocket();
  void set_allocated_websocket(::dht::ConnectivityMethod* value);
  void unsafe_arena_set_allocated_websocket(::dht::ConnectivityMethod* value);
  ::dht::ConnectivityMethod* unsafe_arena_release_websocket();

  private:
  const ::dht::ConnectivityMethod& _internal_websocket() const;
  ::dht::ConnectivityMethod* _internal_mutable_websocket();

  public:
  // .dht.NodeType type = 2;
  void clear_type() ;
  ::dht::NodeType type() const;
  void set_type(::dht::NodeType value);

  private:
  ::dht::NodeType _internal_type() const;
  void _internal_set_type(::dht::NodeType value);

  public:
  // optional uint32 region = 6;
  bool has_region() const;
  void clear_region() ;
  ::uint32_t region() const;
  void set_region(::uint32_t value);

  private:
  ::uint32_t _internal_region() const;
  void _internal_set_region(::uint32_t value);

  public:
  // optional uint32 ipAddress = 7;
  bool has_ipaddress() const;
  void clear_ipaddress() ;
  ::uint32_t ipaddress() const;
  void set_ipaddress(::uint32_t value);

  private:
  ::uint32_t _internal_ipaddress() const;
  void _internal_set_ipaddress(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dht.PeerDescriptor)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nodeid_;
    ::google::protobuf::internal::ArenaStringPtr publickey_;
    ::google::protobuf::internal::ArenaStringPtr signature_;
    ::dht::ConnectivityMethod* udp_;
    ::dht::ConnectivityMethod* tcp_;
    ::dht::ConnectivityMethod* websocket_;
    int type_;
    ::uint32_t region_;
    ::uint32_t ipaddress_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class ExternalStoreDataRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.ExternalStoreDataRequest) */ {
 public:
  inline ExternalStoreDataRequest() : ExternalStoreDataRequest(nullptr) {}
  ~ExternalStoreDataRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExternalStoreDataRequest(::google::protobuf::internal::ConstantInitialized);

  inline ExternalStoreDataRequest(const ExternalStoreDataRequest& from)
      : ExternalStoreDataRequest(nullptr, from) {}
  ExternalStoreDataRequest(ExternalStoreDataRequest&& from) noexcept
    : ExternalStoreDataRequest() {
    *this = ::std::move(from);
  }

  inline ExternalStoreDataRequest& operator=(const ExternalStoreDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalStoreDataRequest& operator=(ExternalStoreDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExternalStoreDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternalStoreDataRequest* internal_default_instance() {
    return reinterpret_cast<const ExternalStoreDataRequest*>(
               &_ExternalStoreDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ExternalStoreDataRequest& a, ExternalStoreDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExternalStoreDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalStoreDataRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExternalStoreDataRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExternalStoreDataRequest>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExternalStoreDataRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.ExternalStoreDataRequest";
  }
  protected:
  explicit ExternalStoreDataRequest(::google::protobuf::Arena* arena);
  ExternalStoreDataRequest(::google::protobuf::Arena* arena, const ExternalStoreDataRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // bytes key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // .google.protobuf.Any data = 2;
  bool has_data() const;
  void clear_data() ;
  const ::google::protobuf::Any& data() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_data();
  ::google::protobuf::Any* mutable_data();
  void set_allocated_data(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_data(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_data();

  private:
  const ::google::protobuf::Any& _internal_data() const;
  ::google::protobuf::Any* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:dht.ExternalStoreDataRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::Any* data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class DataEntry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.DataEntry) */ {
 public:
  inline DataEntry() : DataEntry(nullptr) {}
  ~DataEntry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DataEntry(::google::protobuf::internal::ConstantInitialized);

  inline DataEntry(const DataEntry& from)
      : DataEntry(nullptr, from) {}
  DataEntry(DataEntry&& from) noexcept
    : DataEntry() {
    *this = ::std::move(from);
  }

  inline DataEntry& operator=(const DataEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataEntry& operator=(DataEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataEntry* internal_default_instance() {
    return reinterpret_cast<const DataEntry*>(
               &_DataEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DataEntry& a, DataEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(DataEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataEntry* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataEntry>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DataEntry* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.DataEntry";
  }
  protected:
  explicit DataEntry(::google::protobuf::Arena* arena);
  DataEntry(::google::protobuf::Arena* arena, const DataEntry& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kCreatorFieldNumber = 3,
    kDataFieldNumber = 2,
    kCreatedAtFieldNumber = 4,
    kStoredAtFieldNumber = 5,
    kTtlFieldNumber = 6,
    kStaleFieldNumber = 7,
    kDeletedFieldNumber = 8,
  };
  // bytes key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes creator = 3;
  void clear_creator() ;
  const std::string& creator() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creator(Arg_&& arg, Args_... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* value);

  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(
      const std::string& value);
  std::string* _internal_mutable_creator();

  public:
  // .google.protobuf.Any data = 2;
  bool has_data() const;
  void clear_data() ;
  const ::google::protobuf::Any& data() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_data();
  ::google::protobuf::Any* mutable_data();
  void set_allocated_data(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_data(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_data();

  private:
  const ::google::protobuf::Any& _internal_data() const;
  ::google::protobuf::Any* _internal_mutable_data();

  public:
  // .google.protobuf.Timestamp createdAt = 4;
  bool has_createdat() const;
  void clear_createdat() ;
  const ::google::protobuf::Timestamp& createdat() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_createdat();
  ::google::protobuf::Timestamp* mutable_createdat();
  void set_allocated_createdat(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_createdat(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_createdat();

  private:
  const ::google::protobuf::Timestamp& _internal_createdat() const;
  ::google::protobuf::Timestamp* _internal_mutable_createdat();

  public:
  // .google.protobuf.Timestamp storedAt = 5;
  bool has_storedat() const;
  void clear_storedat() ;
  const ::google::protobuf::Timestamp& storedat() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_storedat();
  ::google::protobuf::Timestamp* mutable_storedat();
  void set_allocated_storedat(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_storedat(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_storedat();

  private:
  const ::google::protobuf::Timestamp& _internal_storedat() const;
  ::google::protobuf::Timestamp* _internal_mutable_storedat();

  public:
  // uint32 ttl = 6;
  void clear_ttl() ;
  ::uint32_t ttl() const;
  void set_ttl(::uint32_t value);

  private:
  ::uint32_t _internal_ttl() const;
  void _internal_set_ttl(::uint32_t value);

  public:
  // bool stale = 7;
  void clear_stale() ;
  bool stale() const;
  void set_stale(bool value);

  private:
  bool _internal_stale() const;
  void _internal_set_stale(bool value);

  public:
  // bool deleted = 8;
  void clear_deleted() ;
  bool deleted() const;
  void set_deleted(bool value);

  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dht.DataEntry)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr creator_;
    ::google::protobuf::Any* data_;
    ::google::protobuf::Timestamp* createdat_;
    ::google::protobuf::Timestamp* storedat_;
    ::uint32_t ttl_;
    bool stale_;
    bool deleted_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class ConnectivityResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.ConnectivityResponse) */ {
 public:
  inline ConnectivityResponse() : ConnectivityResponse(nullptr) {}
  ~ConnectivityResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConnectivityResponse(::google::protobuf::internal::ConstantInitialized);

  inline ConnectivityResponse(const ConnectivityResponse& from)
      : ConnectivityResponse(nullptr, from) {}
  ConnectivityResponse(ConnectivityResponse&& from) noexcept
    : ConnectivityResponse() {
    *this = ::std::move(from);
  }

  inline ConnectivityResponse& operator=(const ConnectivityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectivityResponse& operator=(ConnectivityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectivityResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectivityResponse* internal_default_instance() {
    return reinterpret_cast<const ConnectivityResponse*>(
               &_ConnectivityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ConnectivityResponse& a, ConnectivityResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectivityResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectivityResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectivityResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectivityResponse>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConnectivityResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.ConnectivityResponse";
  }
  protected:
  explicit ConnectivityResponse(::google::protobuf::Arena* arena);
  ConnectivityResponse(::google::protobuf::Arena* arena, const ConnectivityResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 1,
    kNatTypeFieldNumber = 2,
    kVersionFieldNumber = 5,
    kWebsocketFieldNumber = 3,
    kLatitudeFieldNumber = 6,
    kLongitudeFieldNumber = 7,
    kIpAddressFieldNumber = 4,
  };
  // string host = 1;
  void clear_host() ;
  const std::string& host() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_host(Arg_&& arg, Args_... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* value);

  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(
      const std::string& value);
  std::string* _internal_mutable_host();

  public:
  // string natType = 2;
  void clear_nattype() ;
  const std::string& nattype() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nattype(Arg_&& arg, Args_... args);
  std::string* mutable_nattype();
  PROTOBUF_NODISCARD std::string* release_nattype();
  void set_allocated_nattype(std::string* value);

  private:
  const std::string& _internal_nattype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nattype(
      const std::string& value);
  std::string* _internal_mutable_nattype();

  public:
  // string version = 5;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // .dht.ConnectivityMethod websocket = 3;
  bool has_websocket() const;
  void clear_websocket() ;
  const ::dht::ConnectivityMethod& websocket() const;
  PROTOBUF_NODISCARD ::dht::ConnectivityMethod* release_websocket();
  ::dht::ConnectivityMethod* mutable_websocket();
  void set_allocated_websocket(::dht::ConnectivityMethod* value);
  void unsafe_arena_set_allocated_websocket(::dht::ConnectivityMethod* value);
  ::dht::ConnectivityMethod* unsafe_arena_release_websocket();

  private:
  const ::dht::ConnectivityMethod& _internal_websocket() const;
  ::dht::ConnectivityMethod* _internal_mutable_websocket();

  public:
  // optional double latitude = 6;
  bool has_latitude() const;
  void clear_latitude() ;
  double latitude() const;
  void set_latitude(double value);

  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);

  public:
  // optional double longitude = 7;
  bool has_longitude() const;
  void clear_longitude() ;
  double longitude() const;
  void set_longitude(double value);

  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);

  public:
  // uint32 ipAddress = 4;
  void clear_ipaddress() ;
  ::uint32_t ipaddress() const;
  void set_ipaddress(::uint32_t value);

  private:
  ::uint32_t _internal_ipaddress() const;
  void _internal_set_ipaddress(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dht.ConnectivityResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr host_;
    ::google::protobuf::internal::ArenaStringPtr nattype_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::dht::ConnectivityMethod* websocket_;
    double latitude_;
    double longitude_;
    ::uint32_t ipaddress_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class ReplicateDataRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.ReplicateDataRequest) */ {
 public:
  inline ReplicateDataRequest() : ReplicateDataRequest(nullptr) {}
  ~ReplicateDataRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ReplicateDataRequest(::google::protobuf::internal::ConstantInitialized);

  inline ReplicateDataRequest(const ReplicateDataRequest& from)
      : ReplicateDataRequest(nullptr, from) {}
  ReplicateDataRequest(ReplicateDataRequest&& from) noexcept
    : ReplicateDataRequest() {
    *this = ::std::move(from);
  }

  inline ReplicateDataRequest& operator=(const ReplicateDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicateDataRequest& operator=(ReplicateDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplicateDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplicateDataRequest* internal_default_instance() {
    return reinterpret_cast<const ReplicateDataRequest*>(
               &_ReplicateDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ReplicateDataRequest& a, ReplicateDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplicateDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplicateDataRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplicateDataRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReplicateDataRequest>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReplicateDataRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.ReplicateDataRequest";
  }
  protected:
  explicit ReplicateDataRequest(::google::protobuf::Arena* arena);
  ReplicateDataRequest(::google::protobuf::Arena* arena, const ReplicateDataRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 1,
  };
  // .dht.DataEntry entry = 1;
  bool has_entry() const;
  void clear_entry() ;
  const ::dht::DataEntry& entry() const;
  PROTOBUF_NODISCARD ::dht::DataEntry* release_entry();
  ::dht::DataEntry* mutable_entry();
  void set_allocated_entry(::dht::DataEntry* value);
  void unsafe_arena_set_allocated_entry(::dht::DataEntry* value);
  ::dht::DataEntry* unsafe_arena_release_entry();

  private:
  const ::dht::DataEntry& _internal_entry() const;
  ::dht::DataEntry* _internal_mutable_entry();

  public:
  // @@protoc_insertion_point(class_scope:dht.ReplicateDataRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::dht::DataEntry* entry_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class RecursiveOperationResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.RecursiveOperationResponse) */ {
 public:
  inline RecursiveOperationResponse() : RecursiveOperationResponse(nullptr) {}
  ~RecursiveOperationResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecursiveOperationResponse(::google::protobuf::internal::ConstantInitialized);

  inline RecursiveOperationResponse(const RecursiveOperationResponse& from)
      : RecursiveOperationResponse(nullptr, from) {}
  RecursiveOperationResponse(RecursiveOperationResponse&& from) noexcept
    : RecursiveOperationResponse() {
    *this = ::std::move(from);
  }

  inline RecursiveOperationResponse& operator=(const RecursiveOperationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecursiveOperationResponse& operator=(RecursiveOperationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecursiveOperationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecursiveOperationResponse* internal_default_instance() {
    return reinterpret_cast<const RecursiveOperationResponse*>(
               &_RecursiveOperationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RecursiveOperationResponse& a, RecursiveOperationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RecursiveOperationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecursiveOperationResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecursiveOperationResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecursiveOperationResponse>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecursiveOperationResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.RecursiveOperationResponse";
  }
  protected:
  explicit RecursiveOperationResponse(::google::protobuf::Arena* arena);
  RecursiveOperationResponse(::google::protobuf::Arena* arena, const RecursiveOperationResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClosestConnectedNodesFieldNumber = 1,
    kDataEntriesFieldNumber = 2,
    kRoutingPathFieldNumber = 4,
    kNoCloserNodesFoundFieldNumber = 3,
  };
  // repeated .dht.PeerDescriptor closestConnectedNodes = 1;
  int closestconnectednodes_size() const;
  private:
  int _internal_closestconnectednodes_size() const;

  public:
  void clear_closestconnectednodes() ;
  ::dht::PeerDescriptor* mutable_closestconnectednodes(int index);
  ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >*
      mutable_closestconnectednodes();
  private:
  const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& _internal_closestconnectednodes() const;
  ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* _internal_mutable_closestconnectednodes();
  public:
  const ::dht::PeerDescriptor& closestconnectednodes(int index) const;
  ::dht::PeerDescriptor* add_closestconnectednodes();
  const ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >&
      closestconnectednodes() const;
  // repeated .dht.DataEntry dataEntries = 2;
  int dataentries_size() const;
  private:
  int _internal_dataentries_size() const;

  public:
  void clear_dataentries() ;
  ::dht::DataEntry* mutable_dataentries(int index);
  ::google::protobuf::RepeatedPtrField< ::dht::DataEntry >*
      mutable_dataentries();
  private:
  const ::google::protobuf::RepeatedPtrField<::dht::DataEntry>& _internal_dataentries() const;
  ::google::protobuf::RepeatedPtrField<::dht::DataEntry>* _internal_mutable_dataentries();
  public:
  const ::dht::DataEntry& dataentries(int index) const;
  ::dht::DataEntry* add_dataentries();
  const ::google::protobuf::RepeatedPtrField< ::dht::DataEntry >&
      dataentries() const;
  // repeated .dht.PeerDescriptor routingPath = 4;
  int routingpath_size() const;
  private:
  int _internal_routingpath_size() const;

  public:
  void clear_routingpath() ;
  ::dht::PeerDescriptor* mutable_routingpath(int index);
  ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >*
      mutable_routingpath();
  private:
  const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& _internal_routingpath() const;
  ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* _internal_mutable_routingpath();
  public:
  const ::dht::PeerDescriptor& routingpath(int index) const;
  ::dht::PeerDescriptor* add_routingpath();
  const ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >&
      routingpath() const;
  // bool noCloserNodesFound = 3;
  void clear_noclosernodesfound() ;
  bool noclosernodesfound() const;
  void set_noclosernodesfound(bool value);

  private:
  bool _internal_noclosernodesfound() const;
  void _internal_set_noclosernodesfound(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dht.RecursiveOperationResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor > closestconnectednodes_;
    ::google::protobuf::RepeatedPtrField< ::dht::DataEntry > dataentries_;
    ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor > routingpath_;
    bool noclosernodesfound_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class HandshakeResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.HandshakeResponse) */ {
 public:
  inline HandshakeResponse() : HandshakeResponse(nullptr) {}
  ~HandshakeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HandshakeResponse(::google::protobuf::internal::ConstantInitialized);

  inline HandshakeResponse(const HandshakeResponse& from)
      : HandshakeResponse(nullptr, from) {}
  HandshakeResponse(HandshakeResponse&& from) noexcept
    : HandshakeResponse() {
    *this = ::std::move(from);
  }

  inline HandshakeResponse& operator=(const HandshakeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandshakeResponse& operator=(HandshakeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandshakeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandshakeResponse* internal_default_instance() {
    return reinterpret_cast<const HandshakeResponse*>(
               &_HandshakeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(HandshakeResponse& a, HandshakeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HandshakeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandshakeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandshakeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandshakeResponse>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HandshakeResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.HandshakeResponse";
  }
  protected:
  explicit HandshakeResponse(::google::protobuf::Arena* arena);
  HandshakeResponse(::google::protobuf::Arena* arena, const HandshakeResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 3,
    kSourcePeerDescriptorFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string version = 3;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // .dht.PeerDescriptor sourcePeerDescriptor = 1;
  bool has_sourcepeerdescriptor() const;
  void clear_sourcepeerdescriptor() ;
  const ::dht::PeerDescriptor& sourcepeerdescriptor() const;
  PROTOBUF_NODISCARD ::dht::PeerDescriptor* release_sourcepeerdescriptor();
  ::dht::PeerDescriptor* mutable_sourcepeerdescriptor();
  void set_allocated_sourcepeerdescriptor(::dht::PeerDescriptor* value);
  void unsafe_arena_set_allocated_sourcepeerdescriptor(::dht::PeerDescriptor* value);
  ::dht::PeerDescriptor* unsafe_arena_release_sourcepeerdescriptor();

  private:
  const ::dht::PeerDescriptor& _internal_sourcepeerdescriptor() const;
  ::dht::PeerDescriptor* _internal_mutable_sourcepeerdescriptor();

  public:
  // optional .dht.HandshakeError error = 2;
  bool has_error() const;
  void clear_error() ;
  ::dht::HandshakeError error() const;
  void set_error(::dht::HandshakeError value);

  private:
  ::dht::HandshakeError _internal_error() const;
  void _internal_set_error(::dht::HandshakeError value);

  public:
  // @@protoc_insertion_point(class_scope:dht.HandshakeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::dht::PeerDescriptor* sourcepeerdescriptor_;
    int error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class HandshakeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.HandshakeRequest) */ {
 public:
  inline HandshakeRequest() : HandshakeRequest(nullptr) {}
  ~HandshakeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HandshakeRequest(::google::protobuf::internal::ConstantInitialized);

  inline HandshakeRequest(const HandshakeRequest& from)
      : HandshakeRequest(nullptr, from) {}
  HandshakeRequest(HandshakeRequest&& from) noexcept
    : HandshakeRequest() {
    *this = ::std::move(from);
  }

  inline HandshakeRequest& operator=(const HandshakeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandshakeRequest& operator=(HandshakeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandshakeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandshakeRequest* internal_default_instance() {
    return reinterpret_cast<const HandshakeRequest*>(
               &_HandshakeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(HandshakeRequest& a, HandshakeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HandshakeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandshakeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandshakeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandshakeRequest>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HandshakeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.HandshakeRequest";
  }
  protected:
  explicit HandshakeRequest(::google::protobuf::Arena* arena);
  HandshakeRequest(::google::protobuf::Arena* arena, const HandshakeRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 3,
    kSourcePeerDescriptorFieldNumber = 1,
    kTargetPeerDescriptorFieldNumber = 2,
  };
  // string version = 3;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // .dht.PeerDescriptor sourcePeerDescriptor = 1;
  bool has_sourcepeerdescriptor() const;
  void clear_sourcepeerdescriptor() ;
  const ::dht::PeerDescriptor& sourcepeerdescriptor() const;
  PROTOBUF_NODISCARD ::dht::PeerDescriptor* release_sourcepeerdescriptor();
  ::dht::PeerDescriptor* mutable_sourcepeerdescriptor();
  void set_allocated_sourcepeerdescriptor(::dht::PeerDescriptor* value);
  void unsafe_arena_set_allocated_sourcepeerdescriptor(::dht::PeerDescriptor* value);
  ::dht::PeerDescriptor* unsafe_arena_release_sourcepeerdescriptor();

  private:
  const ::dht::PeerDescriptor& _internal_sourcepeerdescriptor() const;
  ::dht::PeerDescriptor* _internal_mutable_sourcepeerdescriptor();

  public:
  // optional .dht.PeerDescriptor targetPeerDescriptor = 2;
  bool has_targetpeerdescriptor() const;
  void clear_targetpeerdescriptor() ;
  const ::dht::PeerDescriptor& targetpeerdescriptor() const;
  PROTOBUF_NODISCARD ::dht::PeerDescriptor* release_targetpeerdescriptor();
  ::dht::PeerDescriptor* mutable_targetpeerdescriptor();
  void set_allocated_targetpeerdescriptor(::dht::PeerDescriptor* value);
  void unsafe_arena_set_allocated_targetpeerdescriptor(::dht::PeerDescriptor* value);
  ::dht::PeerDescriptor* unsafe_arena_release_targetpeerdescriptor();

  private:
  const ::dht::PeerDescriptor& _internal_targetpeerdescriptor() const;
  ::dht::PeerDescriptor* _internal_mutable_targetpeerdescriptor();

  public:
  // @@protoc_insertion_point(class_scope:dht.HandshakeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::dht::PeerDescriptor* sourcepeerdescriptor_;
    ::dht::PeerDescriptor* targetpeerdescriptor_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class ExternalStoreDataResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.ExternalStoreDataResponse) */ {
 public:
  inline ExternalStoreDataResponse() : ExternalStoreDataResponse(nullptr) {}
  ~ExternalStoreDataResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExternalStoreDataResponse(::google::protobuf::internal::ConstantInitialized);

  inline ExternalStoreDataResponse(const ExternalStoreDataResponse& from)
      : ExternalStoreDataResponse(nullptr, from) {}
  ExternalStoreDataResponse(ExternalStoreDataResponse&& from) noexcept
    : ExternalStoreDataResponse() {
    *this = ::std::move(from);
  }

  inline ExternalStoreDataResponse& operator=(const ExternalStoreDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalStoreDataResponse& operator=(ExternalStoreDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExternalStoreDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternalStoreDataResponse* internal_default_instance() {
    return reinterpret_cast<const ExternalStoreDataResponse*>(
               &_ExternalStoreDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ExternalStoreDataResponse& a, ExternalStoreDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExternalStoreDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalStoreDataResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExternalStoreDataResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExternalStoreDataResponse>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExternalStoreDataResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.ExternalStoreDataResponse";
  }
  protected:
  explicit ExternalStoreDataResponse(::google::protobuf::Arena* arena);
  ExternalStoreDataResponse(::google::protobuf::Arena* arena, const ExternalStoreDataResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStorersFieldNumber = 1,
  };
  // repeated .dht.PeerDescriptor storers = 1;
  int storers_size() const;
  private:
  int _internal_storers_size() const;

  public:
  void clear_storers() ;
  ::dht::PeerDescriptor* mutable_storers(int index);
  ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >*
      mutable_storers();
  private:
  const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& _internal_storers() const;
  ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* _internal_mutable_storers();
  public:
  const ::dht::PeerDescriptor& storers(int index) const;
  ::dht::PeerDescriptor* add_storers();
  const ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >&
      storers() const;
  // @@protoc_insertion_point(class_scope:dht.ExternalStoreDataResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor > storers_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class ExternalFetchDataResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.ExternalFetchDataResponse) */ {
 public:
  inline ExternalFetchDataResponse() : ExternalFetchDataResponse(nullptr) {}
  ~ExternalFetchDataResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExternalFetchDataResponse(::google::protobuf::internal::ConstantInitialized);

  inline ExternalFetchDataResponse(const ExternalFetchDataResponse& from)
      : ExternalFetchDataResponse(nullptr, from) {}
  ExternalFetchDataResponse(ExternalFetchDataResponse&& from) noexcept
    : ExternalFetchDataResponse() {
    *this = ::std::move(from);
  }

  inline ExternalFetchDataResponse& operator=(const ExternalFetchDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalFetchDataResponse& operator=(ExternalFetchDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExternalFetchDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternalFetchDataResponse* internal_default_instance() {
    return reinterpret_cast<const ExternalFetchDataResponse*>(
               &_ExternalFetchDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ExternalFetchDataResponse& a, ExternalFetchDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExternalFetchDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalFetchDataResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExternalFetchDataResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExternalFetchDataResponse>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExternalFetchDataResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.ExternalFetchDataResponse";
  }
  protected:
  explicit ExternalFetchDataResponse(::google::protobuf::Arena* arena);
  ExternalFetchDataResponse(::google::protobuf::Arena* arena, const ExternalFetchDataResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .dht.DataEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::dht::DataEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::dht::DataEntry >*
      mutable_entries();
  private:
  const ::google::protobuf::RepeatedPtrField<::dht::DataEntry>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::dht::DataEntry>* _internal_mutable_entries();
  public:
  const ::dht::DataEntry& entries(int index) const;
  ::dht::DataEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField< ::dht::DataEntry >&
      entries() const;
  // @@protoc_insertion_point(class_scope:dht.ExternalFetchDataResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::dht::DataEntry > entries_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class ClosestRingPeersResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.ClosestRingPeersResponse) */ {
 public:
  inline ClosestRingPeersResponse() : ClosestRingPeersResponse(nullptr) {}
  ~ClosestRingPeersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ClosestRingPeersResponse(::google::protobuf::internal::ConstantInitialized);

  inline ClosestRingPeersResponse(const ClosestRingPeersResponse& from)
      : ClosestRingPeersResponse(nullptr, from) {}
  ClosestRingPeersResponse(ClosestRingPeersResponse&& from) noexcept
    : ClosestRingPeersResponse() {
    *this = ::std::move(from);
  }

  inline ClosestRingPeersResponse& operator=(const ClosestRingPeersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClosestRingPeersResponse& operator=(ClosestRingPeersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClosestRingPeersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClosestRingPeersResponse* internal_default_instance() {
    return reinterpret_cast<const ClosestRingPeersResponse*>(
               &_ClosestRingPeersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ClosestRingPeersResponse& a, ClosestRingPeersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ClosestRingPeersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClosestRingPeersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClosestRingPeersResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClosestRingPeersResponse>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ClosestRingPeersResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.ClosestRingPeersResponse";
  }
  protected:
  explicit ClosestRingPeersResponse(::google::protobuf::Arena* arena);
  ClosestRingPeersResponse(::google::protobuf::Arena* arena, const ClosestRingPeersResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftPeersFieldNumber = 1,
    kRightPeersFieldNumber = 2,
    kRequestIdFieldNumber = 3,
  };
  // repeated .dht.PeerDescriptor leftPeers = 1;
  int leftpeers_size() const;
  private:
  int _internal_leftpeers_size() const;

  public:
  void clear_leftpeers() ;
  ::dht::PeerDescriptor* mutable_leftpeers(int index);
  ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >*
      mutable_leftpeers();
  private:
  const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& _internal_leftpeers() const;
  ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* _internal_mutable_leftpeers();
  public:
  const ::dht::PeerDescriptor& leftpeers(int index) const;
  ::dht::PeerDescriptor* add_leftpeers();
  const ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >&
      leftpeers() const;
  // repeated .dht.PeerDescriptor rightPeers = 2;
  int rightpeers_size() const;
  private:
  int _internal_rightpeers_size() const;

  public:
  void clear_rightpeers() ;
  ::dht::PeerDescriptor* mutable_rightpeers(int index);
  ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >*
      mutable_rightpeers();
  private:
  const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& _internal_rightpeers() const;
  ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* _internal_mutable_rightpeers();
  public:
  const ::dht::PeerDescriptor& rightpeers(int index) const;
  ::dht::PeerDescriptor* add_rightpeers();
  const ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >&
      rightpeers() const;
  // string requestId = 3;
  void clear_requestid() ;
  const std::string& requestid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestid(Arg_&& arg, Args_... args);
  std::string* mutable_requestid();
  PROTOBUF_NODISCARD std::string* release_requestid();
  void set_allocated_requestid(std::string* value);

  private:
  const std::string& _internal_requestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestid(
      const std::string& value);
  std::string* _internal_mutable_requestid();

  public:
  // @@protoc_insertion_point(class_scope:dht.ClosestRingPeersResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor > leftpeers_;
    ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor > rightpeers_;
    ::google::protobuf::internal::ArenaStringPtr requestid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class ClosestPeersResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.ClosestPeersResponse) */ {
 public:
  inline ClosestPeersResponse() : ClosestPeersResponse(nullptr) {}
  ~ClosestPeersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ClosestPeersResponse(::google::protobuf::internal::ConstantInitialized);

  inline ClosestPeersResponse(const ClosestPeersResponse& from)
      : ClosestPeersResponse(nullptr, from) {}
  ClosestPeersResponse(ClosestPeersResponse&& from) noexcept
    : ClosestPeersResponse() {
    *this = ::std::move(from);
  }

  inline ClosestPeersResponse& operator=(const ClosestPeersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClosestPeersResponse& operator=(ClosestPeersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClosestPeersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClosestPeersResponse* internal_default_instance() {
    return reinterpret_cast<const ClosestPeersResponse*>(
               &_ClosestPeersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ClosestPeersResponse& a, ClosestPeersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ClosestPeersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClosestPeersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClosestPeersResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClosestPeersResponse>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ClosestPeersResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.ClosestPeersResponse";
  }
  protected:
  explicit ClosestPeersResponse(::google::protobuf::Arena* arena);
  ClosestPeersResponse(::google::protobuf::Arena* arena, const ClosestPeersResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 1,
    kRequestIdFieldNumber = 2,
  };
  // repeated .dht.PeerDescriptor peers = 1;
  int peers_size() const;
  private:
  int _internal_peers_size() const;

  public:
  void clear_peers() ;
  ::dht::PeerDescriptor* mutable_peers(int index);
  ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >*
      mutable_peers();
  private:
  const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& _internal_peers() const;
  ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* _internal_mutable_peers();
  public:
  const ::dht::PeerDescriptor& peers(int index) const;
  ::dht::PeerDescriptor* add_peers();
  const ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >&
      peers() const;
  // string requestId = 2;
  void clear_requestid() ;
  const std::string& requestid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestid(Arg_&& arg, Args_... args);
  std::string* mutable_requestid();
  PROTOBUF_NODISCARD std::string* release_requestid();
  void set_allocated_requestid(std::string* value);

  private:
  const std::string& _internal_requestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestid(
      const std::string& value);
  std::string* _internal_mutable_requestid();

  public:
  // @@protoc_insertion_point(class_scope:dht.ClosestPeersResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor > peers_;
    ::google::protobuf::internal::ArenaStringPtr requestid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class Message final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Message(::google::protobuf::internal::ConstantInitialized);

  inline Message(const Message& from)
      : Message(nullptr, from) {}
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kRpcMessage = 5,
    kConnectivityRequest = 6,
    kConnectivityResponse = 7,
    kHandshakeRequest = 8,
    kHandshakeResponse = 9,
    kRecursiveOperationRequest = 10,
    BODY_NOT_SET = 0,
  };

  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Message* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.Message";
  }
  protected:
  explicit Message(::google::protobuf::Arena* arena);
  Message(::google::protobuf::Arena* arena, const Message& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 1,
    kServiceIdFieldNumber = 4,
    kSourceDescriptorFieldNumber = 2,
    kTargetDescriptorFieldNumber = 3,
    kRpcMessageFieldNumber = 5,
    kConnectivityRequestFieldNumber = 6,
    kConnectivityResponseFieldNumber = 7,
    kHandshakeRequestFieldNumber = 8,
    kHandshakeResponseFieldNumber = 9,
    kRecursiveOperationRequestFieldNumber = 10,
  };
  // string messageId = 1;
  void clear_messageid() ;
  const std::string& messageid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_messageid(Arg_&& arg, Args_... args);
  std::string* mutable_messageid();
  PROTOBUF_NODISCARD std::string* release_messageid();
  void set_allocated_messageid(std::string* value);

  private:
  const std::string& _internal_messageid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_messageid(
      const std::string& value);
  std::string* _internal_mutable_messageid();

  public:
  // string serviceId = 4;
  void clear_serviceid() ;
  const std::string& serviceid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_serviceid(Arg_&& arg, Args_... args);
  std::string* mutable_serviceid();
  PROTOBUF_NODISCARD std::string* release_serviceid();
  void set_allocated_serviceid(std::string* value);

  private:
  const std::string& _internal_serviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serviceid(
      const std::string& value);
  std::string* _internal_mutable_serviceid();

  public:
  // .dht.PeerDescriptor sourceDescriptor = 2;
  bool has_sourcedescriptor() const;
  void clear_sourcedescriptor() ;
  const ::dht::PeerDescriptor& sourcedescriptor() const;
  PROTOBUF_NODISCARD ::dht::PeerDescriptor* release_sourcedescriptor();
  ::dht::PeerDescriptor* mutable_sourcedescriptor();
  void set_allocated_sourcedescriptor(::dht::PeerDescriptor* value);
  void unsafe_arena_set_allocated_sourcedescriptor(::dht::PeerDescriptor* value);
  ::dht::PeerDescriptor* unsafe_arena_release_sourcedescriptor();

  private:
  const ::dht::PeerDescriptor& _internal_sourcedescriptor() const;
  ::dht::PeerDescriptor* _internal_mutable_sourcedescriptor();

  public:
  // .dht.PeerDescriptor targetDescriptor = 3;
  bool has_targetdescriptor() const;
  void clear_targetdescriptor() ;
  const ::dht::PeerDescriptor& targetdescriptor() const;
  PROTOBUF_NODISCARD ::dht::PeerDescriptor* release_targetdescriptor();
  ::dht::PeerDescriptor* mutable_targetdescriptor();
  void set_allocated_targetdescriptor(::dht::PeerDescriptor* value);
  void unsafe_arena_set_allocated_targetdescriptor(::dht::PeerDescriptor* value);
  ::dht::PeerDescriptor* unsafe_arena_release_targetdescriptor();

  private:
  const ::dht::PeerDescriptor& _internal_targetdescriptor() const;
  ::dht::PeerDescriptor* _internal_mutable_targetdescriptor();

  public:
  // .protorpc.RpcMessage rpcMessage = 5;
  bool has_rpcmessage() const;
  private:
  bool _internal_has_rpcmessage() const;

  public:
  void clear_rpcmessage() ;
  const ::protorpc::RpcMessage& rpcmessage() const;
  PROTOBUF_NODISCARD ::protorpc::RpcMessage* release_rpcmessage();
  ::protorpc::RpcMessage* mutable_rpcmessage();
  void set_allocated_rpcmessage(::protorpc::RpcMessage* value);
  void unsafe_arena_set_allocated_rpcmessage(::protorpc::RpcMessage* value);
  ::protorpc::RpcMessage* unsafe_arena_release_rpcmessage();

  private:
  const ::protorpc::RpcMessage& _internal_rpcmessage() const;
  ::protorpc::RpcMessage* _internal_mutable_rpcmessage();

  public:
  // .dht.ConnectivityRequest connectivityRequest = 6;
  bool has_connectivityrequest() const;
  private:
  bool _internal_has_connectivityrequest() const;

  public:
  void clear_connectivityrequest() ;
  const ::dht::ConnectivityRequest& connectivityrequest() const;
  PROTOBUF_NODISCARD ::dht::ConnectivityRequest* release_connectivityrequest();
  ::dht::ConnectivityRequest* mutable_connectivityrequest();
  void set_allocated_connectivityrequest(::dht::ConnectivityRequest* value);
  void unsafe_arena_set_allocated_connectivityrequest(::dht::ConnectivityRequest* value);
  ::dht::ConnectivityRequest* unsafe_arena_release_connectivityrequest();

  private:
  const ::dht::ConnectivityRequest& _internal_connectivityrequest() const;
  ::dht::ConnectivityRequest* _internal_mutable_connectivityrequest();

  public:
  // .dht.ConnectivityResponse connectivityResponse = 7;
  bool has_connectivityresponse() const;
  private:
  bool _internal_has_connectivityresponse() const;

  public:
  void clear_connectivityresponse() ;
  const ::dht::ConnectivityResponse& connectivityresponse() const;
  PROTOBUF_NODISCARD ::dht::ConnectivityResponse* release_connectivityresponse();
  ::dht::ConnectivityResponse* mutable_connectivityresponse();
  void set_allocated_connectivityresponse(::dht::ConnectivityResponse* value);
  void unsafe_arena_set_allocated_connectivityresponse(::dht::ConnectivityResponse* value);
  ::dht::ConnectivityResponse* unsafe_arena_release_connectivityresponse();

  private:
  const ::dht::ConnectivityResponse& _internal_connectivityresponse() const;
  ::dht::ConnectivityResponse* _internal_mutable_connectivityresponse();

  public:
  // .dht.HandshakeRequest handshakeRequest = 8;
  bool has_handshakerequest() const;
  private:
  bool _internal_has_handshakerequest() const;

  public:
  void clear_handshakerequest() ;
  const ::dht::HandshakeRequest& handshakerequest() const;
  PROTOBUF_NODISCARD ::dht::HandshakeRequest* release_handshakerequest();
  ::dht::HandshakeRequest* mutable_handshakerequest();
  void set_allocated_handshakerequest(::dht::HandshakeRequest* value);
  void unsafe_arena_set_allocated_handshakerequest(::dht::HandshakeRequest* value);
  ::dht::HandshakeRequest* unsafe_arena_release_handshakerequest();

  private:
  const ::dht::HandshakeRequest& _internal_handshakerequest() const;
  ::dht::HandshakeRequest* _internal_mutable_handshakerequest();

  public:
  // .dht.HandshakeResponse handshakeResponse = 9;
  bool has_handshakeresponse() const;
  private:
  bool _internal_has_handshakeresponse() const;

  public:
  void clear_handshakeresponse() ;
  const ::dht::HandshakeResponse& handshakeresponse() const;
  PROTOBUF_NODISCARD ::dht::HandshakeResponse* release_handshakeresponse();
  ::dht::HandshakeResponse* mutable_handshakeresponse();
  void set_allocated_handshakeresponse(::dht::HandshakeResponse* value);
  void unsafe_arena_set_allocated_handshakeresponse(::dht::HandshakeResponse* value);
  ::dht::HandshakeResponse* unsafe_arena_release_handshakeresponse();

  private:
  const ::dht::HandshakeResponse& _internal_handshakeresponse() const;
  ::dht::HandshakeResponse* _internal_mutable_handshakeresponse();

  public:
  // .dht.RecursiveOperationRequest recursiveOperationRequest = 10;
  bool has_recursiveoperationrequest() const;
  private:
  bool _internal_has_recursiveoperationrequest() const;

  public:
  void clear_recursiveoperationrequest() ;
  const ::dht::RecursiveOperationRequest& recursiveoperationrequest() const;
  PROTOBUF_NODISCARD ::dht::RecursiveOperationRequest* release_recursiveoperationrequest();
  ::dht::RecursiveOperationRequest* mutable_recursiveoperationrequest();
  void set_allocated_recursiveoperationrequest(::dht::RecursiveOperationRequest* value);
  void unsafe_arena_set_allocated_recursiveoperationrequest(::dht::RecursiveOperationRequest* value);
  ::dht::RecursiveOperationRequest* unsafe_arena_release_recursiveoperationrequest();

  private:
  const ::dht::RecursiveOperationRequest& _internal_recursiveoperationrequest() const;
  ::dht::RecursiveOperationRequest* _internal_mutable_recursiveoperationrequest();

  public:
  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:dht.Message)
 private:
  class _Internal;
  void set_has_rpcmessage();
  void set_has_connectivityrequest();
  void set_has_connectivityresponse();
  void set_has_handshakerequest();
  void set_has_handshakeresponse();
  void set_has_recursiveoperationrequest();

  inline bool has_body() const;
  inline void clear_has_body();

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr messageid_;
    ::google::protobuf::internal::ArenaStringPtr serviceid_;
    ::dht::PeerDescriptor* sourcedescriptor_;
    ::dht::PeerDescriptor* targetdescriptor_;
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::protorpc::RpcMessage* rpcmessage_;
      ::dht::ConnectivityRequest* connectivityrequest_;
      ::dht::ConnectivityResponse* connectivityresponse_;
      ::dht::HandshakeRequest* handshakerequest_;
      ::dht::HandshakeResponse* handshakeresponse_;
      ::dht::RecursiveOperationRequest* recursiveoperationrequest_;
    } body_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};// -------------------------------------------------------------------

class RouteMessageWrapper final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dht.RouteMessageWrapper) */ {
 public:
  inline RouteMessageWrapper() : RouteMessageWrapper(nullptr) {}
  ~RouteMessageWrapper() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouteMessageWrapper(::google::protobuf::internal::ConstantInitialized);

  inline RouteMessageWrapper(const RouteMessageWrapper& from)
      : RouteMessageWrapper(nullptr, from) {}
  RouteMessageWrapper(RouteMessageWrapper&& from) noexcept
    : RouteMessageWrapper() {
    *this = ::std::move(from);
  }

  inline RouteMessageWrapper& operator=(const RouteMessageWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteMessageWrapper& operator=(RouteMessageWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteMessageWrapper& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteMessageWrapper* internal_default_instance() {
    return reinterpret_cast<const RouteMessageWrapper*>(
               &_RouteMessageWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RouteMessageWrapper& a, RouteMessageWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteMessageWrapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteMessageWrapper* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteMessageWrapper* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteMessageWrapper>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouteMessageWrapper* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dht.RouteMessageWrapper";
  }
  protected:
  explicit RouteMessageWrapper(::google::protobuf::Arena* arena);
  RouteMessageWrapper(::google::protobuf::Arena* arena, const RouteMessageWrapper& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReachableThroughFieldNumber = 5,
    kRoutingPathFieldNumber = 6,
    kParallelRootNodeIdsFieldNumber = 7,
    kRequestIdFieldNumber = 1,
    kTargetFieldNumber = 3,
    kSourcePeerFieldNumber = 2,
    kMessageFieldNumber = 4,
  };
  // repeated .dht.PeerDescriptor reachableThrough = 5;
  int reachablethrough_size() const;
  private:
  int _internal_reachablethrough_size() const;

  public:
  void clear_reachablethrough() ;
  ::dht::PeerDescriptor* mutable_reachablethrough(int index);
  ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >*
      mutable_reachablethrough();
  private:
  const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& _internal_reachablethrough() const;
  ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* _internal_mutable_reachablethrough();
  public:
  const ::dht::PeerDescriptor& reachablethrough(int index) const;
  ::dht::PeerDescriptor* add_reachablethrough();
  const ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >&
      reachablethrough() const;
  // repeated .dht.PeerDescriptor routingPath = 6;
  int routingpath_size() const;
  private:
  int _internal_routingpath_size() const;

  public:
  void clear_routingpath() ;
  ::dht::PeerDescriptor* mutable_routingpath(int index);
  ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >*
      mutable_routingpath();
  private:
  const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& _internal_routingpath() const;
  ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* _internal_mutable_routingpath();
  public:
  const ::dht::PeerDescriptor& routingpath(int index) const;
  ::dht::PeerDescriptor* add_routingpath();
  const ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >&
      routingpath() const;
  // repeated string parallelRootNodeIds = 7;
  int parallelrootnodeids_size() const;
  private:
  int _internal_parallelrootnodeids_size() const;

  public:
  void clear_parallelrootnodeids() ;
  const std::string& parallelrootnodeids(int index) const;
  std::string* mutable_parallelrootnodeids(int index);
  void set_parallelrootnodeids(int index, const std::string& value);
  void set_parallelrootnodeids(int index, std::string&& value);
  void set_parallelrootnodeids(int index, const char* value);
  void set_parallelrootnodeids(int index, const char* value, std::size_t size);
  void set_parallelrootnodeids(int index, absl::string_view value);
  std::string* add_parallelrootnodeids();
  void add_parallelrootnodeids(const std::string& value);
  void add_parallelrootnodeids(std::string&& value);
  void add_parallelrootnodeids(const char* value);
  void add_parallelrootnodeids(const char* value, std::size_t size);
  void add_parallelrootnodeids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& parallelrootnodeids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_parallelrootnodeids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_parallelrootnodeids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_parallelrootnodeids();

  public:
  // string requestId = 1;
  void clear_requestid() ;
  const std::string& requestid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestid(Arg_&& arg, Args_... args);
  std::string* mutable_requestid();
  PROTOBUF_NODISCARD std::string* release_requestid();
  void set_allocated_requestid(std::string* value);

  private:
  const std::string& _internal_requestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestid(
      const std::string& value);
  std::string* _internal_mutable_requestid();

  public:
  // bytes target = 3;
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // .dht.PeerDescriptor sourcePeer = 2;
  bool has_sourcepeer() const;
  void clear_sourcepeer() ;
  const ::dht::PeerDescriptor& sourcepeer() const;
  PROTOBUF_NODISCARD ::dht::PeerDescriptor* release_sourcepeer();
  ::dht::PeerDescriptor* mutable_sourcepeer();
  void set_allocated_sourcepeer(::dht::PeerDescriptor* value);
  void unsafe_arena_set_allocated_sourcepeer(::dht::PeerDescriptor* value);
  ::dht::PeerDescriptor* unsafe_arena_release_sourcepeer();

  private:
  const ::dht::PeerDescriptor& _internal_sourcepeer() const;
  ::dht::PeerDescriptor* _internal_mutable_sourcepeer();

  public:
  // .dht.Message message = 4;
  bool has_message() const;
  void clear_message() ;
  const ::dht::Message& message() const;
  PROTOBUF_NODISCARD ::dht::Message* release_message();
  ::dht::Message* mutable_message();
  void set_allocated_message(::dht::Message* value);
  void unsafe_arena_set_allocated_message(::dht::Message* value);
  ::dht::Message* unsafe_arena_release_message();

  private:
  const ::dht::Message& _internal_message() const;
  ::dht::Message* _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:dht.RouteMessageWrapper)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor > reachablethrough_;
    ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor > routingpath_;
    ::google::protobuf::RepeatedPtrField<std::string> parallelrootnodeids_;
    ::google::protobuf::internal::ArenaStringPtr requestid_;
    ::google::protobuf::internal::ArenaStringPtr target_;
    ::dht::PeerDescriptor* sourcepeer_;
    ::dht::Message* message_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fdht_2fprotos_2fDhtRpc_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// StoreDataRequest

// bytes key = 1;
inline void StoreDataRequest::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& StoreDataRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.StoreDataRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreDataRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.StoreDataRequest.key)
}
inline std::string* StoreDataRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:dht.StoreDataRequest.key)
  return _s;
}
inline const std::string& StoreDataRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void StoreDataRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* StoreDataRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* StoreDataRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.StoreDataRequest.key)
  return _impl_.key_.Release();
}
inline void StoreDataRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.StoreDataRequest.key)
}

// .google.protobuf.Any data = 2;
inline bool StoreDataRequest::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& StoreDataRequest::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Any* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& StoreDataRequest::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.StoreDataRequest.data)
  return _internal_data();
}
inline void StoreDataRequest::unsafe_arena_set_allocated_data(::google::protobuf::Any* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.StoreDataRequest.data)
}
inline ::google::protobuf::Any* StoreDataRequest::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Any* StoreDataRequest::unsafe_arena_release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.StoreDataRequest.data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* StoreDataRequest::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArena());
    _impl_.data_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.data_;
}
inline ::google::protobuf::Any* StoreDataRequest::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Any* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:dht.StoreDataRequest.data)
  return _msg;
}
inline void StoreDataRequest::set_allocated_data(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.data_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:dht.StoreDataRequest.data)
}

// bytes creator = 3;
inline void StoreDataRequest::clear_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.creator_.ClearToEmpty();
}
inline const std::string& StoreDataRequest::creator() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.StoreDataRequest.creator)
  return _internal_creator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreDataRequest::set_creator(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.creator_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.StoreDataRequest.creator)
}
inline std::string* StoreDataRequest::mutable_creator() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:dht.StoreDataRequest.creator)
  return _s;
}
inline const std::string& StoreDataRequest::_internal_creator() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.creator_.Get();
}
inline void StoreDataRequest::_internal_set_creator(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.creator_.Set(value, GetArena());
}
inline std::string* StoreDataRequest::_internal_mutable_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.creator_.Mutable( GetArena());
}
inline std::string* StoreDataRequest::release_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.StoreDataRequest.creator)
  return _impl_.creator_.Release();
}
inline void StoreDataRequest::set_allocated_creator(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.creator_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.creator_.IsDefault()) {
          _impl_.creator_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.StoreDataRequest.creator)
}

// .google.protobuf.Timestamp createdAt = 4;
inline bool StoreDataRequest::has_createdat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.createdat_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& StoreDataRequest::_internal_createdat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.createdat_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& StoreDataRequest::createdat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.StoreDataRequest.createdAt)
  return _internal_createdat();
}
inline void StoreDataRequest::unsafe_arena_set_allocated_createdat(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.createdat_);
  }
  _impl_.createdat_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.StoreDataRequest.createdAt)
}
inline ::google::protobuf::Timestamp* StoreDataRequest::release_createdat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.createdat_;
  _impl_.createdat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* StoreDataRequest::unsafe_arena_release_createdat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.StoreDataRequest.createdAt)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.createdat_;
  _impl_.createdat_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* StoreDataRequest::_internal_mutable_createdat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.createdat_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.createdat_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.createdat_;
}
inline ::google::protobuf::Timestamp* StoreDataRequest::mutable_createdat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_createdat();
  // @@protoc_insertion_point(field_mutable:dht.StoreDataRequest.createdAt)
  return _msg;
}
inline void StoreDataRequest::set_allocated_createdat(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.createdat_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.createdat_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:dht.StoreDataRequest.createdAt)
}

// uint32 ttl = 5;
inline void StoreDataRequest::clear_ttl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ttl_ = 0u;
}
inline ::uint32_t StoreDataRequest::ttl() const {
  // @@protoc_insertion_point(field_get:dht.StoreDataRequest.ttl)
  return _internal_ttl();
}
inline void StoreDataRequest::set_ttl(::uint32_t value) {
  _internal_set_ttl(value);
  // @@protoc_insertion_point(field_set:dht.StoreDataRequest.ttl)
}
inline ::uint32_t StoreDataRequest::_internal_ttl() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ttl_;
}
inline void StoreDataRequest::_internal_set_ttl(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ttl_ = value;
}

// -------------------------------------------------------------------

// StoreDataResponse

// -------------------------------------------------------------------

// ExternalStoreDataRequest

// bytes key = 1;
inline void ExternalStoreDataRequest::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ExternalStoreDataRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ExternalStoreDataRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExternalStoreDataRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.ExternalStoreDataRequest.key)
}
inline std::string* ExternalStoreDataRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:dht.ExternalStoreDataRequest.key)
  return _s;
}
inline const std::string& ExternalStoreDataRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void ExternalStoreDataRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* ExternalStoreDataRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* ExternalStoreDataRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.ExternalStoreDataRequest.key)
  return _impl_.key_.Release();
}
inline void ExternalStoreDataRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.ExternalStoreDataRequest.key)
}

// .google.protobuf.Any data = 2;
inline bool ExternalStoreDataRequest::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& ExternalStoreDataRequest::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Any* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& ExternalStoreDataRequest::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ExternalStoreDataRequest.data)
  return _internal_data();
}
inline void ExternalStoreDataRequest::unsafe_arena_set_allocated_data(::google::protobuf::Any* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.ExternalStoreDataRequest.data)
}
inline ::google::protobuf::Any* ExternalStoreDataRequest::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Any* ExternalStoreDataRequest::unsafe_arena_release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.ExternalStoreDataRequest.data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* ExternalStoreDataRequest::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArena());
    _impl_.data_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.data_;
}
inline ::google::protobuf::Any* ExternalStoreDataRequest::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Any* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:dht.ExternalStoreDataRequest.data)
  return _msg;
}
inline void ExternalStoreDataRequest::set_allocated_data(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.data_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:dht.ExternalStoreDataRequest.data)
}

// -------------------------------------------------------------------

// ExternalStoreDataResponse

// repeated .dht.PeerDescriptor storers = 1;
inline int ExternalStoreDataResponse::_internal_storers_size() const {
  return _internal_storers().size();
}
inline int ExternalStoreDataResponse::storers_size() const {
  return _internal_storers_size();
}
inline void ExternalStoreDataResponse::clear_storers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.storers_.Clear();
}
inline ::dht::PeerDescriptor* ExternalStoreDataResponse::mutable_storers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dht.ExternalStoreDataResponse.storers)
  return _internal_mutable_storers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* ExternalStoreDataResponse::mutable_storers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dht.ExternalStoreDataResponse.storers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_storers();
}
inline const ::dht::PeerDescriptor& ExternalStoreDataResponse::storers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ExternalStoreDataResponse.storers)
  return _internal_storers().Get(index);
}
inline ::dht::PeerDescriptor* ExternalStoreDataResponse::add_storers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dht::PeerDescriptor* _add = _internal_mutable_storers()->Add();
  // @@protoc_insertion_point(field_add:dht.ExternalStoreDataResponse.storers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& ExternalStoreDataResponse::storers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dht.ExternalStoreDataResponse.storers)
  return _internal_storers();
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>&
ExternalStoreDataResponse::_internal_storers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.storers_;
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>*
ExternalStoreDataResponse::_internal_mutable_storers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.storers_;
}

// -------------------------------------------------------------------

// ReplicateDataRequest

// .dht.DataEntry entry = 1;
inline bool ReplicateDataRequest::has_entry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.entry_ != nullptr);
  return value;
}
inline void ReplicateDataRequest::clear_entry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.entry_ != nullptr) _impl_.entry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dht::DataEntry& ReplicateDataRequest::_internal_entry() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dht::DataEntry* p = _impl_.entry_;
  return p != nullptr ? *p : reinterpret_cast<const ::dht::DataEntry&>(::dht::_DataEntry_default_instance_);
}
inline const ::dht::DataEntry& ReplicateDataRequest::entry() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ReplicateDataRequest.entry)
  return _internal_entry();
}
inline void ReplicateDataRequest::unsafe_arena_set_allocated_entry(::dht::DataEntry* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.entry_);
  }
  _impl_.entry_ = reinterpret_cast<::dht::DataEntry*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.ReplicateDataRequest.entry)
}
inline ::dht::DataEntry* ReplicateDataRequest::release_entry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dht::DataEntry* released = _impl_.entry_;
  _impl_.entry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dht::DataEntry* ReplicateDataRequest::unsafe_arena_release_entry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.ReplicateDataRequest.entry)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dht::DataEntry* temp = _impl_.entry_;
  _impl_.entry_ = nullptr;
  return temp;
}
inline ::dht::DataEntry* ReplicateDataRequest::_internal_mutable_entry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.entry_ == nullptr) {
    auto* p = CreateMaybeMessage<::dht::DataEntry>(GetArena());
    _impl_.entry_ = reinterpret_cast<::dht::DataEntry*>(p);
  }
  return _impl_.entry_;
}
inline ::dht::DataEntry* ReplicateDataRequest::mutable_entry() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::DataEntry* _msg = _internal_mutable_entry();
  // @@protoc_insertion_point(field_mutable:dht.ReplicateDataRequest.entry)
  return _msg;
}
inline void ReplicateDataRequest::set_allocated_entry(::dht::DataEntry* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::dht::DataEntry*>(_impl_.entry_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::dht::DataEntry*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.entry_ = reinterpret_cast<::dht::DataEntry*>(value);
  // @@protoc_insertion_point(field_set_allocated:dht.ReplicateDataRequest.entry)
}

// -------------------------------------------------------------------

// DataEntry

// bytes key = 1;
inline void DataEntry::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& DataEntry::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.DataEntry.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DataEntry::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.DataEntry.key)
}
inline std::string* DataEntry::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:dht.DataEntry.key)
  return _s;
}
inline const std::string& DataEntry::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void DataEntry::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* DataEntry::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* DataEntry::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.DataEntry.key)
  return _impl_.key_.Release();
}
inline void DataEntry::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.DataEntry.key)
}

// .google.protobuf.Any data = 2;
inline bool DataEntry::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& DataEntry::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Any* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& DataEntry::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.DataEntry.data)
  return _internal_data();
}
inline void DataEntry::unsafe_arena_set_allocated_data(::google::protobuf::Any* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.DataEntry.data)
}
inline ::google::protobuf::Any* DataEntry::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Any* DataEntry::unsafe_arena_release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.DataEntry.data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* DataEntry::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArena());
    _impl_.data_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.data_;
}
inline ::google::protobuf::Any* DataEntry::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Any* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:dht.DataEntry.data)
  return _msg;
}
inline void DataEntry::set_allocated_data(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.data_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:dht.DataEntry.data)
}

// bytes creator = 3;
inline void DataEntry::clear_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.creator_.ClearToEmpty();
}
inline const std::string& DataEntry::creator() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.DataEntry.creator)
  return _internal_creator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DataEntry::set_creator(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.creator_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.DataEntry.creator)
}
inline std::string* DataEntry::mutable_creator() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:dht.DataEntry.creator)
  return _s;
}
inline const std::string& DataEntry::_internal_creator() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.creator_.Get();
}
inline void DataEntry::_internal_set_creator(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.creator_.Set(value, GetArena());
}
inline std::string* DataEntry::_internal_mutable_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.creator_.Mutable( GetArena());
}
inline std::string* DataEntry::release_creator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.DataEntry.creator)
  return _impl_.creator_.Release();
}
inline void DataEntry::set_allocated_creator(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.creator_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.creator_.IsDefault()) {
          _impl_.creator_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.DataEntry.creator)
}

// .google.protobuf.Timestamp createdAt = 4;
inline bool DataEntry::has_createdat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.createdat_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& DataEntry::_internal_createdat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.createdat_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& DataEntry::createdat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.DataEntry.createdAt)
  return _internal_createdat();
}
inline void DataEntry::unsafe_arena_set_allocated_createdat(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.createdat_);
  }
  _impl_.createdat_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.DataEntry.createdAt)
}
inline ::google::protobuf::Timestamp* DataEntry::release_createdat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.createdat_;
  _impl_.createdat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* DataEntry::unsafe_arena_release_createdat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.DataEntry.createdAt)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.createdat_;
  _impl_.createdat_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* DataEntry::_internal_mutable_createdat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.createdat_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.createdat_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.createdat_;
}
inline ::google::protobuf::Timestamp* DataEntry::mutable_createdat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_createdat();
  // @@protoc_insertion_point(field_mutable:dht.DataEntry.createdAt)
  return _msg;
}
inline void DataEntry::set_allocated_createdat(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.createdat_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.createdat_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:dht.DataEntry.createdAt)
}

// .google.protobuf.Timestamp storedAt = 5;
inline bool DataEntry::has_storedat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storedat_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& DataEntry::_internal_storedat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.storedat_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& DataEntry::storedat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.DataEntry.storedAt)
  return _internal_storedat();
}
inline void DataEntry::unsafe_arena_set_allocated_storedat(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.storedat_);
  }
  _impl_.storedat_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.DataEntry.storedAt)
}
inline ::google::protobuf::Timestamp* DataEntry::release_storedat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* released = _impl_.storedat_;
  _impl_.storedat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* DataEntry::unsafe_arena_release_storedat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.DataEntry.storedAt)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* temp = _impl_.storedat_;
  _impl_.storedat_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* DataEntry::_internal_mutable_storedat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.storedat_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.storedat_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.storedat_;
}
inline ::google::protobuf::Timestamp* DataEntry::mutable_storedat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_storedat();
  // @@protoc_insertion_point(field_mutable:dht.DataEntry.storedAt)
  return _msg;
}
inline void DataEntry::set_allocated_storedat(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.storedat_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.storedat_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:dht.DataEntry.storedAt)
}

// uint32 ttl = 6;
inline void DataEntry::clear_ttl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ttl_ = 0u;
}
inline ::uint32_t DataEntry::ttl() const {
  // @@protoc_insertion_point(field_get:dht.DataEntry.ttl)
  return _internal_ttl();
}
inline void DataEntry::set_ttl(::uint32_t value) {
  _internal_set_ttl(value);
  // @@protoc_insertion_point(field_set:dht.DataEntry.ttl)
}
inline ::uint32_t DataEntry::_internal_ttl() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ttl_;
}
inline void DataEntry::_internal_set_ttl(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ttl_ = value;
}

// bool stale = 7;
inline void DataEntry::clear_stale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stale_ = false;
}
inline bool DataEntry::stale() const {
  // @@protoc_insertion_point(field_get:dht.DataEntry.stale)
  return _internal_stale();
}
inline void DataEntry::set_stale(bool value) {
  _internal_set_stale(value);
  // @@protoc_insertion_point(field_set:dht.DataEntry.stale)
}
inline bool DataEntry::_internal_stale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stale_;
}
inline void DataEntry::_internal_set_stale(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stale_ = value;
}

// bool deleted = 8;
inline void DataEntry::clear_deleted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deleted_ = false;
}
inline bool DataEntry::deleted() const {
  // @@protoc_insertion_point(field_get:dht.DataEntry.deleted)
  return _internal_deleted();
}
inline void DataEntry::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:dht.DataEntry.deleted)
}
inline bool DataEntry::_internal_deleted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.deleted_;
}
inline void DataEntry::_internal_set_deleted(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.deleted_ = value;
}

// -------------------------------------------------------------------

// ClosestPeersRequest

// bytes nodeId = 1;
inline void ClosestPeersRequest::clear_nodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nodeid_.ClearToEmpty();
}
inline const std::string& ClosestPeersRequest::nodeid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ClosestPeersRequest.nodeId)
  return _internal_nodeid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClosestPeersRequest::set_nodeid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nodeid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.ClosestPeersRequest.nodeId)
}
inline std::string* ClosestPeersRequest::mutable_nodeid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nodeid();
  // @@protoc_insertion_point(field_mutable:dht.ClosestPeersRequest.nodeId)
  return _s;
}
inline const std::string& ClosestPeersRequest::_internal_nodeid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nodeid_.Get();
}
inline void ClosestPeersRequest::_internal_set_nodeid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nodeid_.Set(value, GetArena());
}
inline std::string* ClosestPeersRequest::_internal_mutable_nodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.nodeid_.Mutable( GetArena());
}
inline std::string* ClosestPeersRequest::release_nodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.ClosestPeersRequest.nodeId)
  return _impl_.nodeid_.Release();
}
inline void ClosestPeersRequest::set_allocated_nodeid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nodeid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nodeid_.IsDefault()) {
          _impl_.nodeid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.ClosestPeersRequest.nodeId)
}

// string requestId = 2;
inline void ClosestPeersRequest::clear_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.ClearToEmpty();
}
inline const std::string& ClosestPeersRequest::requestid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ClosestPeersRequest.requestId)
  return _internal_requestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClosestPeersRequest::set_requestid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.ClosestPeersRequest.requestId)
}
inline std::string* ClosestPeersRequest::mutable_requestid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_requestid();
  // @@protoc_insertion_point(field_mutable:dht.ClosestPeersRequest.requestId)
  return _s;
}
inline const std::string& ClosestPeersRequest::_internal_requestid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestid_.Get();
}
inline void ClosestPeersRequest::_internal_set_requestid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(value, GetArena());
}
inline std::string* ClosestPeersRequest::_internal_mutable_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.requestid_.Mutable( GetArena());
}
inline std::string* ClosestPeersRequest::release_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.ClosestPeersRequest.requestId)
  return _impl_.requestid_.Release();
}
inline void ClosestPeersRequest::set_allocated_requestid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestid_.IsDefault()) {
          _impl_.requestid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.ClosestPeersRequest.requestId)
}

// -------------------------------------------------------------------

// ClosestPeersResponse

// repeated .dht.PeerDescriptor peers = 1;
inline int ClosestPeersResponse::_internal_peers_size() const {
  return _internal_peers().size();
}
inline int ClosestPeersResponse::peers_size() const {
  return _internal_peers_size();
}
inline void ClosestPeersResponse::clear_peers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.peers_.Clear();
}
inline ::dht::PeerDescriptor* ClosestPeersResponse::mutable_peers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dht.ClosestPeersResponse.peers)
  return _internal_mutable_peers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* ClosestPeersResponse::mutable_peers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dht.ClosestPeersResponse.peers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_peers();
}
inline const ::dht::PeerDescriptor& ClosestPeersResponse::peers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ClosestPeersResponse.peers)
  return _internal_peers().Get(index);
}
inline ::dht::PeerDescriptor* ClosestPeersResponse::add_peers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dht::PeerDescriptor* _add = _internal_mutable_peers()->Add();
  // @@protoc_insertion_point(field_add:dht.ClosestPeersResponse.peers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& ClosestPeersResponse::peers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dht.ClosestPeersResponse.peers)
  return _internal_peers();
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>&
ClosestPeersResponse::_internal_peers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.peers_;
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>*
ClosestPeersResponse::_internal_mutable_peers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.peers_;
}

// string requestId = 2;
inline void ClosestPeersResponse::clear_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.ClearToEmpty();
}
inline const std::string& ClosestPeersResponse::requestid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ClosestPeersResponse.requestId)
  return _internal_requestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClosestPeersResponse::set_requestid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.ClosestPeersResponse.requestId)
}
inline std::string* ClosestPeersResponse::mutable_requestid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_requestid();
  // @@protoc_insertion_point(field_mutable:dht.ClosestPeersResponse.requestId)
  return _s;
}
inline const std::string& ClosestPeersResponse::_internal_requestid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestid_.Get();
}
inline void ClosestPeersResponse::_internal_set_requestid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(value, GetArena());
}
inline std::string* ClosestPeersResponse::_internal_mutable_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.requestid_.Mutable( GetArena());
}
inline std::string* ClosestPeersResponse::release_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.ClosestPeersResponse.requestId)
  return _impl_.requestid_.Release();
}
inline void ClosestPeersResponse::set_allocated_requestid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestid_.IsDefault()) {
          _impl_.requestid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.ClosestPeersResponse.requestId)
}

// -------------------------------------------------------------------

// ClosestRingPeersRequest

// bytes ringId = 1;
inline void ClosestRingPeersRequest::clear_ringid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ringid_.ClearToEmpty();
}
inline const std::string& ClosestRingPeersRequest::ringid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ClosestRingPeersRequest.ringId)
  return _internal_ringid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClosestRingPeersRequest::set_ringid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ringid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.ClosestRingPeersRequest.ringId)
}
inline std::string* ClosestRingPeersRequest::mutable_ringid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ringid();
  // @@protoc_insertion_point(field_mutable:dht.ClosestRingPeersRequest.ringId)
  return _s;
}
inline const std::string& ClosestRingPeersRequest::_internal_ringid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ringid_.Get();
}
inline void ClosestRingPeersRequest::_internal_set_ringid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ringid_.Set(value, GetArena());
}
inline std::string* ClosestRingPeersRequest::_internal_mutable_ringid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ringid_.Mutable( GetArena());
}
inline std::string* ClosestRingPeersRequest::release_ringid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.ClosestRingPeersRequest.ringId)
  return _impl_.ringid_.Release();
}
inline void ClosestRingPeersRequest::set_allocated_ringid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ringid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ringid_.IsDefault()) {
          _impl_.ringid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.ClosestRingPeersRequest.ringId)
}

// string requestId = 2;
inline void ClosestRingPeersRequest::clear_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.ClearToEmpty();
}
inline const std::string& ClosestRingPeersRequest::requestid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ClosestRingPeersRequest.requestId)
  return _internal_requestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClosestRingPeersRequest::set_requestid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.ClosestRingPeersRequest.requestId)
}
inline std::string* ClosestRingPeersRequest::mutable_requestid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_requestid();
  // @@protoc_insertion_point(field_mutable:dht.ClosestRingPeersRequest.requestId)
  return _s;
}
inline const std::string& ClosestRingPeersRequest::_internal_requestid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestid_.Get();
}
inline void ClosestRingPeersRequest::_internal_set_requestid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(value, GetArena());
}
inline std::string* ClosestRingPeersRequest::_internal_mutable_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.requestid_.Mutable( GetArena());
}
inline std::string* ClosestRingPeersRequest::release_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.ClosestRingPeersRequest.requestId)
  return _impl_.requestid_.Release();
}
inline void ClosestRingPeersRequest::set_allocated_requestid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestid_.IsDefault()) {
          _impl_.requestid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.ClosestRingPeersRequest.requestId)
}

// -------------------------------------------------------------------

// ClosestRingPeersResponse

// repeated .dht.PeerDescriptor leftPeers = 1;
inline int ClosestRingPeersResponse::_internal_leftpeers_size() const {
  return _internal_leftpeers().size();
}
inline int ClosestRingPeersResponse::leftpeers_size() const {
  return _internal_leftpeers_size();
}
inline void ClosestRingPeersResponse::clear_leftpeers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.leftpeers_.Clear();
}
inline ::dht::PeerDescriptor* ClosestRingPeersResponse::mutable_leftpeers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dht.ClosestRingPeersResponse.leftPeers)
  return _internal_mutable_leftpeers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* ClosestRingPeersResponse::mutable_leftpeers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dht.ClosestRingPeersResponse.leftPeers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_leftpeers();
}
inline const ::dht::PeerDescriptor& ClosestRingPeersResponse::leftpeers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ClosestRingPeersResponse.leftPeers)
  return _internal_leftpeers().Get(index);
}
inline ::dht::PeerDescriptor* ClosestRingPeersResponse::add_leftpeers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dht::PeerDescriptor* _add = _internal_mutable_leftpeers()->Add();
  // @@protoc_insertion_point(field_add:dht.ClosestRingPeersResponse.leftPeers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& ClosestRingPeersResponse::leftpeers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dht.ClosestRingPeersResponse.leftPeers)
  return _internal_leftpeers();
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>&
ClosestRingPeersResponse::_internal_leftpeers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.leftpeers_;
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>*
ClosestRingPeersResponse::_internal_mutable_leftpeers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.leftpeers_;
}

// repeated .dht.PeerDescriptor rightPeers = 2;
inline int ClosestRingPeersResponse::_internal_rightpeers_size() const {
  return _internal_rightpeers().size();
}
inline int ClosestRingPeersResponse::rightpeers_size() const {
  return _internal_rightpeers_size();
}
inline void ClosestRingPeersResponse::clear_rightpeers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rightpeers_.Clear();
}
inline ::dht::PeerDescriptor* ClosestRingPeersResponse::mutable_rightpeers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dht.ClosestRingPeersResponse.rightPeers)
  return _internal_mutable_rightpeers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* ClosestRingPeersResponse::mutable_rightpeers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dht.ClosestRingPeersResponse.rightPeers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_rightpeers();
}
inline const ::dht::PeerDescriptor& ClosestRingPeersResponse::rightpeers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ClosestRingPeersResponse.rightPeers)
  return _internal_rightpeers().Get(index);
}
inline ::dht::PeerDescriptor* ClosestRingPeersResponse::add_rightpeers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dht::PeerDescriptor* _add = _internal_mutable_rightpeers()->Add();
  // @@protoc_insertion_point(field_add:dht.ClosestRingPeersResponse.rightPeers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& ClosestRingPeersResponse::rightpeers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dht.ClosestRingPeersResponse.rightPeers)
  return _internal_rightpeers();
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>&
ClosestRingPeersResponse::_internal_rightpeers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rightpeers_;
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>*
ClosestRingPeersResponse::_internal_mutable_rightpeers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.rightpeers_;
}

// string requestId = 3;
inline void ClosestRingPeersResponse::clear_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.ClearToEmpty();
}
inline const std::string& ClosestRingPeersResponse::requestid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ClosestRingPeersResponse.requestId)
  return _internal_requestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClosestRingPeersResponse::set_requestid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.ClosestRingPeersResponse.requestId)
}
inline std::string* ClosestRingPeersResponse::mutable_requestid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_requestid();
  // @@protoc_insertion_point(field_mutable:dht.ClosestRingPeersResponse.requestId)
  return _s;
}
inline const std::string& ClosestRingPeersResponse::_internal_requestid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestid_.Get();
}
inline void ClosestRingPeersResponse::_internal_set_requestid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(value, GetArena());
}
inline std::string* ClosestRingPeersResponse::_internal_mutable_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.requestid_.Mutable( GetArena());
}
inline std::string* ClosestRingPeersResponse::release_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.ClosestRingPeersResponse.requestId)
  return _impl_.requestid_.Release();
}
inline void ClosestRingPeersResponse::set_allocated_requestid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestid_.IsDefault()) {
          _impl_.requestid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.ClosestRingPeersResponse.requestId)
}

// -------------------------------------------------------------------

// RecursiveOperationRequest

// string sessionId = 1;
inline void RecursiveOperationRequest::clear_sessionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sessionid_.ClearToEmpty();
}
inline const std::string& RecursiveOperationRequest::sessionid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.RecursiveOperationRequest.sessionId)
  return _internal_sessionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecursiveOperationRequest::set_sessionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sessionid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.RecursiveOperationRequest.sessionId)
}
inline std::string* RecursiveOperationRequest::mutable_sessionid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:dht.RecursiveOperationRequest.sessionId)
  return _s;
}
inline const std::string& RecursiveOperationRequest::_internal_sessionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sessionid_.Get();
}
inline void RecursiveOperationRequest::_internal_set_sessionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sessionid_.Set(value, GetArena());
}
inline std::string* RecursiveOperationRequest::_internal_mutable_sessionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.sessionid_.Mutable( GetArena());
}
inline std::string* RecursiveOperationRequest::release_sessionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.RecursiveOperationRequest.sessionId)
  return _impl_.sessionid_.Release();
}
inline void RecursiveOperationRequest::set_allocated_sessionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sessionid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sessionid_.IsDefault()) {
          _impl_.sessionid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.RecursiveOperationRequest.sessionId)
}

// .dht.RecursiveOperation operation = 2;
inline void RecursiveOperationRequest::clear_operation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.operation_ = 0;
}
inline ::dht::RecursiveOperation RecursiveOperationRequest::operation() const {
  // @@protoc_insertion_point(field_get:dht.RecursiveOperationRequest.operation)
  return _internal_operation();
}
inline void RecursiveOperationRequest::set_operation(::dht::RecursiveOperation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:dht.RecursiveOperationRequest.operation)
}
inline ::dht::RecursiveOperation RecursiveOperationRequest::_internal_operation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::dht::RecursiveOperation>(_impl_.operation_);
}
inline void RecursiveOperationRequest::_internal_set_operation(::dht::RecursiveOperation value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.operation_ = value;
}

// -------------------------------------------------------------------

// RecursiveOperationResponse

// repeated .dht.PeerDescriptor closestConnectedNodes = 1;
inline int RecursiveOperationResponse::_internal_closestconnectednodes_size() const {
  return _internal_closestconnectednodes().size();
}
inline int RecursiveOperationResponse::closestconnectednodes_size() const {
  return _internal_closestconnectednodes_size();
}
inline void RecursiveOperationResponse::clear_closestconnectednodes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.closestconnectednodes_.Clear();
}
inline ::dht::PeerDescriptor* RecursiveOperationResponse::mutable_closestconnectednodes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dht.RecursiveOperationResponse.closestConnectedNodes)
  return _internal_mutable_closestconnectednodes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* RecursiveOperationResponse::mutable_closestconnectednodes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dht.RecursiveOperationResponse.closestConnectedNodes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_closestconnectednodes();
}
inline const ::dht::PeerDescriptor& RecursiveOperationResponse::closestconnectednodes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.RecursiveOperationResponse.closestConnectedNodes)
  return _internal_closestconnectednodes().Get(index);
}
inline ::dht::PeerDescriptor* RecursiveOperationResponse::add_closestconnectednodes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dht::PeerDescriptor* _add = _internal_mutable_closestconnectednodes()->Add();
  // @@protoc_insertion_point(field_add:dht.RecursiveOperationResponse.closestConnectedNodes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& RecursiveOperationResponse::closestconnectednodes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dht.RecursiveOperationResponse.closestConnectedNodes)
  return _internal_closestconnectednodes();
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>&
RecursiveOperationResponse::_internal_closestconnectednodes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.closestconnectednodes_;
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>*
RecursiveOperationResponse::_internal_mutable_closestconnectednodes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.closestconnectednodes_;
}

// repeated .dht.DataEntry dataEntries = 2;
inline int RecursiveOperationResponse::_internal_dataentries_size() const {
  return _internal_dataentries().size();
}
inline int RecursiveOperationResponse::dataentries_size() const {
  return _internal_dataentries_size();
}
inline void RecursiveOperationResponse::clear_dataentries() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dataentries_.Clear();
}
inline ::dht::DataEntry* RecursiveOperationResponse::mutable_dataentries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dht.RecursiveOperationResponse.dataEntries)
  return _internal_mutable_dataentries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dht::DataEntry>* RecursiveOperationResponse::mutable_dataentries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dht.RecursiveOperationResponse.dataEntries)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dataentries();
}
inline const ::dht::DataEntry& RecursiveOperationResponse::dataentries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.RecursiveOperationResponse.dataEntries)
  return _internal_dataentries().Get(index);
}
inline ::dht::DataEntry* RecursiveOperationResponse::add_dataentries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dht::DataEntry* _add = _internal_mutable_dataentries()->Add();
  // @@protoc_insertion_point(field_add:dht.RecursiveOperationResponse.dataEntries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dht::DataEntry>& RecursiveOperationResponse::dataentries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dht.RecursiveOperationResponse.dataEntries)
  return _internal_dataentries();
}
inline const ::google::protobuf::RepeatedPtrField<::dht::DataEntry>&
RecursiveOperationResponse::_internal_dataentries() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dataentries_;
}
inline ::google::protobuf::RepeatedPtrField<::dht::DataEntry>*
RecursiveOperationResponse::_internal_mutable_dataentries() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dataentries_;
}

// bool noCloserNodesFound = 3;
inline void RecursiveOperationResponse::clear_noclosernodesfound() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.noclosernodesfound_ = false;
}
inline bool RecursiveOperationResponse::noclosernodesfound() const {
  // @@protoc_insertion_point(field_get:dht.RecursiveOperationResponse.noCloserNodesFound)
  return _internal_noclosernodesfound();
}
inline void RecursiveOperationResponse::set_noclosernodesfound(bool value) {
  _internal_set_noclosernodesfound(value);
  // @@protoc_insertion_point(field_set:dht.RecursiveOperationResponse.noCloserNodesFound)
}
inline bool RecursiveOperationResponse::_internal_noclosernodesfound() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.noclosernodesfound_;
}
inline void RecursiveOperationResponse::_internal_set_noclosernodesfound(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.noclosernodesfound_ = value;
}

// repeated .dht.PeerDescriptor routingPath = 4;
inline int RecursiveOperationResponse::_internal_routingpath_size() const {
  return _internal_routingpath().size();
}
inline int RecursiveOperationResponse::routingpath_size() const {
  return _internal_routingpath_size();
}
inline void RecursiveOperationResponse::clear_routingpath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.routingpath_.Clear();
}
inline ::dht::PeerDescriptor* RecursiveOperationResponse::mutable_routingpath(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dht.RecursiveOperationResponse.routingPath)
  return _internal_mutable_routingpath()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* RecursiveOperationResponse::mutable_routingpath()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dht.RecursiveOperationResponse.routingPath)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_routingpath();
}
inline const ::dht::PeerDescriptor& RecursiveOperationResponse::routingpath(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.RecursiveOperationResponse.routingPath)
  return _internal_routingpath().Get(index);
}
inline ::dht::PeerDescriptor* RecursiveOperationResponse::add_routingpath() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dht::PeerDescriptor* _add = _internal_mutable_routingpath()->Add();
  // @@protoc_insertion_point(field_add:dht.RecursiveOperationResponse.routingPath)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& RecursiveOperationResponse::routingpath() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dht.RecursiveOperationResponse.routingPath)
  return _internal_routingpath();
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>&
RecursiveOperationResponse::_internal_routingpath() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.routingpath_;
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>*
RecursiveOperationResponse::_internal_mutable_routingpath() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.routingpath_;
}

// -------------------------------------------------------------------

// PingRequest

// string requestId = 1;
inline void PingRequest::clear_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.ClearToEmpty();
}
inline const std::string& PingRequest::requestid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.PingRequest.requestId)
  return _internal_requestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PingRequest::set_requestid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.PingRequest.requestId)
}
inline std::string* PingRequest::mutable_requestid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_requestid();
  // @@protoc_insertion_point(field_mutable:dht.PingRequest.requestId)
  return _s;
}
inline const std::string& PingRequest::_internal_requestid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestid_.Get();
}
inline void PingRequest::_internal_set_requestid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(value, GetArena());
}
inline std::string* PingRequest::_internal_mutable_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.requestid_.Mutable( GetArena());
}
inline std::string* PingRequest::release_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.PingRequest.requestId)
  return _impl_.requestid_.Release();
}
inline void PingRequest::set_allocated_requestid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestid_.IsDefault()) {
          _impl_.requestid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.PingRequest.requestId)
}

// -------------------------------------------------------------------

// PingResponse

// string requestId = 1;
inline void PingResponse::clear_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.ClearToEmpty();
}
inline const std::string& PingResponse::requestid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.PingResponse.requestId)
  return _internal_requestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PingResponse::set_requestid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.PingResponse.requestId)
}
inline std::string* PingResponse::mutable_requestid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_requestid();
  // @@protoc_insertion_point(field_mutable:dht.PingResponse.requestId)
  return _s;
}
inline const std::string& PingResponse::_internal_requestid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestid_.Get();
}
inline void PingResponse::_internal_set_requestid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(value, GetArena());
}
inline std::string* PingResponse::_internal_mutable_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.requestid_.Mutable( GetArena());
}
inline std::string* PingResponse::release_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.PingResponse.requestId)
  return _impl_.requestid_.Release();
}
inline void PingResponse::set_allocated_requestid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestid_.IsDefault()) {
          _impl_.requestid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.PingResponse.requestId)
}

// -------------------------------------------------------------------

// LeaveNotice

// -------------------------------------------------------------------

// PeerDescriptor

// bytes nodeId = 1;
inline void PeerDescriptor::clear_nodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nodeid_.ClearToEmpty();
}
inline const std::string& PeerDescriptor::nodeid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.PeerDescriptor.nodeId)
  return _internal_nodeid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeerDescriptor::set_nodeid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nodeid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.PeerDescriptor.nodeId)
}
inline std::string* PeerDescriptor::mutable_nodeid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nodeid();
  // @@protoc_insertion_point(field_mutable:dht.PeerDescriptor.nodeId)
  return _s;
}
inline const std::string& PeerDescriptor::_internal_nodeid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nodeid_.Get();
}
inline void PeerDescriptor::_internal_set_nodeid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nodeid_.Set(value, GetArena());
}
inline std::string* PeerDescriptor::_internal_mutable_nodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.nodeid_.Mutable( GetArena());
}
inline std::string* PeerDescriptor::release_nodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.PeerDescriptor.nodeId)
  return _impl_.nodeid_.Release();
}
inline void PeerDescriptor::set_allocated_nodeid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nodeid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nodeid_.IsDefault()) {
          _impl_.nodeid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.PeerDescriptor.nodeId)
}

// .dht.NodeType type = 2;
inline void PeerDescriptor::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::dht::NodeType PeerDescriptor::type() const {
  // @@protoc_insertion_point(field_get:dht.PeerDescriptor.type)
  return _internal_type();
}
inline void PeerDescriptor::set_type(::dht::NodeType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:dht.PeerDescriptor.type)
}
inline ::dht::NodeType PeerDescriptor::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::dht::NodeType>(_impl_.type_);
}
inline void PeerDescriptor::_internal_set_type(::dht::NodeType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .dht.ConnectivityMethod udp = 3;
inline bool PeerDescriptor::has_udp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.udp_ != nullptr);
  return value;
}
inline void PeerDescriptor::clear_udp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.udp_ != nullptr) _impl_.udp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::dht::ConnectivityMethod& PeerDescriptor::_internal_udp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dht::ConnectivityMethod* p = _impl_.udp_;
  return p != nullptr ? *p : reinterpret_cast<const ::dht::ConnectivityMethod&>(::dht::_ConnectivityMethod_default_instance_);
}
inline const ::dht::ConnectivityMethod& PeerDescriptor::udp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.PeerDescriptor.udp)
  return _internal_udp();
}
inline void PeerDescriptor::unsafe_arena_set_allocated_udp(::dht::ConnectivityMethod* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.udp_);
  }
  _impl_.udp_ = reinterpret_cast<::dht::ConnectivityMethod*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.PeerDescriptor.udp)
}
inline ::dht::ConnectivityMethod* PeerDescriptor::release_udp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::dht::ConnectivityMethod* released = _impl_.udp_;
  _impl_.udp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dht::ConnectivityMethod* PeerDescriptor::unsafe_arena_release_udp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.PeerDescriptor.udp)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::dht::ConnectivityMethod* temp = _impl_.udp_;
  _impl_.udp_ = nullptr;
  return temp;
}
inline ::dht::ConnectivityMethod* PeerDescriptor::_internal_mutable_udp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.udp_ == nullptr) {
    auto* p = CreateMaybeMessage<::dht::ConnectivityMethod>(GetArena());
    _impl_.udp_ = reinterpret_cast<::dht::ConnectivityMethod*>(p);
  }
  return _impl_.udp_;
}
inline ::dht::ConnectivityMethod* PeerDescriptor::mutable_udp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::ConnectivityMethod* _msg = _internal_mutable_udp();
  // @@protoc_insertion_point(field_mutable:dht.PeerDescriptor.udp)
  return _msg;
}
inline void PeerDescriptor::set_allocated_udp(::dht::ConnectivityMethod* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::dht::ConnectivityMethod*>(_impl_.udp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::dht::ConnectivityMethod*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.udp_ = reinterpret_cast<::dht::ConnectivityMethod*>(value);
  // @@protoc_insertion_point(field_set_allocated:dht.PeerDescriptor.udp)
}

// .dht.ConnectivityMethod tcp = 4;
inline bool PeerDescriptor::has_tcp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tcp_ != nullptr);
  return value;
}
inline void PeerDescriptor::clear_tcp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tcp_ != nullptr) _impl_.tcp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::dht::ConnectivityMethod& PeerDescriptor::_internal_tcp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dht::ConnectivityMethod* p = _impl_.tcp_;
  return p != nullptr ? *p : reinterpret_cast<const ::dht::ConnectivityMethod&>(::dht::_ConnectivityMethod_default_instance_);
}
inline const ::dht::ConnectivityMethod& PeerDescriptor::tcp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.PeerDescriptor.tcp)
  return _internal_tcp();
}
inline void PeerDescriptor::unsafe_arena_set_allocated_tcp(::dht::ConnectivityMethod* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tcp_);
  }
  _impl_.tcp_ = reinterpret_cast<::dht::ConnectivityMethod*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.PeerDescriptor.tcp)
}
inline ::dht::ConnectivityMethod* PeerDescriptor::release_tcp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::dht::ConnectivityMethod* released = _impl_.tcp_;
  _impl_.tcp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dht::ConnectivityMethod* PeerDescriptor::unsafe_arena_release_tcp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.PeerDescriptor.tcp)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::dht::ConnectivityMethod* temp = _impl_.tcp_;
  _impl_.tcp_ = nullptr;
  return temp;
}
inline ::dht::ConnectivityMethod* PeerDescriptor::_internal_mutable_tcp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.tcp_ == nullptr) {
    auto* p = CreateMaybeMessage<::dht::ConnectivityMethod>(GetArena());
    _impl_.tcp_ = reinterpret_cast<::dht::ConnectivityMethod*>(p);
  }
  return _impl_.tcp_;
}
inline ::dht::ConnectivityMethod* PeerDescriptor::mutable_tcp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::ConnectivityMethod* _msg = _internal_mutable_tcp();
  // @@protoc_insertion_point(field_mutable:dht.PeerDescriptor.tcp)
  return _msg;
}
inline void PeerDescriptor::set_allocated_tcp(::dht::ConnectivityMethod* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::dht::ConnectivityMethod*>(_impl_.tcp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::dht::ConnectivityMethod*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.tcp_ = reinterpret_cast<::dht::ConnectivityMethod*>(value);
  // @@protoc_insertion_point(field_set_allocated:dht.PeerDescriptor.tcp)
}

// .dht.ConnectivityMethod websocket = 5;
inline bool PeerDescriptor::has_websocket() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.websocket_ != nullptr);
  return value;
}
inline void PeerDescriptor::clear_websocket() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.websocket_ != nullptr) _impl_.websocket_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::dht::ConnectivityMethod& PeerDescriptor::_internal_websocket() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dht::ConnectivityMethod* p = _impl_.websocket_;
  return p != nullptr ? *p : reinterpret_cast<const ::dht::ConnectivityMethod&>(::dht::_ConnectivityMethod_default_instance_);
}
inline const ::dht::ConnectivityMethod& PeerDescriptor::websocket() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.PeerDescriptor.websocket)
  return _internal_websocket();
}
inline void PeerDescriptor::unsafe_arena_set_allocated_websocket(::dht::ConnectivityMethod* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.websocket_);
  }
  _impl_.websocket_ = reinterpret_cast<::dht::ConnectivityMethod*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.PeerDescriptor.websocket)
}
inline ::dht::ConnectivityMethod* PeerDescriptor::release_websocket() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::dht::ConnectivityMethod* released = _impl_.websocket_;
  _impl_.websocket_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dht::ConnectivityMethod* PeerDescriptor::unsafe_arena_release_websocket() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.PeerDescriptor.websocket)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::dht::ConnectivityMethod* temp = _impl_.websocket_;
  _impl_.websocket_ = nullptr;
  return temp;
}
inline ::dht::ConnectivityMethod* PeerDescriptor::_internal_mutable_websocket() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.websocket_ == nullptr) {
    auto* p = CreateMaybeMessage<::dht::ConnectivityMethod>(GetArena());
    _impl_.websocket_ = reinterpret_cast<::dht::ConnectivityMethod*>(p);
  }
  return _impl_.websocket_;
}
inline ::dht::ConnectivityMethod* PeerDescriptor::mutable_websocket() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::ConnectivityMethod* _msg = _internal_mutable_websocket();
  // @@protoc_insertion_point(field_mutable:dht.PeerDescriptor.websocket)
  return _msg;
}
inline void PeerDescriptor::set_allocated_websocket(::dht::ConnectivityMethod* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::dht::ConnectivityMethod*>(_impl_.websocket_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::dht::ConnectivityMethod*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.websocket_ = reinterpret_cast<::dht::ConnectivityMethod*>(value);
  // @@protoc_insertion_point(field_set_allocated:dht.PeerDescriptor.websocket)
}

// optional uint32 region = 6;
inline bool PeerDescriptor::has_region() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void PeerDescriptor::clear_region() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.region_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t PeerDescriptor::region() const {
  // @@protoc_insertion_point(field_get:dht.PeerDescriptor.region)
  return _internal_region();
}
inline void PeerDescriptor::set_region(::uint32_t value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:dht.PeerDescriptor.region)
}
inline ::uint32_t PeerDescriptor::_internal_region() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.region_;
}
inline void PeerDescriptor::_internal_set_region(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.region_ = value;
}

// optional uint32 ipAddress = 7;
inline bool PeerDescriptor::has_ipaddress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void PeerDescriptor::clear_ipaddress() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ipaddress_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t PeerDescriptor::ipaddress() const {
  // @@protoc_insertion_point(field_get:dht.PeerDescriptor.ipAddress)
  return _internal_ipaddress();
}
inline void PeerDescriptor::set_ipaddress(::uint32_t value) {
  _internal_set_ipaddress(value);
  // @@protoc_insertion_point(field_set:dht.PeerDescriptor.ipAddress)
}
inline ::uint32_t PeerDescriptor::_internal_ipaddress() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ipaddress_;
}
inline void PeerDescriptor::_internal_set_ipaddress(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.ipaddress_ = value;
}

// optional bytes publicKey = 8;
inline bool PeerDescriptor::has_publickey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PeerDescriptor::clear_publickey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.publickey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PeerDescriptor::publickey() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.PeerDescriptor.publicKey)
  return _internal_publickey();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeerDescriptor::set_publickey(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.publickey_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.PeerDescriptor.publicKey)
}
inline std::string* PeerDescriptor::mutable_publickey() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_publickey();
  // @@protoc_insertion_point(field_mutable:dht.PeerDescriptor.publicKey)
  return _s;
}
inline const std::string& PeerDescriptor::_internal_publickey() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.publickey_.Get();
}
inline void PeerDescriptor::_internal_set_publickey(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.publickey_.Set(value, GetArena());
}
inline std::string* PeerDescriptor::_internal_mutable_publickey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.publickey_.Mutable( GetArena());
}
inline std::string* PeerDescriptor::release_publickey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.PeerDescriptor.publicKey)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.publickey_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.publickey_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PeerDescriptor::set_allocated_publickey(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.publickey_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.publickey_.IsDefault()) {
          _impl_.publickey_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.PeerDescriptor.publicKey)
}

// optional bytes signature = 9;
inline bool PeerDescriptor::has_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PeerDescriptor::clear_signature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PeerDescriptor::signature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.PeerDescriptor.signature)
  return _internal_signature();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeerDescriptor::set_signature(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.signature_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.PeerDescriptor.signature)
}
inline std::string* PeerDescriptor::mutable_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:dht.PeerDescriptor.signature)
  return _s;
}
inline const std::string& PeerDescriptor::_internal_signature() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.signature_.Get();
}
inline void PeerDescriptor::_internal_set_signature(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.signature_.Set(value, GetArena());
}
inline std::string* PeerDescriptor::_internal_mutable_signature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.signature_.Mutable( GetArena());
}
inline std::string* PeerDescriptor::release_signature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.PeerDescriptor.signature)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.signature_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PeerDescriptor::set_allocated_signature(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.signature_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signature_.IsDefault()) {
          _impl_.signature_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.PeerDescriptor.signature)
}

// -------------------------------------------------------------------

// ConnectivityMethod

// uint32 port = 1;
inline void ConnectivityMethod::clear_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = 0u;
}
inline ::uint32_t ConnectivityMethod::port() const {
  // @@protoc_insertion_point(field_get:dht.ConnectivityMethod.port)
  return _internal_port();
}
inline void ConnectivityMethod::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:dht.ConnectivityMethod.port)
}
inline ::uint32_t ConnectivityMethod::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void ConnectivityMethod::_internal_set_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// string host = 2;
inline void ConnectivityMethod::clear_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.host_.ClearToEmpty();
}
inline const std::string& ConnectivityMethod::host() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ConnectivityMethod.host)
  return _internal_host();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectivityMethod::set_host(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.host_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.ConnectivityMethod.host)
}
inline std::string* ConnectivityMethod::mutable_host() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:dht.ConnectivityMethod.host)
  return _s;
}
inline const std::string& ConnectivityMethod::_internal_host() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.host_.Get();
}
inline void ConnectivityMethod::_internal_set_host(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.host_.Set(value, GetArena());
}
inline std::string* ConnectivityMethod::_internal_mutable_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.host_.Mutable( GetArena());
}
inline std::string* ConnectivityMethod::release_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.ConnectivityMethod.host)
  return _impl_.host_.Release();
}
inline void ConnectivityMethod::set_allocated_host(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.host_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.host_.IsDefault()) {
          _impl_.host_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.ConnectivityMethod.host)
}

// bool tls = 3;
inline void ConnectivityMethod::clear_tls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tls_ = false;
}
inline bool ConnectivityMethod::tls() const {
  // @@protoc_insertion_point(field_get:dht.ConnectivityMethod.tls)
  return _internal_tls();
}
inline void ConnectivityMethod::set_tls(bool value) {
  _internal_set_tls(value);
  // @@protoc_insertion_point(field_set:dht.ConnectivityMethod.tls)
}
inline bool ConnectivityMethod::_internal_tls() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tls_;
}
inline void ConnectivityMethod::_internal_set_tls(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tls_ = value;
}

// -------------------------------------------------------------------

// RouteMessageWrapper

// string requestId = 1;
inline void RouteMessageWrapper::clear_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.ClearToEmpty();
}
inline const std::string& RouteMessageWrapper::requestid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.RouteMessageWrapper.requestId)
  return _internal_requestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouteMessageWrapper::set_requestid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.RouteMessageWrapper.requestId)
}
inline std::string* RouteMessageWrapper::mutable_requestid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_requestid();
  // @@protoc_insertion_point(field_mutable:dht.RouteMessageWrapper.requestId)
  return _s;
}
inline const std::string& RouteMessageWrapper::_internal_requestid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestid_.Get();
}
inline void RouteMessageWrapper::_internal_set_requestid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(value, GetArena());
}
inline std::string* RouteMessageWrapper::_internal_mutable_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.requestid_.Mutable( GetArena());
}
inline std::string* RouteMessageWrapper::release_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.RouteMessageWrapper.requestId)
  return _impl_.requestid_.Release();
}
inline void RouteMessageWrapper::set_allocated_requestid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestid_.IsDefault()) {
          _impl_.requestid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.RouteMessageWrapper.requestId)
}

// .dht.PeerDescriptor sourcePeer = 2;
inline bool RouteMessageWrapper::has_sourcepeer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sourcepeer_ != nullptr);
  return value;
}
inline void RouteMessageWrapper::clear_sourcepeer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.sourcepeer_ != nullptr) _impl_.sourcepeer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dht::PeerDescriptor& RouteMessageWrapper::_internal_sourcepeer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dht::PeerDescriptor* p = _impl_.sourcepeer_;
  return p != nullptr ? *p : reinterpret_cast<const ::dht::PeerDescriptor&>(::dht::_PeerDescriptor_default_instance_);
}
inline const ::dht::PeerDescriptor& RouteMessageWrapper::sourcepeer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.RouteMessageWrapper.sourcePeer)
  return _internal_sourcepeer();
}
inline void RouteMessageWrapper::unsafe_arena_set_allocated_sourcepeer(::dht::PeerDescriptor* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sourcepeer_);
  }
  _impl_.sourcepeer_ = reinterpret_cast<::dht::PeerDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.RouteMessageWrapper.sourcePeer)
}
inline ::dht::PeerDescriptor* RouteMessageWrapper::release_sourcepeer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dht::PeerDescriptor* released = _impl_.sourcepeer_;
  _impl_.sourcepeer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dht::PeerDescriptor* RouteMessageWrapper::unsafe_arena_release_sourcepeer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.RouteMessageWrapper.sourcePeer)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dht::PeerDescriptor* temp = _impl_.sourcepeer_;
  _impl_.sourcepeer_ = nullptr;
  return temp;
}
inline ::dht::PeerDescriptor* RouteMessageWrapper::_internal_mutable_sourcepeer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sourcepeer_ == nullptr) {
    auto* p = CreateMaybeMessage<::dht::PeerDescriptor>(GetArena());
    _impl_.sourcepeer_ = reinterpret_cast<::dht::PeerDescriptor*>(p);
  }
  return _impl_.sourcepeer_;
}
inline ::dht::PeerDescriptor* RouteMessageWrapper::mutable_sourcepeer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::PeerDescriptor* _msg = _internal_mutable_sourcepeer();
  // @@protoc_insertion_point(field_mutable:dht.RouteMessageWrapper.sourcePeer)
  return _msg;
}
inline void RouteMessageWrapper::set_allocated_sourcepeer(::dht::PeerDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::dht::PeerDescriptor*>(_impl_.sourcepeer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::dht::PeerDescriptor*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.sourcepeer_ = reinterpret_cast<::dht::PeerDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:dht.RouteMessageWrapper.sourcePeer)
}

// bytes target = 3;
inline void RouteMessageWrapper::clear_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& RouteMessageWrapper::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.RouteMessageWrapper.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouteMessageWrapper::set_target(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.RouteMessageWrapper.target)
}
inline std::string* RouteMessageWrapper::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:dht.RouteMessageWrapper.target)
  return _s;
}
inline const std::string& RouteMessageWrapper::_internal_target() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_.Get();
}
inline void RouteMessageWrapper::_internal_set_target(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_.Set(value, GetArena());
}
inline std::string* RouteMessageWrapper::_internal_mutable_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* RouteMessageWrapper::release_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.RouteMessageWrapper.target)
  return _impl_.target_.Release();
}
inline void RouteMessageWrapper::set_allocated_target(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_.IsDefault()) {
          _impl_.target_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.RouteMessageWrapper.target)
}

// .dht.Message message = 4;
inline bool RouteMessageWrapper::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.message_ != nullptr);
  return value;
}
inline void RouteMessageWrapper::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.message_ != nullptr) _impl_.message_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::dht::Message& RouteMessageWrapper::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dht::Message* p = _impl_.message_;
  return p != nullptr ? *p : reinterpret_cast<const ::dht::Message&>(::dht::_Message_default_instance_);
}
inline const ::dht::Message& RouteMessageWrapper::message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.RouteMessageWrapper.message)
  return _internal_message();
}
inline void RouteMessageWrapper::unsafe_arena_set_allocated_message(::dht::Message* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.message_);
  }
  _impl_.message_ = reinterpret_cast<::dht::Message*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.RouteMessageWrapper.message)
}
inline ::dht::Message* RouteMessageWrapper::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dht::Message* released = _impl_.message_;
  _impl_.message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dht::Message* RouteMessageWrapper::unsafe_arena_release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.RouteMessageWrapper.message)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dht::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
  return temp;
}
inline ::dht::Message* RouteMessageWrapper::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.message_ == nullptr) {
    auto* p = CreateMaybeMessage<::dht::Message>(GetArena());
    _impl_.message_ = reinterpret_cast<::dht::Message*>(p);
  }
  return _impl_.message_;
}
inline ::dht::Message* RouteMessageWrapper::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::Message* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:dht.RouteMessageWrapper.message)
  return _msg;
}
inline void RouteMessageWrapper::set_allocated_message(::dht::Message* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::dht::Message*>(_impl_.message_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::dht::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.message_ = reinterpret_cast<::dht::Message*>(value);
  // @@protoc_insertion_point(field_set_allocated:dht.RouteMessageWrapper.message)
}

// repeated .dht.PeerDescriptor reachableThrough = 5;
inline int RouteMessageWrapper::_internal_reachablethrough_size() const {
  return _internal_reachablethrough().size();
}
inline int RouteMessageWrapper::reachablethrough_size() const {
  return _internal_reachablethrough_size();
}
inline void RouteMessageWrapper::clear_reachablethrough() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reachablethrough_.Clear();
}
inline ::dht::PeerDescriptor* RouteMessageWrapper::mutable_reachablethrough(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dht.RouteMessageWrapper.reachableThrough)
  return _internal_mutable_reachablethrough()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* RouteMessageWrapper::mutable_reachablethrough()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dht.RouteMessageWrapper.reachableThrough)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_reachablethrough();
}
inline const ::dht::PeerDescriptor& RouteMessageWrapper::reachablethrough(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.RouteMessageWrapper.reachableThrough)
  return _internal_reachablethrough().Get(index);
}
inline ::dht::PeerDescriptor* RouteMessageWrapper::add_reachablethrough() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dht::PeerDescriptor* _add = _internal_mutable_reachablethrough()->Add();
  // @@protoc_insertion_point(field_add:dht.RouteMessageWrapper.reachableThrough)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& RouteMessageWrapper::reachablethrough() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dht.RouteMessageWrapper.reachableThrough)
  return _internal_reachablethrough();
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>&
RouteMessageWrapper::_internal_reachablethrough() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reachablethrough_;
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>*
RouteMessageWrapper::_internal_mutable_reachablethrough() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.reachablethrough_;
}

// repeated .dht.PeerDescriptor routingPath = 6;
inline int RouteMessageWrapper::_internal_routingpath_size() const {
  return _internal_routingpath().size();
}
inline int RouteMessageWrapper::routingpath_size() const {
  return _internal_routingpath_size();
}
inline void RouteMessageWrapper::clear_routingpath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.routingpath_.Clear();
}
inline ::dht::PeerDescriptor* RouteMessageWrapper::mutable_routingpath(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dht.RouteMessageWrapper.routingPath)
  return _internal_mutable_routingpath()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* RouteMessageWrapper::mutable_routingpath()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dht.RouteMessageWrapper.routingPath)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_routingpath();
}
inline const ::dht::PeerDescriptor& RouteMessageWrapper::routingpath(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.RouteMessageWrapper.routingPath)
  return _internal_routingpath().Get(index);
}
inline ::dht::PeerDescriptor* RouteMessageWrapper::add_routingpath() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dht::PeerDescriptor* _add = _internal_mutable_routingpath()->Add();
  // @@protoc_insertion_point(field_add:dht.RouteMessageWrapper.routingPath)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& RouteMessageWrapper::routingpath() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dht.RouteMessageWrapper.routingPath)
  return _internal_routingpath();
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>&
RouteMessageWrapper::_internal_routingpath() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.routingpath_;
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>*
RouteMessageWrapper::_internal_mutable_routingpath() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.routingpath_;
}

// repeated string parallelRootNodeIds = 7;
inline int RouteMessageWrapper::_internal_parallelrootnodeids_size() const {
  return _internal_parallelrootnodeids().size();
}
inline int RouteMessageWrapper::parallelrootnodeids_size() const {
  return _internal_parallelrootnodeids_size();
}
inline void RouteMessageWrapper::clear_parallelrootnodeids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parallelrootnodeids_.Clear();
}
inline std::string* RouteMessageWrapper::add_parallelrootnodeids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_parallelrootnodeids()->Add();
  // @@protoc_insertion_point(field_add_mutable:dht.RouteMessageWrapper.parallelRootNodeIds)
  return _s;
}
inline const std::string& RouteMessageWrapper::parallelrootnodeids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.RouteMessageWrapper.parallelRootNodeIds)
  return _internal_parallelrootnodeids().Get(index);
}
inline std::string* RouteMessageWrapper::mutable_parallelrootnodeids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dht.RouteMessageWrapper.parallelRootNodeIds)
  return _internal_mutable_parallelrootnodeids()->Mutable(index);
}
inline void RouteMessageWrapper::set_parallelrootnodeids(int index, const std::string& value) {
  _internal_mutable_parallelrootnodeids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:dht.RouteMessageWrapper.parallelRootNodeIds)
}
inline void RouteMessageWrapper::set_parallelrootnodeids(int index, std::string&& value) {
  _internal_mutable_parallelrootnodeids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:dht.RouteMessageWrapper.parallelRootNodeIds)
}
inline void RouteMessageWrapper::set_parallelrootnodeids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_parallelrootnodeids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dht.RouteMessageWrapper.parallelRootNodeIds)
}
inline void RouteMessageWrapper::set_parallelrootnodeids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_parallelrootnodeids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dht.RouteMessageWrapper.parallelRootNodeIds)
}
inline void RouteMessageWrapper::set_parallelrootnodeids(int index, absl::string_view value) {
  _internal_mutable_parallelrootnodeids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:dht.RouteMessageWrapper.parallelRootNodeIds)
}
inline void RouteMessageWrapper::add_parallelrootnodeids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_parallelrootnodeids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:dht.RouteMessageWrapper.parallelRootNodeIds)
}
inline void RouteMessageWrapper::add_parallelrootnodeids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_parallelrootnodeids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:dht.RouteMessageWrapper.parallelRootNodeIds)
}
inline void RouteMessageWrapper::add_parallelrootnodeids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_parallelrootnodeids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dht.RouteMessageWrapper.parallelRootNodeIds)
}
inline void RouteMessageWrapper::add_parallelrootnodeids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_parallelrootnodeids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dht.RouteMessageWrapper.parallelRootNodeIds)
}
inline void RouteMessageWrapper::add_parallelrootnodeids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_parallelrootnodeids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:dht.RouteMessageWrapper.parallelRootNodeIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RouteMessageWrapper::parallelrootnodeids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dht.RouteMessageWrapper.parallelRootNodeIds)
  return _internal_parallelrootnodeids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RouteMessageWrapper::mutable_parallelrootnodeids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dht.RouteMessageWrapper.parallelRootNodeIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_parallelrootnodeids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RouteMessageWrapper::_internal_parallelrootnodeids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parallelrootnodeids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RouteMessageWrapper::_internal_mutable_parallelrootnodeids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.parallelrootnodeids_;
}

// -------------------------------------------------------------------

// RouteMessageAck

// string requestId = 1;
inline void RouteMessageAck::clear_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.ClearToEmpty();
}
inline const std::string& RouteMessageAck::requestid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.RouteMessageAck.requestId)
  return _internal_requestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouteMessageAck::set_requestid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.RouteMessageAck.requestId)
}
inline std::string* RouteMessageAck::mutable_requestid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_requestid();
  // @@protoc_insertion_point(field_mutable:dht.RouteMessageAck.requestId)
  return _s;
}
inline const std::string& RouteMessageAck::_internal_requestid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestid_.Get();
}
inline void RouteMessageAck::_internal_set_requestid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(value, GetArena());
}
inline std::string* RouteMessageAck::_internal_mutable_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.requestid_.Mutable( GetArena());
}
inline std::string* RouteMessageAck::release_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.RouteMessageAck.requestId)
  return _impl_.requestid_.Release();
}
inline void RouteMessageAck::set_allocated_requestid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestid_.IsDefault()) {
          _impl_.requestid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.RouteMessageAck.requestId)
}

// optional .dht.RouteMessageError error = 2;
inline bool RouteMessageAck::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RouteMessageAck::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::dht::RouteMessageError RouteMessageAck::error() const {
  // @@protoc_insertion_point(field_get:dht.RouteMessageAck.error)
  return _internal_error();
}
inline void RouteMessageAck::set_error(::dht::RouteMessageError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:dht.RouteMessageAck.error)
}
inline ::dht::RouteMessageError RouteMessageAck::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::dht::RouteMessageError>(_impl_.error_);
}
inline void RouteMessageAck::_internal_set_error(::dht::RouteMessageError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_ = value;
}

// -------------------------------------------------------------------

// ConnectivityRequest

// uint32 port = 1;
inline void ConnectivityRequest::clear_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = 0u;
}
inline ::uint32_t ConnectivityRequest::port() const {
  // @@protoc_insertion_point(field_get:dht.ConnectivityRequest.port)
  return _internal_port();
}
inline void ConnectivityRequest::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:dht.ConnectivityRequest.port)
}
inline ::uint32_t ConnectivityRequest::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void ConnectivityRequest::_internal_set_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// bool tls = 2;
inline void ConnectivityRequest::clear_tls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tls_ = false;
}
inline bool ConnectivityRequest::tls() const {
  // @@protoc_insertion_point(field_get:dht.ConnectivityRequest.tls)
  return _internal_tls();
}
inline void ConnectivityRequest::set_tls(bool value) {
  _internal_set_tls(value);
  // @@protoc_insertion_point(field_set:dht.ConnectivityRequest.tls)
}
inline bool ConnectivityRequest::_internal_tls() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tls_;
}
inline void ConnectivityRequest::_internal_set_tls(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tls_ = value;
}

// optional string host = 3;
inline bool ConnectivityRequest::has_host() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ConnectivityRequest::clear_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.host_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConnectivityRequest::host() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ConnectivityRequest.host)
  return _internal_host();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectivityRequest::set_host(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.host_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.ConnectivityRequest.host)
}
inline std::string* ConnectivityRequest::mutable_host() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:dht.ConnectivityRequest.host)
  return _s;
}
inline const std::string& ConnectivityRequest::_internal_host() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.host_.Get();
}
inline void ConnectivityRequest::_internal_set_host(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.host_.Set(value, GetArena());
}
inline std::string* ConnectivityRequest::_internal_mutable_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.host_.Mutable( GetArena());
}
inline std::string* ConnectivityRequest::release_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.ConnectivityRequest.host)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.host_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.host_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ConnectivityRequest::set_allocated_host(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.host_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.host_.IsDefault()) {
          _impl_.host_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.ConnectivityRequest.host)
}

// bool allowSelfSignedCertificate = 4;
inline void ConnectivityRequest::clear_allowselfsignedcertificate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allowselfsignedcertificate_ = false;
}
inline bool ConnectivityRequest::allowselfsignedcertificate() const {
  // @@protoc_insertion_point(field_get:dht.ConnectivityRequest.allowSelfSignedCertificate)
  return _internal_allowselfsignedcertificate();
}
inline void ConnectivityRequest::set_allowselfsignedcertificate(bool value) {
  _internal_set_allowselfsignedcertificate(value);
  // @@protoc_insertion_point(field_set:dht.ConnectivityRequest.allowSelfSignedCertificate)
}
inline bool ConnectivityRequest::_internal_allowselfsignedcertificate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allowselfsignedcertificate_;
}
inline void ConnectivityRequest::_internal_set_allowselfsignedcertificate(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.allowselfsignedcertificate_ = value;
}

// -------------------------------------------------------------------

// ConnectivityResponse

// string host = 1;
inline void ConnectivityResponse::clear_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.host_.ClearToEmpty();
}
inline const std::string& ConnectivityResponse::host() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ConnectivityResponse.host)
  return _internal_host();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectivityResponse::set_host(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.host_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.ConnectivityResponse.host)
}
inline std::string* ConnectivityResponse::mutable_host() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:dht.ConnectivityResponse.host)
  return _s;
}
inline const std::string& ConnectivityResponse::_internal_host() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.host_.Get();
}
inline void ConnectivityResponse::_internal_set_host(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.host_.Set(value, GetArena());
}
inline std::string* ConnectivityResponse::_internal_mutable_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.host_.Mutable( GetArena());
}
inline std::string* ConnectivityResponse::release_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.ConnectivityResponse.host)
  return _impl_.host_.Release();
}
inline void ConnectivityResponse::set_allocated_host(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.host_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.host_.IsDefault()) {
          _impl_.host_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.ConnectivityResponse.host)
}

// string natType = 2;
inline void ConnectivityResponse::clear_nattype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nattype_.ClearToEmpty();
}
inline const std::string& ConnectivityResponse::nattype() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ConnectivityResponse.natType)
  return _internal_nattype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectivityResponse::set_nattype(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nattype_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.ConnectivityResponse.natType)
}
inline std::string* ConnectivityResponse::mutable_nattype() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nattype();
  // @@protoc_insertion_point(field_mutable:dht.ConnectivityResponse.natType)
  return _s;
}
inline const std::string& ConnectivityResponse::_internal_nattype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nattype_.Get();
}
inline void ConnectivityResponse::_internal_set_nattype(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nattype_.Set(value, GetArena());
}
inline std::string* ConnectivityResponse::_internal_mutable_nattype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.nattype_.Mutable( GetArena());
}
inline std::string* ConnectivityResponse::release_nattype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.ConnectivityResponse.natType)
  return _impl_.nattype_.Release();
}
inline void ConnectivityResponse::set_allocated_nattype(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nattype_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nattype_.IsDefault()) {
          _impl_.nattype_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.ConnectivityResponse.natType)
}

// .dht.ConnectivityMethod websocket = 3;
inline bool ConnectivityResponse::has_websocket() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.websocket_ != nullptr);
  return value;
}
inline void ConnectivityResponse::clear_websocket() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.websocket_ != nullptr) _impl_.websocket_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dht::ConnectivityMethod& ConnectivityResponse::_internal_websocket() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dht::ConnectivityMethod* p = _impl_.websocket_;
  return p != nullptr ? *p : reinterpret_cast<const ::dht::ConnectivityMethod&>(::dht::_ConnectivityMethod_default_instance_);
}
inline const ::dht::ConnectivityMethod& ConnectivityResponse::websocket() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ConnectivityResponse.websocket)
  return _internal_websocket();
}
inline void ConnectivityResponse::unsafe_arena_set_allocated_websocket(::dht::ConnectivityMethod* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.websocket_);
  }
  _impl_.websocket_ = reinterpret_cast<::dht::ConnectivityMethod*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.ConnectivityResponse.websocket)
}
inline ::dht::ConnectivityMethod* ConnectivityResponse::release_websocket() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dht::ConnectivityMethod* released = _impl_.websocket_;
  _impl_.websocket_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dht::ConnectivityMethod* ConnectivityResponse::unsafe_arena_release_websocket() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.ConnectivityResponse.websocket)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dht::ConnectivityMethod* temp = _impl_.websocket_;
  _impl_.websocket_ = nullptr;
  return temp;
}
inline ::dht::ConnectivityMethod* ConnectivityResponse::_internal_mutable_websocket() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.websocket_ == nullptr) {
    auto* p = CreateMaybeMessage<::dht::ConnectivityMethod>(GetArena());
    _impl_.websocket_ = reinterpret_cast<::dht::ConnectivityMethod*>(p);
  }
  return _impl_.websocket_;
}
inline ::dht::ConnectivityMethod* ConnectivityResponse::mutable_websocket() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::ConnectivityMethod* _msg = _internal_mutable_websocket();
  // @@protoc_insertion_point(field_mutable:dht.ConnectivityResponse.websocket)
  return _msg;
}
inline void ConnectivityResponse::set_allocated_websocket(::dht::ConnectivityMethod* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::dht::ConnectivityMethod*>(_impl_.websocket_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::dht::ConnectivityMethod*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.websocket_ = reinterpret_cast<::dht::ConnectivityMethod*>(value);
  // @@protoc_insertion_point(field_set_allocated:dht.ConnectivityResponse.websocket)
}

// uint32 ipAddress = 4;
inline void ConnectivityResponse::clear_ipaddress() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ipaddress_ = 0u;
}
inline ::uint32_t ConnectivityResponse::ipaddress() const {
  // @@protoc_insertion_point(field_get:dht.ConnectivityResponse.ipAddress)
  return _internal_ipaddress();
}
inline void ConnectivityResponse::set_ipaddress(::uint32_t value) {
  _internal_set_ipaddress(value);
  // @@protoc_insertion_point(field_set:dht.ConnectivityResponse.ipAddress)
}
inline ::uint32_t ConnectivityResponse::_internal_ipaddress() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ipaddress_;
}
inline void ConnectivityResponse::_internal_set_ipaddress(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ipaddress_ = value;
}

// string version = 5;
inline void ConnectivityResponse::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ConnectivityResponse::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ConnectivityResponse.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectivityResponse::set_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.ConnectivityResponse.version)
}
inline std::string* ConnectivityResponse::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:dht.ConnectivityResponse.version)
  return _s;
}
inline const std::string& ConnectivityResponse::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_.Get();
}
inline void ConnectivityResponse::_internal_set_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(value, GetArena());
}
inline std::string* ConnectivityResponse::_internal_mutable_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* ConnectivityResponse::release_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.ConnectivityResponse.version)
  return _impl_.version_.Release();
}
inline void ConnectivityResponse::set_allocated_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.ConnectivityResponse.version)
}

// optional double latitude = 6;
inline bool ConnectivityResponse::has_latitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ConnectivityResponse::clear_latitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ConnectivityResponse::latitude() const {
  // @@protoc_insertion_point(field_get:dht.ConnectivityResponse.latitude)
  return _internal_latitude();
}
inline void ConnectivityResponse::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:dht.ConnectivityResponse.latitude)
}
inline double ConnectivityResponse::_internal_latitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.latitude_;
}
inline void ConnectivityResponse::_internal_set_latitude(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.latitude_ = value;
}

// optional double longitude = 7;
inline bool ConnectivityResponse::has_longitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ConnectivityResponse::clear_longitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.longitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ConnectivityResponse::longitude() const {
  // @@protoc_insertion_point(field_get:dht.ConnectivityResponse.longitude)
  return _internal_longitude();
}
inline void ConnectivityResponse::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:dht.ConnectivityResponse.longitude)
}
inline double ConnectivityResponse::_internal_longitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.longitude_;
}
inline void ConnectivityResponse::_internal_set_longitude(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.longitude_ = value;
}

// -------------------------------------------------------------------

// HandshakeRequest

// .dht.PeerDescriptor sourcePeerDescriptor = 1;
inline bool HandshakeRequest::has_sourcepeerdescriptor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sourcepeerdescriptor_ != nullptr);
  return value;
}
inline void HandshakeRequest::clear_sourcepeerdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.sourcepeerdescriptor_ != nullptr) _impl_.sourcepeerdescriptor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dht::PeerDescriptor& HandshakeRequest::_internal_sourcepeerdescriptor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dht::PeerDescriptor* p = _impl_.sourcepeerdescriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::dht::PeerDescriptor&>(::dht::_PeerDescriptor_default_instance_);
}
inline const ::dht::PeerDescriptor& HandshakeRequest::sourcepeerdescriptor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.HandshakeRequest.sourcePeerDescriptor)
  return _internal_sourcepeerdescriptor();
}
inline void HandshakeRequest::unsafe_arena_set_allocated_sourcepeerdescriptor(::dht::PeerDescriptor* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sourcepeerdescriptor_);
  }
  _impl_.sourcepeerdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.HandshakeRequest.sourcePeerDescriptor)
}
inline ::dht::PeerDescriptor* HandshakeRequest::release_sourcepeerdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dht::PeerDescriptor* released = _impl_.sourcepeerdescriptor_;
  _impl_.sourcepeerdescriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dht::PeerDescriptor* HandshakeRequest::unsafe_arena_release_sourcepeerdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.HandshakeRequest.sourcePeerDescriptor)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dht::PeerDescriptor* temp = _impl_.sourcepeerdescriptor_;
  _impl_.sourcepeerdescriptor_ = nullptr;
  return temp;
}
inline ::dht::PeerDescriptor* HandshakeRequest::_internal_mutable_sourcepeerdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sourcepeerdescriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::dht::PeerDescriptor>(GetArena());
    _impl_.sourcepeerdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(p);
  }
  return _impl_.sourcepeerdescriptor_;
}
inline ::dht::PeerDescriptor* HandshakeRequest::mutable_sourcepeerdescriptor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::PeerDescriptor* _msg = _internal_mutable_sourcepeerdescriptor();
  // @@protoc_insertion_point(field_mutable:dht.HandshakeRequest.sourcePeerDescriptor)
  return _msg;
}
inline void HandshakeRequest::set_allocated_sourcepeerdescriptor(::dht::PeerDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::dht::PeerDescriptor*>(_impl_.sourcepeerdescriptor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::dht::PeerDescriptor*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.sourcepeerdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:dht.HandshakeRequest.sourcePeerDescriptor)
}

// optional .dht.PeerDescriptor targetPeerDescriptor = 2;
inline bool HandshakeRequest::has_targetpeerdescriptor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.targetpeerdescriptor_ != nullptr);
  return value;
}
inline void HandshakeRequest::clear_targetpeerdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.targetpeerdescriptor_ != nullptr) _impl_.targetpeerdescriptor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::dht::PeerDescriptor& HandshakeRequest::_internal_targetpeerdescriptor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dht::PeerDescriptor* p = _impl_.targetpeerdescriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::dht::PeerDescriptor&>(::dht::_PeerDescriptor_default_instance_);
}
inline const ::dht::PeerDescriptor& HandshakeRequest::targetpeerdescriptor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.HandshakeRequest.targetPeerDescriptor)
  return _internal_targetpeerdescriptor();
}
inline void HandshakeRequest::unsafe_arena_set_allocated_targetpeerdescriptor(::dht::PeerDescriptor* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.targetpeerdescriptor_);
  }
  _impl_.targetpeerdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.HandshakeRequest.targetPeerDescriptor)
}
inline ::dht::PeerDescriptor* HandshakeRequest::release_targetpeerdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dht::PeerDescriptor* released = _impl_.targetpeerdescriptor_;
  _impl_.targetpeerdescriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dht::PeerDescriptor* HandshakeRequest::unsafe_arena_release_targetpeerdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.HandshakeRequest.targetPeerDescriptor)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dht::PeerDescriptor* temp = _impl_.targetpeerdescriptor_;
  _impl_.targetpeerdescriptor_ = nullptr;
  return temp;
}
inline ::dht::PeerDescriptor* HandshakeRequest::_internal_mutable_targetpeerdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.targetpeerdescriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::dht::PeerDescriptor>(GetArena());
    _impl_.targetpeerdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(p);
  }
  return _impl_.targetpeerdescriptor_;
}
inline ::dht::PeerDescriptor* HandshakeRequest::mutable_targetpeerdescriptor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::PeerDescriptor* _msg = _internal_mutable_targetpeerdescriptor();
  // @@protoc_insertion_point(field_mutable:dht.HandshakeRequest.targetPeerDescriptor)
  return _msg;
}
inline void HandshakeRequest::set_allocated_targetpeerdescriptor(::dht::PeerDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::dht::PeerDescriptor*>(_impl_.targetpeerdescriptor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::dht::PeerDescriptor*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.targetpeerdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:dht.HandshakeRequest.targetPeerDescriptor)
}

// string version = 3;
inline void HandshakeRequest::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.ClearToEmpty();
}
inline const std::string& HandshakeRequest::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.HandshakeRequest.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HandshakeRequest::set_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.HandshakeRequest.version)
}
inline std::string* HandshakeRequest::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:dht.HandshakeRequest.version)
  return _s;
}
inline const std::string& HandshakeRequest::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_.Get();
}
inline void HandshakeRequest::_internal_set_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(value, GetArena());
}
inline std::string* HandshakeRequest::_internal_mutable_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* HandshakeRequest::release_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.HandshakeRequest.version)
  return _impl_.version_.Release();
}
inline void HandshakeRequest::set_allocated_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.HandshakeRequest.version)
}

// -------------------------------------------------------------------

// HandshakeResponse

// .dht.PeerDescriptor sourcePeerDescriptor = 1;
inline bool HandshakeResponse::has_sourcepeerdescriptor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sourcepeerdescriptor_ != nullptr);
  return value;
}
inline void HandshakeResponse::clear_sourcepeerdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.sourcepeerdescriptor_ != nullptr) _impl_.sourcepeerdescriptor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dht::PeerDescriptor& HandshakeResponse::_internal_sourcepeerdescriptor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dht::PeerDescriptor* p = _impl_.sourcepeerdescriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::dht::PeerDescriptor&>(::dht::_PeerDescriptor_default_instance_);
}
inline const ::dht::PeerDescriptor& HandshakeResponse::sourcepeerdescriptor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.HandshakeResponse.sourcePeerDescriptor)
  return _internal_sourcepeerdescriptor();
}
inline void HandshakeResponse::unsafe_arena_set_allocated_sourcepeerdescriptor(::dht::PeerDescriptor* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sourcepeerdescriptor_);
  }
  _impl_.sourcepeerdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.HandshakeResponse.sourcePeerDescriptor)
}
inline ::dht::PeerDescriptor* HandshakeResponse::release_sourcepeerdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dht::PeerDescriptor* released = _impl_.sourcepeerdescriptor_;
  _impl_.sourcepeerdescriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dht::PeerDescriptor* HandshakeResponse::unsafe_arena_release_sourcepeerdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.HandshakeResponse.sourcePeerDescriptor)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dht::PeerDescriptor* temp = _impl_.sourcepeerdescriptor_;
  _impl_.sourcepeerdescriptor_ = nullptr;
  return temp;
}
inline ::dht::PeerDescriptor* HandshakeResponse::_internal_mutable_sourcepeerdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sourcepeerdescriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::dht::PeerDescriptor>(GetArena());
    _impl_.sourcepeerdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(p);
  }
  return _impl_.sourcepeerdescriptor_;
}
inline ::dht::PeerDescriptor* HandshakeResponse::mutable_sourcepeerdescriptor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::PeerDescriptor* _msg = _internal_mutable_sourcepeerdescriptor();
  // @@protoc_insertion_point(field_mutable:dht.HandshakeResponse.sourcePeerDescriptor)
  return _msg;
}
inline void HandshakeResponse::set_allocated_sourcepeerdescriptor(::dht::PeerDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::dht::PeerDescriptor*>(_impl_.sourcepeerdescriptor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::dht::PeerDescriptor*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.sourcepeerdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:dht.HandshakeResponse.sourcePeerDescriptor)
}

// optional .dht.HandshakeError error = 2;
inline bool HandshakeResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void HandshakeResponse::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::dht::HandshakeError HandshakeResponse::error() const {
  // @@protoc_insertion_point(field_get:dht.HandshakeResponse.error)
  return _internal_error();
}
inline void HandshakeResponse::set_error(::dht::HandshakeError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:dht.HandshakeResponse.error)
}
inline ::dht::HandshakeError HandshakeResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::dht::HandshakeError>(_impl_.error_);
}
inline void HandshakeResponse::_internal_set_error(::dht::HandshakeError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.error_ = value;
}

// string version = 3;
inline void HandshakeResponse::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.ClearToEmpty();
}
inline const std::string& HandshakeResponse::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.HandshakeResponse.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HandshakeResponse::set_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.HandshakeResponse.version)
}
inline std::string* HandshakeResponse::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:dht.HandshakeResponse.version)
  return _s;
}
inline const std::string& HandshakeResponse::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_.Get();
}
inline void HandshakeResponse::_internal_set_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(value, GetArena());
}
inline std::string* HandshakeResponse::_internal_mutable_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* HandshakeResponse::release_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.HandshakeResponse.version)
  return _impl_.version_.Release();
}
inline void HandshakeResponse::set_allocated_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.HandshakeResponse.version)
}

// -------------------------------------------------------------------

// Message

// string messageId = 1;
inline void Message::clear_messageid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.messageid_.ClearToEmpty();
}
inline const std::string& Message::messageid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.Message.messageId)
  return _internal_messageid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Message::set_messageid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.messageid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.Message.messageId)
}
inline std::string* Message::mutable_messageid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_messageid();
  // @@protoc_insertion_point(field_mutable:dht.Message.messageId)
  return _s;
}
inline const std::string& Message::_internal_messageid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.messageid_.Get();
}
inline void Message::_internal_set_messageid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.messageid_.Set(value, GetArena());
}
inline std::string* Message::_internal_mutable_messageid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.messageid_.Mutable( GetArena());
}
inline std::string* Message::release_messageid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.Message.messageId)
  return _impl_.messageid_.Release();
}
inline void Message::set_allocated_messageid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.messageid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.messageid_.IsDefault()) {
          _impl_.messageid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.Message.messageId)
}

// .dht.PeerDescriptor sourceDescriptor = 2;
inline bool Message::has_sourcedescriptor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sourcedescriptor_ != nullptr);
  return value;
}
inline void Message::clear_sourcedescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.sourcedescriptor_ != nullptr) _impl_.sourcedescriptor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dht::PeerDescriptor& Message::_internal_sourcedescriptor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dht::PeerDescriptor* p = _impl_.sourcedescriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::dht::PeerDescriptor&>(::dht::_PeerDescriptor_default_instance_);
}
inline const ::dht::PeerDescriptor& Message::sourcedescriptor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.Message.sourceDescriptor)
  return _internal_sourcedescriptor();
}
inline void Message::unsafe_arena_set_allocated_sourcedescriptor(::dht::PeerDescriptor* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sourcedescriptor_);
  }
  _impl_.sourcedescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.Message.sourceDescriptor)
}
inline ::dht::PeerDescriptor* Message::release_sourcedescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dht::PeerDescriptor* released = _impl_.sourcedescriptor_;
  _impl_.sourcedescriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dht::PeerDescriptor* Message::unsafe_arena_release_sourcedescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.Message.sourceDescriptor)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dht::PeerDescriptor* temp = _impl_.sourcedescriptor_;
  _impl_.sourcedescriptor_ = nullptr;
  return temp;
}
inline ::dht::PeerDescriptor* Message::_internal_mutable_sourcedescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sourcedescriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::dht::PeerDescriptor>(GetArena());
    _impl_.sourcedescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(p);
  }
  return _impl_.sourcedescriptor_;
}
inline ::dht::PeerDescriptor* Message::mutable_sourcedescriptor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::PeerDescriptor* _msg = _internal_mutable_sourcedescriptor();
  // @@protoc_insertion_point(field_mutable:dht.Message.sourceDescriptor)
  return _msg;
}
inline void Message::set_allocated_sourcedescriptor(::dht::PeerDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::dht::PeerDescriptor*>(_impl_.sourcedescriptor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::dht::PeerDescriptor*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.sourcedescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:dht.Message.sourceDescriptor)
}

// .dht.PeerDescriptor targetDescriptor = 3;
inline bool Message::has_targetdescriptor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.targetdescriptor_ != nullptr);
  return value;
}
inline void Message::clear_targetdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.targetdescriptor_ != nullptr) _impl_.targetdescriptor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::dht::PeerDescriptor& Message::_internal_targetdescriptor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dht::PeerDescriptor* p = _impl_.targetdescriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::dht::PeerDescriptor&>(::dht::_PeerDescriptor_default_instance_);
}
inline const ::dht::PeerDescriptor& Message::targetdescriptor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.Message.targetDescriptor)
  return _internal_targetdescriptor();
}
inline void Message::unsafe_arena_set_allocated_targetdescriptor(::dht::PeerDescriptor* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.targetdescriptor_);
  }
  _impl_.targetdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.Message.targetDescriptor)
}
inline ::dht::PeerDescriptor* Message::release_targetdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dht::PeerDescriptor* released = _impl_.targetdescriptor_;
  _impl_.targetdescriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dht::PeerDescriptor* Message::unsafe_arena_release_targetdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.Message.targetDescriptor)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dht::PeerDescriptor* temp = _impl_.targetdescriptor_;
  _impl_.targetdescriptor_ = nullptr;
  return temp;
}
inline ::dht::PeerDescriptor* Message::_internal_mutable_targetdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.targetdescriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::dht::PeerDescriptor>(GetArena());
    _impl_.targetdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(p);
  }
  return _impl_.targetdescriptor_;
}
inline ::dht::PeerDescriptor* Message::mutable_targetdescriptor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::PeerDescriptor* _msg = _internal_mutable_targetdescriptor();
  // @@protoc_insertion_point(field_mutable:dht.Message.targetDescriptor)
  return _msg;
}
inline void Message::set_allocated_targetdescriptor(::dht::PeerDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::dht::PeerDescriptor*>(_impl_.targetdescriptor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::dht::PeerDescriptor*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.targetdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:dht.Message.targetDescriptor)
}

// string serviceId = 4;
inline void Message::clear_serviceid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.serviceid_.ClearToEmpty();
}
inline const std::string& Message::serviceid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.Message.serviceId)
  return _internal_serviceid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Message::set_serviceid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.serviceid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.Message.serviceId)
}
inline std::string* Message::mutable_serviceid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_serviceid();
  // @@protoc_insertion_point(field_mutable:dht.Message.serviceId)
  return _s;
}
inline const std::string& Message::_internal_serviceid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.serviceid_.Get();
}
inline void Message::_internal_set_serviceid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.serviceid_.Set(value, GetArena());
}
inline std::string* Message::_internal_mutable_serviceid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.serviceid_.Mutable( GetArena());
}
inline std::string* Message::release_serviceid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.Message.serviceId)
  return _impl_.serviceid_.Release();
}
inline void Message::set_allocated_serviceid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.serviceid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.serviceid_.IsDefault()) {
          _impl_.serviceid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.Message.serviceId)
}

// .protorpc.RpcMessage rpcMessage = 5;
inline bool Message::has_rpcmessage() const {
  return body_case() == kRpcMessage;
}
inline bool Message::_internal_has_rpcmessage() const {
  return body_case() == kRpcMessage;
}
inline void Message::set_has_rpcmessage() {
  _impl_._oneof_case_[0] = kRpcMessage;
}
inline ::protorpc::RpcMessage* Message::release_rpcmessage() {
  // @@protoc_insertion_point(field_release:dht.Message.rpcMessage)
  if (body_case() == kRpcMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.rpcmessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.rpcmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protorpc::RpcMessage& Message::_internal_rpcmessage() const {
  return body_case() == kRpcMessage ? *_impl_.body_.rpcmessage_ : reinterpret_cast<::protorpc::RpcMessage&>(::protorpc::_RpcMessage_default_instance_);
}
inline const ::protorpc::RpcMessage& Message::rpcmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.Message.rpcMessage)
  return _internal_rpcmessage();
}
inline ::protorpc::RpcMessage* Message::unsafe_arena_release_rpcmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dht.Message.rpcMessage)
  if (body_case() == kRpcMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.rpcmessage_;
    _impl_.body_.rpcmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_rpcmessage(::protorpc::RpcMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_rpcmessage();
    _impl_.body_.rpcmessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.Message.rpcMessage)
}
inline ::protorpc::RpcMessage* Message::_internal_mutable_rpcmessage() {
  if (body_case() != kRpcMessage) {
    clear_body();
    set_has_rpcmessage();
    _impl_.body_.rpcmessage_ = CreateMaybeMessage<::protorpc::RpcMessage>(GetArena());
  }
  return _impl_.body_.rpcmessage_;
}
inline ::protorpc::RpcMessage* Message::mutable_rpcmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protorpc::RpcMessage* _msg = _internal_mutable_rpcmessage();
  // @@protoc_insertion_point(field_mutable:dht.Message.rpcMessage)
  return _msg;
}

// .dht.ConnectivityRequest connectivityRequest = 6;
inline bool Message::has_connectivityrequest() const {
  return body_case() == kConnectivityRequest;
}
inline bool Message::_internal_has_connectivityrequest() const {
  return body_case() == kConnectivityRequest;
}
inline void Message::set_has_connectivityrequest() {
  _impl_._oneof_case_[0] = kConnectivityRequest;
}
inline void Message::clear_connectivityrequest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (body_case() == kConnectivityRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.connectivityrequest_;
    }
    clear_has_body();
  }
}
inline ::dht::ConnectivityRequest* Message::release_connectivityrequest() {
  // @@protoc_insertion_point(field_release:dht.Message.connectivityRequest)
  if (body_case() == kConnectivityRequest) {
    clear_has_body();
    auto* temp = _impl_.body_.connectivityrequest_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.connectivityrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dht::ConnectivityRequest& Message::_internal_connectivityrequest() const {
  return body_case() == kConnectivityRequest ? *_impl_.body_.connectivityrequest_ : reinterpret_cast<::dht::ConnectivityRequest&>(::dht::_ConnectivityRequest_default_instance_);
}
inline const ::dht::ConnectivityRequest& Message::connectivityrequest() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.Message.connectivityRequest)
  return _internal_connectivityrequest();
}
inline ::dht::ConnectivityRequest* Message::unsafe_arena_release_connectivityrequest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dht.Message.connectivityRequest)
  if (body_case() == kConnectivityRequest) {
    clear_has_body();
    auto* temp = _impl_.body_.connectivityrequest_;
    _impl_.body_.connectivityrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_connectivityrequest(::dht::ConnectivityRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_connectivityrequest();
    _impl_.body_.connectivityrequest_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.Message.connectivityRequest)
}
inline ::dht::ConnectivityRequest* Message::_internal_mutable_connectivityrequest() {
  if (body_case() != kConnectivityRequest) {
    clear_body();
    set_has_connectivityrequest();
    _impl_.body_.connectivityrequest_ = CreateMaybeMessage<::dht::ConnectivityRequest>(GetArena());
  }
  return _impl_.body_.connectivityrequest_;
}
inline ::dht::ConnectivityRequest* Message::mutable_connectivityrequest() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::ConnectivityRequest* _msg = _internal_mutable_connectivityrequest();
  // @@protoc_insertion_point(field_mutable:dht.Message.connectivityRequest)
  return _msg;
}

// .dht.ConnectivityResponse connectivityResponse = 7;
inline bool Message::has_connectivityresponse() const {
  return body_case() == kConnectivityResponse;
}
inline bool Message::_internal_has_connectivityresponse() const {
  return body_case() == kConnectivityResponse;
}
inline void Message::set_has_connectivityresponse() {
  _impl_._oneof_case_[0] = kConnectivityResponse;
}
inline void Message::clear_connectivityresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (body_case() == kConnectivityResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.connectivityresponse_;
    }
    clear_has_body();
  }
}
inline ::dht::ConnectivityResponse* Message::release_connectivityresponse() {
  // @@protoc_insertion_point(field_release:dht.Message.connectivityResponse)
  if (body_case() == kConnectivityResponse) {
    clear_has_body();
    auto* temp = _impl_.body_.connectivityresponse_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.connectivityresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dht::ConnectivityResponse& Message::_internal_connectivityresponse() const {
  return body_case() == kConnectivityResponse ? *_impl_.body_.connectivityresponse_ : reinterpret_cast<::dht::ConnectivityResponse&>(::dht::_ConnectivityResponse_default_instance_);
}
inline const ::dht::ConnectivityResponse& Message::connectivityresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.Message.connectivityResponse)
  return _internal_connectivityresponse();
}
inline ::dht::ConnectivityResponse* Message::unsafe_arena_release_connectivityresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dht.Message.connectivityResponse)
  if (body_case() == kConnectivityResponse) {
    clear_has_body();
    auto* temp = _impl_.body_.connectivityresponse_;
    _impl_.body_.connectivityresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_connectivityresponse(::dht::ConnectivityResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_connectivityresponse();
    _impl_.body_.connectivityresponse_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.Message.connectivityResponse)
}
inline ::dht::ConnectivityResponse* Message::_internal_mutable_connectivityresponse() {
  if (body_case() != kConnectivityResponse) {
    clear_body();
    set_has_connectivityresponse();
    _impl_.body_.connectivityresponse_ = CreateMaybeMessage<::dht::ConnectivityResponse>(GetArena());
  }
  return _impl_.body_.connectivityresponse_;
}
inline ::dht::ConnectivityResponse* Message::mutable_connectivityresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::ConnectivityResponse* _msg = _internal_mutable_connectivityresponse();
  // @@protoc_insertion_point(field_mutable:dht.Message.connectivityResponse)
  return _msg;
}

// .dht.HandshakeRequest handshakeRequest = 8;
inline bool Message::has_handshakerequest() const {
  return body_case() == kHandshakeRequest;
}
inline bool Message::_internal_has_handshakerequest() const {
  return body_case() == kHandshakeRequest;
}
inline void Message::set_has_handshakerequest() {
  _impl_._oneof_case_[0] = kHandshakeRequest;
}
inline void Message::clear_handshakerequest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (body_case() == kHandshakeRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.handshakerequest_;
    }
    clear_has_body();
  }
}
inline ::dht::HandshakeRequest* Message::release_handshakerequest() {
  // @@protoc_insertion_point(field_release:dht.Message.handshakeRequest)
  if (body_case() == kHandshakeRequest) {
    clear_has_body();
    auto* temp = _impl_.body_.handshakerequest_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.handshakerequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dht::HandshakeRequest& Message::_internal_handshakerequest() const {
  return body_case() == kHandshakeRequest ? *_impl_.body_.handshakerequest_ : reinterpret_cast<::dht::HandshakeRequest&>(::dht::_HandshakeRequest_default_instance_);
}
inline const ::dht::HandshakeRequest& Message::handshakerequest() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.Message.handshakeRequest)
  return _internal_handshakerequest();
}
inline ::dht::HandshakeRequest* Message::unsafe_arena_release_handshakerequest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dht.Message.handshakeRequest)
  if (body_case() == kHandshakeRequest) {
    clear_has_body();
    auto* temp = _impl_.body_.handshakerequest_;
    _impl_.body_.handshakerequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_handshakerequest(::dht::HandshakeRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_handshakerequest();
    _impl_.body_.handshakerequest_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.Message.handshakeRequest)
}
inline ::dht::HandshakeRequest* Message::_internal_mutable_handshakerequest() {
  if (body_case() != kHandshakeRequest) {
    clear_body();
    set_has_handshakerequest();
    _impl_.body_.handshakerequest_ = CreateMaybeMessage<::dht::HandshakeRequest>(GetArena());
  }
  return _impl_.body_.handshakerequest_;
}
inline ::dht::HandshakeRequest* Message::mutable_handshakerequest() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::HandshakeRequest* _msg = _internal_mutable_handshakerequest();
  // @@protoc_insertion_point(field_mutable:dht.Message.handshakeRequest)
  return _msg;
}

// .dht.HandshakeResponse handshakeResponse = 9;
inline bool Message::has_handshakeresponse() const {
  return body_case() == kHandshakeResponse;
}
inline bool Message::_internal_has_handshakeresponse() const {
  return body_case() == kHandshakeResponse;
}
inline void Message::set_has_handshakeresponse() {
  _impl_._oneof_case_[0] = kHandshakeResponse;
}
inline void Message::clear_handshakeresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (body_case() == kHandshakeResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.handshakeresponse_;
    }
    clear_has_body();
  }
}
inline ::dht::HandshakeResponse* Message::release_handshakeresponse() {
  // @@protoc_insertion_point(field_release:dht.Message.handshakeResponse)
  if (body_case() == kHandshakeResponse) {
    clear_has_body();
    auto* temp = _impl_.body_.handshakeresponse_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.handshakeresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dht::HandshakeResponse& Message::_internal_handshakeresponse() const {
  return body_case() == kHandshakeResponse ? *_impl_.body_.handshakeresponse_ : reinterpret_cast<::dht::HandshakeResponse&>(::dht::_HandshakeResponse_default_instance_);
}
inline const ::dht::HandshakeResponse& Message::handshakeresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.Message.handshakeResponse)
  return _internal_handshakeresponse();
}
inline ::dht::HandshakeResponse* Message::unsafe_arena_release_handshakeresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dht.Message.handshakeResponse)
  if (body_case() == kHandshakeResponse) {
    clear_has_body();
    auto* temp = _impl_.body_.handshakeresponse_;
    _impl_.body_.handshakeresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_handshakeresponse(::dht::HandshakeResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_handshakeresponse();
    _impl_.body_.handshakeresponse_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.Message.handshakeResponse)
}
inline ::dht::HandshakeResponse* Message::_internal_mutable_handshakeresponse() {
  if (body_case() != kHandshakeResponse) {
    clear_body();
    set_has_handshakeresponse();
    _impl_.body_.handshakeresponse_ = CreateMaybeMessage<::dht::HandshakeResponse>(GetArena());
  }
  return _impl_.body_.handshakeresponse_;
}
inline ::dht::HandshakeResponse* Message::mutable_handshakeresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::HandshakeResponse* _msg = _internal_mutable_handshakeresponse();
  // @@protoc_insertion_point(field_mutable:dht.Message.handshakeResponse)
  return _msg;
}

// .dht.RecursiveOperationRequest recursiveOperationRequest = 10;
inline bool Message::has_recursiveoperationrequest() const {
  return body_case() == kRecursiveOperationRequest;
}
inline bool Message::_internal_has_recursiveoperationrequest() const {
  return body_case() == kRecursiveOperationRequest;
}
inline void Message::set_has_recursiveoperationrequest() {
  _impl_._oneof_case_[0] = kRecursiveOperationRequest;
}
inline void Message::clear_recursiveoperationrequest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (body_case() == kRecursiveOperationRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.recursiveoperationrequest_;
    }
    clear_has_body();
  }
}
inline ::dht::RecursiveOperationRequest* Message::release_recursiveoperationrequest() {
  // @@protoc_insertion_point(field_release:dht.Message.recursiveOperationRequest)
  if (body_case() == kRecursiveOperationRequest) {
    clear_has_body();
    auto* temp = _impl_.body_.recursiveoperationrequest_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.recursiveoperationrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dht::RecursiveOperationRequest& Message::_internal_recursiveoperationrequest() const {
  return body_case() == kRecursiveOperationRequest ? *_impl_.body_.recursiveoperationrequest_ : reinterpret_cast<::dht::RecursiveOperationRequest&>(::dht::_RecursiveOperationRequest_default_instance_);
}
inline const ::dht::RecursiveOperationRequest& Message::recursiveoperationrequest() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.Message.recursiveOperationRequest)
  return _internal_recursiveoperationrequest();
}
inline ::dht::RecursiveOperationRequest* Message::unsafe_arena_release_recursiveoperationrequest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dht.Message.recursiveOperationRequest)
  if (body_case() == kRecursiveOperationRequest) {
    clear_has_body();
    auto* temp = _impl_.body_.recursiveoperationrequest_;
    _impl_.body_.recursiveoperationrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_recursiveoperationrequest(::dht::RecursiveOperationRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_recursiveoperationrequest();
    _impl_.body_.recursiveoperationrequest_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dht.Message.recursiveOperationRequest)
}
inline ::dht::RecursiveOperationRequest* Message::_internal_mutable_recursiveoperationrequest() {
  if (body_case() != kRecursiveOperationRequest) {
    clear_body();
    set_has_recursiveoperationrequest();
    _impl_.body_.recursiveoperationrequest_ = CreateMaybeMessage<::dht::RecursiveOperationRequest>(GetArena());
  }
  return _impl_.body_.recursiveoperationrequest_;
}
inline ::dht::RecursiveOperationRequest* Message::mutable_recursiveoperationrequest() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::RecursiveOperationRequest* _msg = _internal_mutable_recursiveoperationrequest();
  // @@protoc_insertion_point(field_mutable:dht.Message.recursiveOperationRequest)
  return _msg;
}

inline bool Message::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void Message::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline Message::BodyCase Message::body_case() const {
  return Message::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// WebsocketConnectionRequest

// -------------------------------------------------------------------

// WebrtcConnectionRequest

// -------------------------------------------------------------------

// RtcOffer

// string description = 1;
inline void RtcOffer::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& RtcOffer::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.RtcOffer.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RtcOffer::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.RtcOffer.description)
}
inline std::string* RtcOffer::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:dht.RtcOffer.description)
  return _s;
}
inline const std::string& RtcOffer::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void RtcOffer::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* RtcOffer::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* RtcOffer::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.RtcOffer.description)
  return _impl_.description_.Release();
}
inline void RtcOffer::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.RtcOffer.description)
}

// string connectionId = 2;
inline void RtcOffer::clear_connectionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.connectionid_.ClearToEmpty();
}
inline const std::string& RtcOffer::connectionid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.RtcOffer.connectionId)
  return _internal_connectionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RtcOffer::set_connectionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.connectionid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.RtcOffer.connectionId)
}
inline std::string* RtcOffer::mutable_connectionid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_connectionid();
  // @@protoc_insertion_point(field_mutable:dht.RtcOffer.connectionId)
  return _s;
}
inline const std::string& RtcOffer::_internal_connectionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.connectionid_.Get();
}
inline void RtcOffer::_internal_set_connectionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.connectionid_.Set(value, GetArena());
}
inline std::string* RtcOffer::_internal_mutable_connectionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.connectionid_.Mutable( GetArena());
}
inline std::string* RtcOffer::release_connectionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.RtcOffer.connectionId)
  return _impl_.connectionid_.Release();
}
inline void RtcOffer::set_allocated_connectionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.connectionid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.connectionid_.IsDefault()) {
          _impl_.connectionid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.RtcOffer.connectionId)
}

// -------------------------------------------------------------------

// RtcAnswer

// string description = 1;
inline void RtcAnswer::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& RtcAnswer::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.RtcAnswer.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RtcAnswer::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.RtcAnswer.description)
}
inline std::string* RtcAnswer::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:dht.RtcAnswer.description)
  return _s;
}
inline const std::string& RtcAnswer::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void RtcAnswer::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* RtcAnswer::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* RtcAnswer::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.RtcAnswer.description)
  return _impl_.description_.Release();
}
inline void RtcAnswer::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.RtcAnswer.description)
}

// string connectionId = 2;
inline void RtcAnswer::clear_connectionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.connectionid_.ClearToEmpty();
}
inline const std::string& RtcAnswer::connectionid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.RtcAnswer.connectionId)
  return _internal_connectionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RtcAnswer::set_connectionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.connectionid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.RtcAnswer.connectionId)
}
inline std::string* RtcAnswer::mutable_connectionid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_connectionid();
  // @@protoc_insertion_point(field_mutable:dht.RtcAnswer.connectionId)
  return _s;
}
inline const std::string& RtcAnswer::_internal_connectionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.connectionid_.Get();
}
inline void RtcAnswer::_internal_set_connectionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.connectionid_.Set(value, GetArena());
}
inline std::string* RtcAnswer::_internal_mutable_connectionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.connectionid_.Mutable( GetArena());
}
inline std::string* RtcAnswer::release_connectionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.RtcAnswer.connectionId)
  return _impl_.connectionid_.Release();
}
inline void RtcAnswer::set_allocated_connectionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.connectionid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.connectionid_.IsDefault()) {
          _impl_.connectionid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.RtcAnswer.connectionId)
}

// -------------------------------------------------------------------

// IceCandidate

// string candidate = 1;
inline void IceCandidate::clear_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.candidate_.ClearToEmpty();
}
inline const std::string& IceCandidate::candidate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.IceCandidate.candidate)
  return _internal_candidate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IceCandidate::set_candidate(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.candidate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.IceCandidate.candidate)
}
inline std::string* IceCandidate::mutable_candidate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:dht.IceCandidate.candidate)
  return _s;
}
inline const std::string& IceCandidate::_internal_candidate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.candidate_.Get();
}
inline void IceCandidate::_internal_set_candidate(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.candidate_.Set(value, GetArena());
}
inline std::string* IceCandidate::_internal_mutable_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.candidate_.Mutable( GetArena());
}
inline std::string* IceCandidate::release_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.IceCandidate.candidate)
  return _impl_.candidate_.Release();
}
inline void IceCandidate::set_allocated_candidate(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.candidate_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.candidate_.IsDefault()) {
          _impl_.candidate_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.IceCandidate.candidate)
}

// string mid = 2;
inline void IceCandidate::clear_mid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mid_.ClearToEmpty();
}
inline const std::string& IceCandidate::mid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.IceCandidate.mid)
  return _internal_mid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IceCandidate::set_mid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.IceCandidate.mid)
}
inline std::string* IceCandidate::mutable_mid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mid();
  // @@protoc_insertion_point(field_mutable:dht.IceCandidate.mid)
  return _s;
}
inline const std::string& IceCandidate::_internal_mid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mid_.Get();
}
inline void IceCandidate::_internal_set_mid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mid_.Set(value, GetArena());
}
inline std::string* IceCandidate::_internal_mutable_mid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mid_.Mutable( GetArena());
}
inline std::string* IceCandidate::release_mid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.IceCandidate.mid)
  return _impl_.mid_.Release();
}
inline void IceCandidate::set_allocated_mid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mid_.IsDefault()) {
          _impl_.mid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.IceCandidate.mid)
}

// string connectionId = 3;
inline void IceCandidate::clear_connectionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.connectionid_.ClearToEmpty();
}
inline const std::string& IceCandidate::connectionid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.IceCandidate.connectionId)
  return _internal_connectionid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IceCandidate::set_connectionid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.connectionid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.IceCandidate.connectionId)
}
inline std::string* IceCandidate::mutable_connectionid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_connectionid();
  // @@protoc_insertion_point(field_mutable:dht.IceCandidate.connectionId)
  return _s;
}
inline const std::string& IceCandidate::_internal_connectionid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.connectionid_.Get();
}
inline void IceCandidate::_internal_set_connectionid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.connectionid_.Set(value, GetArena());
}
inline std::string* IceCandidate::_internal_mutable_connectionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.connectionid_.Mutable( GetArena());
}
inline std::string* IceCandidate::release_connectionid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.IceCandidate.connectionId)
  return _impl_.connectionid_.Release();
}
inline void IceCandidate::set_allocated_connectionid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.connectionid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.connectionid_.IsDefault()) {
          _impl_.connectionid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.IceCandidate.connectionId)
}

// -------------------------------------------------------------------

// LockRequest

// string lockId = 1;
inline void LockRequest::clear_lockid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lockid_.ClearToEmpty();
}
inline const std::string& LockRequest::lockid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.LockRequest.lockId)
  return _internal_lockid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LockRequest::set_lockid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lockid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.LockRequest.lockId)
}
inline std::string* LockRequest::mutable_lockid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_lockid();
  // @@protoc_insertion_point(field_mutable:dht.LockRequest.lockId)
  return _s;
}
inline const std::string& LockRequest::_internal_lockid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lockid_.Get();
}
inline void LockRequest::_internal_set_lockid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lockid_.Set(value, GetArena());
}
inline std::string* LockRequest::_internal_mutable_lockid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.lockid_.Mutable( GetArena());
}
inline std::string* LockRequest::release_lockid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.LockRequest.lockId)
  return _impl_.lockid_.Release();
}
inline void LockRequest::set_allocated_lockid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lockid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.lockid_.IsDefault()) {
          _impl_.lockid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.LockRequest.lockId)
}

// -------------------------------------------------------------------

// UnlockRequest

// string lockId = 1;
inline void UnlockRequest::clear_lockid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lockid_.ClearToEmpty();
}
inline const std::string& UnlockRequest::lockid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.UnlockRequest.lockId)
  return _internal_lockid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UnlockRequest::set_lockid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lockid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.UnlockRequest.lockId)
}
inline std::string* UnlockRequest::mutable_lockid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_lockid();
  // @@protoc_insertion_point(field_mutable:dht.UnlockRequest.lockId)
  return _s;
}
inline const std::string& UnlockRequest::_internal_lockid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lockid_.Get();
}
inline void UnlockRequest::_internal_set_lockid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lockid_.Set(value, GetArena());
}
inline std::string* UnlockRequest::_internal_mutable_lockid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.lockid_.Mutable( GetArena());
}
inline std::string* UnlockRequest::release_lockid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.UnlockRequest.lockId)
  return _impl_.lockid_.Release();
}
inline void UnlockRequest::set_allocated_lockid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lockid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.lockid_.IsDefault()) {
          _impl_.lockid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.UnlockRequest.lockId)
}

// -------------------------------------------------------------------

// LockResponse

// bool accepted = 1;
inline void LockResponse::clear_accepted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accepted_ = false;
}
inline bool LockResponse::accepted() const {
  // @@protoc_insertion_point(field_get:dht.LockResponse.accepted)
  return _internal_accepted();
}
inline void LockResponse::set_accepted(bool value) {
  _internal_set_accepted(value);
  // @@protoc_insertion_point(field_set:dht.LockResponse.accepted)
}
inline bool LockResponse::_internal_accepted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.accepted_;
}
inline void LockResponse::_internal_set_accepted(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.accepted_ = value;
}

// -------------------------------------------------------------------

// DisconnectNotice

// .dht.DisconnectMode disconnectMode = 1;
inline void DisconnectNotice::clear_disconnectmode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.disconnectmode_ = 0;
}
inline ::dht::DisconnectMode DisconnectNotice::disconnectmode() const {
  // @@protoc_insertion_point(field_get:dht.DisconnectNotice.disconnectMode)
  return _internal_disconnectmode();
}
inline void DisconnectNotice::set_disconnectmode(::dht::DisconnectMode value) {
  _internal_set_disconnectmode(value);
  // @@protoc_insertion_point(field_set:dht.DisconnectNotice.disconnectMode)
}
inline ::dht::DisconnectMode DisconnectNotice::_internal_disconnectmode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::dht::DisconnectMode>(_impl_.disconnectmode_);
}
inline void DisconnectNotice::_internal_set_disconnectmode(::dht::DisconnectMode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.disconnectmode_ = value;
}

// -------------------------------------------------------------------

// ExternalFetchDataRequest

// bytes key = 1;
inline void ExternalFetchDataRequest::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ExternalFetchDataRequest::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ExternalFetchDataRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExternalFetchDataRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dht.ExternalFetchDataRequest.key)
}
inline std::string* ExternalFetchDataRequest::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:dht.ExternalFetchDataRequest.key)
  return _s;
}
inline const std::string& ExternalFetchDataRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void ExternalFetchDataRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* ExternalFetchDataRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* ExternalFetchDataRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dht.ExternalFetchDataRequest.key)
  return _impl_.key_.Release();
}
inline void ExternalFetchDataRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dht.ExternalFetchDataRequest.key)
}

// -------------------------------------------------------------------

// ExternalFetchDataResponse

// repeated .dht.DataEntry entries = 1;
inline int ExternalFetchDataResponse::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int ExternalFetchDataResponse::entries_size() const {
  return _internal_entries_size();
}
inline void ExternalFetchDataResponse::clear_entries() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entries_.Clear();
}
inline ::dht::DataEntry* ExternalFetchDataResponse::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dht.ExternalFetchDataResponse.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dht::DataEntry>* ExternalFetchDataResponse::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dht.ExternalFetchDataResponse.entries)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_entries();
}
inline const ::dht::DataEntry& ExternalFetchDataResponse::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dht.ExternalFetchDataResponse.entries)
  return _internal_entries().Get(index);
}
inline ::dht::DataEntry* ExternalFetchDataResponse::add_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dht::DataEntry* _add = _internal_mutable_entries()->Add();
  // @@protoc_insertion_point(field_add:dht.ExternalFetchDataResponse.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dht::DataEntry>& ExternalFetchDataResponse::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dht.ExternalFetchDataResponse.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::dht::DataEntry>&
ExternalFetchDataResponse::_internal_entries() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::dht::DataEntry>*
ExternalFetchDataResponse::_internal_mutable_entries() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.entries_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace dht


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::dht::RecursiveOperation> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::dht::RecursiveOperation>() {
  return ::dht::RecursiveOperation_descriptor();
}
template <>
struct is_proto_enum<::dht::NodeType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::dht::NodeType>() {
  return ::dht::NodeType_descriptor();
}
template <>
struct is_proto_enum<::dht::RpcResponseError> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::dht::RpcResponseError>() {
  return ::dht::RpcResponseError_descriptor();
}
template <>
struct is_proto_enum<::dht::RouteMessageError> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::dht::RouteMessageError>() {
  return ::dht::RouteMessageError_descriptor();
}
template <>
struct is_proto_enum<::dht::HandshakeError> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::dht::HandshakeError>() {
  return ::dht::HandshakeError_descriptor();
}
template <>
struct is_proto_enum<::dht::DisconnectMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::dht::DisconnectMode>() {
  return ::dht::DisconnectMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_packages_2fdht_2fprotos_2fDhtRpc_2eproto_2epb_2eh
