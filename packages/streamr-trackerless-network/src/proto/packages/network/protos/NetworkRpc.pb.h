// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: packages/network/protos/NetworkRpc.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/empty.pb.h"
#include "google/protobuf/any.pb.h"
#include "packages/dht/protos/DhtRpc.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
class CloseTemporaryConnection;
struct CloseTemporaryConnectionDefaultTypeInternal;
extern CloseTemporaryConnectionDefaultTypeInternal _CloseTemporaryConnection_default_instance_;
class ContentMessage;
struct ContentMessageDefaultTypeInternal;
extern ContentMessageDefaultTypeInternal _ContentMessage_default_instance_;
class ControlLayerInfo;
struct ControlLayerInfoDefaultTypeInternal;
extern ControlLayerInfoDefaultTypeInternal _ControlLayerInfo_default_instance_;
class GroupKey;
struct GroupKeyDefaultTypeInternal;
extern GroupKeyDefaultTypeInternal _GroupKey_default_instance_;
class GroupKeyRequest;
struct GroupKeyRequestDefaultTypeInternal;
extern GroupKeyRequestDefaultTypeInternal _GroupKeyRequest_default_instance_;
class GroupKeyResponse;
struct GroupKeyResponseDefaultTypeInternal;
extern GroupKeyResponseDefaultTypeInternal _GroupKeyResponse_default_instance_;
class InterleaveRequest;
struct InterleaveRequestDefaultTypeInternal;
extern InterleaveRequestDefaultTypeInternal _InterleaveRequest_default_instance_;
class InterleaveResponse;
struct InterleaveResponseDefaultTypeInternal;
extern InterleaveResponseDefaultTypeInternal _InterleaveResponse_default_instance_;
class LeaveStreamPartNotice;
struct LeaveStreamPartNoticeDefaultTypeInternal;
extern LeaveStreamPartNoticeDefaultTypeInternal _LeaveStreamPartNotice_default_instance_;
class MessageID;
struct MessageIDDefaultTypeInternal;
extern MessageIDDefaultTypeInternal _MessageID_default_instance_;
class MessageRef;
struct MessageRefDefaultTypeInternal;
extern MessageRefDefaultTypeInternal _MessageRef_default_instance_;
class NeighborUpdate;
struct NeighborUpdateDefaultTypeInternal;
extern NeighborUpdateDefaultTypeInternal _NeighborUpdate_default_instance_;
class NodeInfoRequest;
struct NodeInfoRequestDefaultTypeInternal;
extern NodeInfoRequestDefaultTypeInternal _NodeInfoRequest_default_instance_;
class NodeInfoResponse;
struct NodeInfoResponseDefaultTypeInternal;
extern NodeInfoResponseDefaultTypeInternal _NodeInfoResponse_default_instance_;
class ProxyConnectionRequest;
struct ProxyConnectionRequestDefaultTypeInternal;
extern ProxyConnectionRequestDefaultTypeInternal _ProxyConnectionRequest_default_instance_;
class ProxyConnectionResponse;
struct ProxyConnectionResponseDefaultTypeInternal;
extern ProxyConnectionResponseDefaultTypeInternal _ProxyConnectionResponse_default_instance_;
class StreamMessage;
struct StreamMessageDefaultTypeInternal;
extern StreamMessageDefaultTypeInternal _StreamMessage_default_instance_;
class StreamPartHandshakeRequest;
struct StreamPartHandshakeRequestDefaultTypeInternal;
extern StreamPartHandshakeRequestDefaultTypeInternal _StreamPartHandshakeRequest_default_instance_;
class StreamPartHandshakeResponse;
struct StreamPartHandshakeResponseDefaultTypeInternal;
extern StreamPartHandshakeResponseDefaultTypeInternal _StreamPartHandshakeResponse_default_instance_;
class StreamPartitionInfo;
struct StreamPartitionInfoDefaultTypeInternal;
extern StreamPartitionInfoDefaultTypeInternal _StreamPartitionInfo_default_instance_;
class TemporaryConnectionRequest;
struct TemporaryConnectionRequestDefaultTypeInternal;
extern TemporaryConnectionRequestDefaultTypeInternal _TemporaryConnectionRequest_default_instance_;
class TemporaryConnectionResponse;
struct TemporaryConnectionResponseDefaultTypeInternal;
extern TemporaryConnectionResponseDefaultTypeInternal _TemporaryConnectionResponse_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

enum ContentType : int {
  JSON = 0,
  BINARY = 1,
  ContentType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ContentType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ContentType_IsValid(int value);
extern const uint32_t ContentType_internal_data_[];
constexpr ContentType ContentType_MIN = static_cast<ContentType>(0);
constexpr ContentType ContentType_MAX = static_cast<ContentType>(1);
constexpr int ContentType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
ContentType_descriptor();
template <typename T>
const std::string& ContentType_Name(T value) {
  static_assert(std::is_same<T, ContentType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ContentType_Name().");
  return ContentType_Name(static_cast<ContentType>(value));
}
template <>
inline const std::string& ContentType_Name(ContentType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ContentType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool ContentType_Parse(absl::string_view name, ContentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContentType>(
      ContentType_descriptor(), name, value);
}
enum EncryptionType : int {
  NONE = 0,
  AES = 1,
  EncryptionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EncryptionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EncryptionType_IsValid(int value);
extern const uint32_t EncryptionType_internal_data_[];
constexpr EncryptionType EncryptionType_MIN = static_cast<EncryptionType>(0);
constexpr EncryptionType EncryptionType_MAX = static_cast<EncryptionType>(1);
constexpr int EncryptionType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
EncryptionType_descriptor();
template <typename T>
const std::string& EncryptionType_Name(T value) {
  static_assert(std::is_same<T, EncryptionType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EncryptionType_Name().");
  return EncryptionType_Name(static_cast<EncryptionType>(value));
}
template <>
inline const std::string& EncryptionType_Name(EncryptionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EncryptionType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool EncryptionType_Parse(absl::string_view name, EncryptionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EncryptionType>(
      EncryptionType_descriptor(), name, value);
}
enum SignatureType : int {
  LEGACY_SECP256K1 = 0,
  SECP256K1 = 1,
  ERC_1271 = 2,
  SignatureType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SignatureType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SignatureType_IsValid(int value);
extern const uint32_t SignatureType_internal_data_[];
constexpr SignatureType SignatureType_MIN = static_cast<SignatureType>(0);
constexpr SignatureType SignatureType_MAX = static_cast<SignatureType>(2);
constexpr int SignatureType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SignatureType_descriptor();
template <typename T>
const std::string& SignatureType_Name(T value) {
  static_assert(std::is_same<T, SignatureType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SignatureType_Name().");
  return SignatureType_Name(static_cast<SignatureType>(value));
}
template <>
inline const std::string& SignatureType_Name(SignatureType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SignatureType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SignatureType_Parse(absl::string_view name, SignatureType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignatureType>(
      SignatureType_descriptor(), name, value);
}
enum ProxyDirection : int {
  PUBLISH = 0,
  SUBSCRIBE = 1,
  ProxyDirection_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ProxyDirection_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ProxyDirection_IsValid(int value);
extern const uint32_t ProxyDirection_internal_data_[];
constexpr ProxyDirection ProxyDirection_MIN = static_cast<ProxyDirection>(0);
constexpr ProxyDirection ProxyDirection_MAX = static_cast<ProxyDirection>(1);
constexpr int ProxyDirection_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
ProxyDirection_descriptor();
template <typename T>
const std::string& ProxyDirection_Name(T value) {
  static_assert(std::is_same<T, ProxyDirection>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ProxyDirection_Name().");
  return ProxyDirection_Name(static_cast<ProxyDirection>(value));
}
template <>
inline const std::string& ProxyDirection_Name(ProxyDirection value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ProxyDirection_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool ProxyDirection_Parse(absl::string_view name, ProxyDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProxyDirection>(
      ProxyDirection_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TemporaryConnectionResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TemporaryConnectionResponse) */ {
 public:
  inline TemporaryConnectionResponse() : TemporaryConnectionResponse(nullptr) {}
  ~TemporaryConnectionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TemporaryConnectionResponse(::google::protobuf::internal::ConstantInitialized);

  inline TemporaryConnectionResponse(const TemporaryConnectionResponse& from)
      : TemporaryConnectionResponse(nullptr, from) {}
  TemporaryConnectionResponse(TemporaryConnectionResponse&& from) noexcept
    : TemporaryConnectionResponse() {
    *this = ::std::move(from);
  }

  inline TemporaryConnectionResponse& operator=(const TemporaryConnectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TemporaryConnectionResponse& operator=(TemporaryConnectionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TemporaryConnectionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TemporaryConnectionResponse* internal_default_instance() {
    return reinterpret_cast<const TemporaryConnectionResponse*>(
               &_TemporaryConnectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TemporaryConnectionResponse& a, TemporaryConnectionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TemporaryConnectionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TemporaryConnectionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TemporaryConnectionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TemporaryConnectionResponse>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TemporaryConnectionResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "TemporaryConnectionResponse";
  }
  protected:
  explicit TemporaryConnectionResponse(::google::protobuf::Arena* arena);
  TemporaryConnectionResponse(::google::protobuf::Arena* arena, const TemporaryConnectionResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAcceptedFieldNumber = 1,
  };
  // bool accepted = 1;
  void clear_accepted() ;
  bool accepted() const;
  void set_accepted(bool value);

  private:
  bool _internal_accepted() const;
  void _internal_set_accepted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:TemporaryConnectionResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool accepted_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class TemporaryConnectionRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:TemporaryConnectionRequest) */ {
 public:
  inline TemporaryConnectionRequest() : TemporaryConnectionRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TemporaryConnectionRequest(::google::protobuf::internal::ConstantInitialized);

  inline TemporaryConnectionRequest(const TemporaryConnectionRequest& from)
      : TemporaryConnectionRequest(nullptr, from) {}
  TemporaryConnectionRequest(TemporaryConnectionRequest&& from) noexcept
    : TemporaryConnectionRequest() {
    *this = ::std::move(from);
  }

  inline TemporaryConnectionRequest& operator=(const TemporaryConnectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TemporaryConnectionRequest& operator=(TemporaryConnectionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TemporaryConnectionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TemporaryConnectionRequest* internal_default_instance() {
    return reinterpret_cast<const TemporaryConnectionRequest*>(
               &_TemporaryConnectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TemporaryConnectionRequest& a, TemporaryConnectionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TemporaryConnectionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TemporaryConnectionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TemporaryConnectionRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TemporaryConnectionRequest>(arena);
  }

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "TemporaryConnectionRequest";
  }
  protected:
  explicit TemporaryConnectionRequest(::google::protobuf::Arena* arena);
  TemporaryConnectionRequest(::google::protobuf::Arena* arena, const TemporaryConnectionRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TemporaryConnectionRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class StreamPartHandshakeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StreamPartHandshakeRequest) */ {
 public:
  inline StreamPartHandshakeRequest() : StreamPartHandshakeRequest(nullptr) {}
  ~StreamPartHandshakeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamPartHandshakeRequest(::google::protobuf::internal::ConstantInitialized);

  inline StreamPartHandshakeRequest(const StreamPartHandshakeRequest& from)
      : StreamPartHandshakeRequest(nullptr, from) {}
  StreamPartHandshakeRequest(StreamPartHandshakeRequest&& from) noexcept
    : StreamPartHandshakeRequest() {
    *this = ::std::move(from);
  }

  inline StreamPartHandshakeRequest& operator=(const StreamPartHandshakeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamPartHandshakeRequest& operator=(StreamPartHandshakeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamPartHandshakeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamPartHandshakeRequest* internal_default_instance() {
    return reinterpret_cast<const StreamPartHandshakeRequest*>(
               &_StreamPartHandshakeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StreamPartHandshakeRequest& a, StreamPartHandshakeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamPartHandshakeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamPartHandshakeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamPartHandshakeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamPartHandshakeRequest>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StreamPartHandshakeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "StreamPartHandshakeRequest";
  }
  protected:
  explicit StreamPartHandshakeRequest(::google::protobuf::Arena* arena);
  StreamPartHandshakeRequest(::google::protobuf::Arena* arena, const StreamPartHandshakeRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNeighborNodeIdsFieldNumber = 4,
    kStreamPartIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
    kConcurrentHandshakeNodeIdFieldNumber = 3,
    kInterleaveNodeIdFieldNumber = 5,
  };
  // repeated bytes neighborNodeIds = 4;
  int neighbornodeids_size() const;
  private:
  int _internal_neighbornodeids_size() const;

  public:
  void clear_neighbornodeids() ;
  const std::string& neighbornodeids(int index) const;
  std::string* mutable_neighbornodeids(int index);
  void set_neighbornodeids(int index, const std::string& value);
  void set_neighbornodeids(int index, std::string&& value);
  void set_neighbornodeids(int index, const char* value);
  void set_neighbornodeids(int index, const void* value, std::size_t size);
  void set_neighbornodeids(int index, absl::string_view value);
  std::string* add_neighbornodeids();
  void add_neighbornodeids(const std::string& value);
  void add_neighbornodeids(std::string&& value);
  void add_neighbornodeids(const char* value);
  void add_neighbornodeids(const void* value, std::size_t size);
  void add_neighbornodeids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& neighbornodeids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_neighbornodeids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_neighbornodeids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_neighbornodeids();

  public:
  // string streamPartId = 1;
  void clear_streampartid() ;
  const std::string& streampartid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_streampartid(Arg_&& arg, Args_... args);
  std::string* mutable_streampartid();
  PROTOBUF_NODISCARD std::string* release_streampartid();
  void set_allocated_streampartid(std::string* value);

  private:
  const std::string& _internal_streampartid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_streampartid(
      const std::string& value);
  std::string* _internal_mutable_streampartid();

  public:
  // string requestId = 2;
  void clear_requestid() ;
  const std::string& requestid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestid(Arg_&& arg, Args_... args);
  std::string* mutable_requestid();
  PROTOBUF_NODISCARD std::string* release_requestid();
  void set_allocated_requestid(std::string* value);

  private:
  const std::string& _internal_requestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestid(
      const std::string& value);
  std::string* _internal_mutable_requestid();

  public:
  // optional bytes concurrentHandshakeNodeId = 3;
  bool has_concurrenthandshakenodeid() const;
  void clear_concurrenthandshakenodeid() ;
  const std::string& concurrenthandshakenodeid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_concurrenthandshakenodeid(Arg_&& arg, Args_... args);
  std::string* mutable_concurrenthandshakenodeid();
  PROTOBUF_NODISCARD std::string* release_concurrenthandshakenodeid();
  void set_allocated_concurrenthandshakenodeid(std::string* value);

  private:
  const std::string& _internal_concurrenthandshakenodeid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_concurrenthandshakenodeid(
      const std::string& value);
  std::string* _internal_mutable_concurrenthandshakenodeid();

  public:
  // optional bytes interleaveNodeId = 5;
  bool has_interleavenodeid() const;
  void clear_interleavenodeid() ;
  const std::string& interleavenodeid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interleavenodeid(Arg_&& arg, Args_... args);
  std::string* mutable_interleavenodeid();
  PROTOBUF_NODISCARD std::string* release_interleavenodeid();
  void set_allocated_interleavenodeid(std::string* value);

  private:
  const std::string& _internal_interleavenodeid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interleavenodeid(
      const std::string& value);
  std::string* _internal_mutable_interleavenodeid();

  public:
  // @@protoc_insertion_point(class_scope:StreamPartHandshakeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> neighbornodeids_;
    ::google::protobuf::internal::ArenaStringPtr streampartid_;
    ::google::protobuf::internal::ArenaStringPtr requestid_;
    ::google::protobuf::internal::ArenaStringPtr concurrenthandshakenodeid_;
    ::google::protobuf::internal::ArenaStringPtr interleavenodeid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class ProxyConnectionResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProxyConnectionResponse) */ {
 public:
  inline ProxyConnectionResponse() : ProxyConnectionResponse(nullptr) {}
  ~ProxyConnectionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProxyConnectionResponse(::google::protobuf::internal::ConstantInitialized);

  inline ProxyConnectionResponse(const ProxyConnectionResponse& from)
      : ProxyConnectionResponse(nullptr, from) {}
  ProxyConnectionResponse(ProxyConnectionResponse&& from) noexcept
    : ProxyConnectionResponse() {
    *this = ::std::move(from);
  }

  inline ProxyConnectionResponse& operator=(const ProxyConnectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProxyConnectionResponse& operator=(ProxyConnectionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProxyConnectionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProxyConnectionResponse* internal_default_instance() {
    return reinterpret_cast<const ProxyConnectionResponse*>(
               &_ProxyConnectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ProxyConnectionResponse& a, ProxyConnectionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProxyConnectionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProxyConnectionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProxyConnectionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProxyConnectionResponse>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProxyConnectionResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ProxyConnectionResponse";
  }
  protected:
  explicit ProxyConnectionResponse(::google::protobuf::Arena* arena);
  ProxyConnectionResponse(::google::protobuf::Arena* arena, const ProxyConnectionResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAcceptedFieldNumber = 1,
  };
  // bool accepted = 1;
  void clear_accepted() ;
  bool accepted() const;
  void set_accepted(bool value);

  private:
  bool _internal_accepted() const;
  void _internal_set_accepted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:ProxyConnectionResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool accepted_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class ProxyConnectionRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProxyConnectionRequest) */ {
 public:
  inline ProxyConnectionRequest() : ProxyConnectionRequest(nullptr) {}
  ~ProxyConnectionRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProxyConnectionRequest(::google::protobuf::internal::ConstantInitialized);

  inline ProxyConnectionRequest(const ProxyConnectionRequest& from)
      : ProxyConnectionRequest(nullptr, from) {}
  ProxyConnectionRequest(ProxyConnectionRequest&& from) noexcept
    : ProxyConnectionRequest() {
    *this = ::std::move(from);
  }

  inline ProxyConnectionRequest& operator=(const ProxyConnectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProxyConnectionRequest& operator=(ProxyConnectionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProxyConnectionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProxyConnectionRequest* internal_default_instance() {
    return reinterpret_cast<const ProxyConnectionRequest*>(
               &_ProxyConnectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ProxyConnectionRequest& a, ProxyConnectionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProxyConnectionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProxyConnectionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProxyConnectionRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProxyConnectionRequest>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProxyConnectionRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ProxyConnectionRequest";
  }
  protected:
  explicit ProxyConnectionRequest(::google::protobuf::Arena* arena);
  ProxyConnectionRequest(::google::protobuf::Arena* arena, const ProxyConnectionRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 2,
    kDirectionFieldNumber = 1,
  };
  // bytes userId = 2;
  void clear_userid() ;
  const std::string& userid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_userid(Arg_&& arg, Args_... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* value);

  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(
      const std::string& value);
  std::string* _internal_mutable_userid();

  public:
  // .ProxyDirection direction = 1;
  void clear_direction() ;
  ::ProxyDirection direction() const;
  void set_direction(::ProxyDirection value);

  private:
  ::ProxyDirection _internal_direction() const;
  void _internal_set_direction(::ProxyDirection value);

  public:
  // @@protoc_insertion_point(class_scope:ProxyConnectionRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr userid_;
    int direction_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class NodeInfoRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:NodeInfoRequest) */ {
 public:
  inline NodeInfoRequest() : NodeInfoRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeInfoRequest(::google::protobuf::internal::ConstantInitialized);

  inline NodeInfoRequest(const NodeInfoRequest& from)
      : NodeInfoRequest(nullptr, from) {}
  NodeInfoRequest(NodeInfoRequest&& from) noexcept
    : NodeInfoRequest() {
    *this = ::std::move(from);
  }

  inline NodeInfoRequest& operator=(const NodeInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfoRequest& operator=(NodeInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfoRequest* internal_default_instance() {
    return reinterpret_cast<const NodeInfoRequest*>(
               &_NodeInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(NodeInfoRequest& a, NodeInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfoRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeInfoRequest>(arena);
  }

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NodeInfoRequest";
  }
  protected:
  explicit NodeInfoRequest(::google::protobuf::Arena* arena);
  NodeInfoRequest(::google::protobuf::Arena* arena, const NodeInfoRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NodeInfoRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class MessageRef final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MessageRef) */ {
 public:
  inline MessageRef() : MessageRef(nullptr) {}
  ~MessageRef() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MessageRef(::google::protobuf::internal::ConstantInitialized);

  inline MessageRef(const MessageRef& from)
      : MessageRef(nullptr, from) {}
  MessageRef(MessageRef&& from) noexcept
    : MessageRef() {
    *this = ::std::move(from);
  }

  inline MessageRef& operator=(const MessageRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageRef& operator=(MessageRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageRef* internal_default_instance() {
    return reinterpret_cast<const MessageRef*>(
               &_MessageRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MessageRef& a, MessageRef& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageRef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageRef* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageRef* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageRef>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MessageRef* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MessageRef";
  }
  protected:
  explicit MessageRef(::google::protobuf::Arena* arena);
  MessageRef(::google::protobuf::Arena* arena, const MessageRef& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kSequenceNumberFieldNumber = 2,
  };
  // int64 timestamp = 1;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // int32 sequenceNumber = 2;
  void clear_sequencenumber() ;
  ::int32_t sequencenumber() const;
  void set_sequencenumber(::int32_t value);

  private:
  ::int32_t _internal_sequencenumber() const;
  void _internal_set_sequencenumber(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MessageRef)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t timestamp_;
    ::int32_t sequencenumber_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class MessageID final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MessageID) */ {
 public:
  inline MessageID() : MessageID(nullptr) {}
  ~MessageID() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MessageID(::google::protobuf::internal::ConstantInitialized);

  inline MessageID(const MessageID& from)
      : MessageID(nullptr, from) {}
  MessageID(MessageID&& from) noexcept
    : MessageID() {
    *this = ::std::move(from);
  }

  inline MessageID& operator=(const MessageID& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageID& operator=(MessageID&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageID& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageID* internal_default_instance() {
    return reinterpret_cast<const MessageID*>(
               &_MessageID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MessageID& a, MessageID& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageID* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageID* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageID>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MessageID* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MessageID";
  }
  protected:
  explicit MessageID(::google::protobuf::Arena* arena);
  MessageID(::google::protobuf::Arena* arena, const MessageID& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamIdFieldNumber = 1,
    kPublisherIdFieldNumber = 5,
    kMessageChainIdFieldNumber = 6,
    kTimestampFieldNumber = 3,
    kStreamPartitionFieldNumber = 2,
    kSequenceNumberFieldNumber = 4,
  };
  // string streamId = 1;
  void clear_streamid() ;
  const std::string& streamid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_streamid(Arg_&& arg, Args_... args);
  std::string* mutable_streamid();
  PROTOBUF_NODISCARD std::string* release_streamid();
  void set_allocated_streamid(std::string* value);

  private:
  const std::string& _internal_streamid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_streamid(
      const std::string& value);
  std::string* _internal_mutable_streamid();

  public:
  // bytes publisherId = 5;
  void clear_publisherid() ;
  const std::string& publisherid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_publisherid(Arg_&& arg, Args_... args);
  std::string* mutable_publisherid();
  PROTOBUF_NODISCARD std::string* release_publisherid();
  void set_allocated_publisherid(std::string* value);

  private:
  const std::string& _internal_publisherid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publisherid(
      const std::string& value);
  std::string* _internal_mutable_publisherid();

  public:
  // string messageChainId = 6;
  void clear_messagechainid() ;
  const std::string& messagechainid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_messagechainid(Arg_&& arg, Args_... args);
  std::string* mutable_messagechainid();
  PROTOBUF_NODISCARD std::string* release_messagechainid();
  void set_allocated_messagechainid(std::string* value);

  private:
  const std::string& _internal_messagechainid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_messagechainid(
      const std::string& value);
  std::string* _internal_mutable_messagechainid();

  public:
  // int64 timestamp = 3;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // int32 streamPartition = 2;
  void clear_streampartition() ;
  ::int32_t streampartition() const;
  void set_streampartition(::int32_t value);

  private:
  ::int32_t _internal_streampartition() const;
  void _internal_set_streampartition(::int32_t value);

  public:
  // int32 sequenceNumber = 4;
  void clear_sequencenumber() ;
  ::int32_t sequencenumber() const;
  void set_sequencenumber(::int32_t value);

  private:
  ::int32_t _internal_sequencenumber() const;
  void _internal_set_sequencenumber(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MessageID)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr streamid_;
    ::google::protobuf::internal::ArenaStringPtr publisherid_;
    ::google::protobuf::internal::ArenaStringPtr messagechainid_;
    ::int64_t timestamp_;
    ::int32_t streampartition_;
    ::int32_t sequencenumber_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class LeaveStreamPartNotice final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LeaveStreamPartNotice) */ {
 public:
  inline LeaveStreamPartNotice() : LeaveStreamPartNotice(nullptr) {}
  ~LeaveStreamPartNotice() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LeaveStreamPartNotice(::google::protobuf::internal::ConstantInitialized);

  inline LeaveStreamPartNotice(const LeaveStreamPartNotice& from)
      : LeaveStreamPartNotice(nullptr, from) {}
  LeaveStreamPartNotice(LeaveStreamPartNotice&& from) noexcept
    : LeaveStreamPartNotice() {
    *this = ::std::move(from);
  }

  inline LeaveStreamPartNotice& operator=(const LeaveStreamPartNotice& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveStreamPartNotice& operator=(LeaveStreamPartNotice&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaveStreamPartNotice& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaveStreamPartNotice* internal_default_instance() {
    return reinterpret_cast<const LeaveStreamPartNotice*>(
               &_LeaveStreamPartNotice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LeaveStreamPartNotice& a, LeaveStreamPartNotice& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaveStreamPartNotice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveStreamPartNotice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaveStreamPartNotice* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaveStreamPartNotice>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LeaveStreamPartNotice* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "LeaveStreamPartNotice";
  }
  protected:
  explicit LeaveStreamPartNotice(::google::protobuf::Arena* arena);
  LeaveStreamPartNotice(::google::protobuf::Arena* arena, const LeaveStreamPartNotice& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamPartIdFieldNumber = 1,
    kIsEntryPointFieldNumber = 2,
  };
  // string streamPartId = 1;
  void clear_streampartid() ;
  const std::string& streampartid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_streampartid(Arg_&& arg, Args_... args);
  std::string* mutable_streampartid();
  PROTOBUF_NODISCARD std::string* release_streampartid();
  void set_allocated_streampartid(std::string* value);

  private:
  const std::string& _internal_streampartid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_streampartid(
      const std::string& value);
  std::string* _internal_mutable_streampartid();

  public:
  // bool isEntryPoint = 2;
  void clear_isentrypoint() ;
  bool isentrypoint() const;
  void set_isentrypoint(bool value);

  private:
  bool _internal_isentrypoint() const;
  void _internal_set_isentrypoint(bool value);

  public:
  // @@protoc_insertion_point(class_scope:LeaveStreamPartNotice)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr streampartid_;
    bool isentrypoint_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class InterleaveResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InterleaveResponse) */ {
 public:
  inline InterleaveResponse() : InterleaveResponse(nullptr) {}
  ~InterleaveResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InterleaveResponse(::google::protobuf::internal::ConstantInitialized);

  inline InterleaveResponse(const InterleaveResponse& from)
      : InterleaveResponse(nullptr, from) {}
  InterleaveResponse(InterleaveResponse&& from) noexcept
    : InterleaveResponse() {
    *this = ::std::move(from);
  }

  inline InterleaveResponse& operator=(const InterleaveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterleaveResponse& operator=(InterleaveResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterleaveResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterleaveResponse* internal_default_instance() {
    return reinterpret_cast<const InterleaveResponse*>(
               &_InterleaveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(InterleaveResponse& a, InterleaveResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InterleaveResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterleaveResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterleaveResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterleaveResponse>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InterleaveResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "InterleaveResponse";
  }
  protected:
  explicit InterleaveResponse(::google::protobuf::Arena* arena);
  InterleaveResponse(::google::protobuf::Arena* arena, const InterleaveResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAcceptedFieldNumber = 1,
  };
  // bool accepted = 1;
  void clear_accepted() ;
  bool accepted() const;
  void set_accepted(bool value);

  private:
  bool _internal_accepted() const;
  void _internal_set_accepted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:InterleaveResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool accepted_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class GroupKeyRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GroupKeyRequest) */ {
 public:
  inline GroupKeyRequest() : GroupKeyRequest(nullptr) {}
  ~GroupKeyRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GroupKeyRequest(::google::protobuf::internal::ConstantInitialized);

  inline GroupKeyRequest(const GroupKeyRequest& from)
      : GroupKeyRequest(nullptr, from) {}
  GroupKeyRequest(GroupKeyRequest&& from) noexcept
    : GroupKeyRequest() {
    *this = ::std::move(from);
  }

  inline GroupKeyRequest& operator=(const GroupKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupKeyRequest& operator=(GroupKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupKeyRequest* internal_default_instance() {
    return reinterpret_cast<const GroupKeyRequest*>(
               &_GroupKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GroupKeyRequest& a, GroupKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupKeyRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupKeyRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupKeyRequest>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GroupKeyRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "GroupKeyRequest";
  }
  protected:
  explicit GroupKeyRequest(::google::protobuf::Arena* arena);
  GroupKeyRequest(::google::protobuf::Arena* arena, const GroupKeyRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupKeyIdsFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kRecipientIdFieldNumber = 2,
    kRsaPublicKeyFieldNumber = 3,
  };
  // repeated string groupKeyIds = 4;
  int groupkeyids_size() const;
  private:
  int _internal_groupkeyids_size() const;

  public:
  void clear_groupkeyids() ;
  const std::string& groupkeyids(int index) const;
  std::string* mutable_groupkeyids(int index);
  void set_groupkeyids(int index, const std::string& value);
  void set_groupkeyids(int index, std::string&& value);
  void set_groupkeyids(int index, const char* value);
  void set_groupkeyids(int index, const char* value, std::size_t size);
  void set_groupkeyids(int index, absl::string_view value);
  std::string* add_groupkeyids();
  void add_groupkeyids(const std::string& value);
  void add_groupkeyids(std::string&& value);
  void add_groupkeyids(const char* value);
  void add_groupkeyids(const char* value, std::size_t size);
  void add_groupkeyids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& groupkeyids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_groupkeyids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_groupkeyids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_groupkeyids();

  public:
  // string requestId = 1;
  void clear_requestid() ;
  const std::string& requestid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestid(Arg_&& arg, Args_... args);
  std::string* mutable_requestid();
  PROTOBUF_NODISCARD std::string* release_requestid();
  void set_allocated_requestid(std::string* value);

  private:
  const std::string& _internal_requestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestid(
      const std::string& value);
  std::string* _internal_mutable_requestid();

  public:
  // bytes recipientId = 2;
  void clear_recipientid() ;
  const std::string& recipientid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recipientid(Arg_&& arg, Args_... args);
  std::string* mutable_recipientid();
  PROTOBUF_NODISCARD std::string* release_recipientid();
  void set_allocated_recipientid(std::string* value);

  private:
  const std::string& _internal_recipientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipientid(
      const std::string& value);
  std::string* _internal_mutable_recipientid();

  public:
  // bytes rsaPublicKey = 3;
  void clear_rsapublickey() ;
  const std::string& rsapublickey() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rsapublickey(Arg_&& arg, Args_... args);
  std::string* mutable_rsapublickey();
  PROTOBUF_NODISCARD std::string* release_rsapublickey();
  void set_allocated_rsapublickey(std::string* value);

  private:
  const std::string& _internal_rsapublickey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rsapublickey(
      const std::string& value);
  std::string* _internal_mutable_rsapublickey();

  public:
  // @@protoc_insertion_point(class_scope:GroupKeyRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> groupkeyids_;
    ::google::protobuf::internal::ArenaStringPtr requestid_;
    ::google::protobuf::internal::ArenaStringPtr recipientid_;
    ::google::protobuf::internal::ArenaStringPtr rsapublickey_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class GroupKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GroupKey) */ {
 public:
  inline GroupKey() : GroupKey(nullptr) {}
  ~GroupKey() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GroupKey(::google::protobuf::internal::ConstantInitialized);

  inline GroupKey(const GroupKey& from)
      : GroupKey(nullptr, from) {}
  GroupKey(GroupKey&& from) noexcept
    : GroupKey() {
    *this = ::std::move(from);
  }

  inline GroupKey& operator=(const GroupKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupKey& operator=(GroupKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupKey* internal_default_instance() {
    return reinterpret_cast<const GroupKey*>(
               &_GroupKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GroupKey& a, GroupKey& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupKey* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupKey>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GroupKey* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "GroupKey";
  }
  protected:
  explicit GroupKey(::google::protobuf::Arena* arena);
  GroupKey(::google::protobuf::Arena* arena, const GroupKey& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // bytes data = 2;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:GroupKey)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class CloseTemporaryConnection final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CloseTemporaryConnection) */ {
 public:
  inline CloseTemporaryConnection() : CloseTemporaryConnection(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CloseTemporaryConnection(::google::protobuf::internal::ConstantInitialized);

  inline CloseTemporaryConnection(const CloseTemporaryConnection& from)
      : CloseTemporaryConnection(nullptr, from) {}
  CloseTemporaryConnection(CloseTemporaryConnection&& from) noexcept
    : CloseTemporaryConnection() {
    *this = ::std::move(from);
  }

  inline CloseTemporaryConnection& operator=(const CloseTemporaryConnection& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseTemporaryConnection& operator=(CloseTemporaryConnection&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseTemporaryConnection& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseTemporaryConnection* internal_default_instance() {
    return reinterpret_cast<const CloseTemporaryConnection*>(
               &_CloseTemporaryConnection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CloseTemporaryConnection& a, CloseTemporaryConnection& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseTemporaryConnection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseTemporaryConnection* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseTemporaryConnection* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseTemporaryConnection>(arena);
  }

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CloseTemporaryConnection";
  }
  protected:
  explicit CloseTemporaryConnection(::google::protobuf::Arena* arena);
  CloseTemporaryConnection(::google::protobuf::Arena* arena, const CloseTemporaryConnection& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CloseTemporaryConnection)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class GroupKeyResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GroupKeyResponse) */ {
 public:
  inline GroupKeyResponse() : GroupKeyResponse(nullptr) {}
  ~GroupKeyResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GroupKeyResponse(::google::protobuf::internal::ConstantInitialized);

  inline GroupKeyResponse(const GroupKeyResponse& from)
      : GroupKeyResponse(nullptr, from) {}
  GroupKeyResponse(GroupKeyResponse&& from) noexcept
    : GroupKeyResponse() {
    *this = ::std::move(from);
  }

  inline GroupKeyResponse& operator=(const GroupKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupKeyResponse& operator=(GroupKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupKeyResponse* internal_default_instance() {
    return reinterpret_cast<const GroupKeyResponse*>(
               &_GroupKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GroupKeyResponse& a, GroupKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupKeyResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupKeyResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupKeyResponse>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GroupKeyResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "GroupKeyResponse";
  }
  protected:
  explicit GroupKeyResponse(::google::protobuf::Arena* arena);
  GroupKeyResponse(::google::protobuf::Arena* arena, const GroupKeyResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupKeysFieldNumber = 3,
    kRequestIdFieldNumber = 1,
    kRecipientIdFieldNumber = 2,
  };
  // repeated .GroupKey groupKeys = 3;
  int groupkeys_size() const;
  private:
  int _internal_groupkeys_size() const;

  public:
  void clear_groupkeys() ;
  ::GroupKey* mutable_groupkeys(int index);
  ::google::protobuf::RepeatedPtrField< ::GroupKey >*
      mutable_groupkeys();
  private:
  const ::google::protobuf::RepeatedPtrField<::GroupKey>& _internal_groupkeys() const;
  ::google::protobuf::RepeatedPtrField<::GroupKey>* _internal_mutable_groupkeys();
  public:
  const ::GroupKey& groupkeys(int index) const;
  ::GroupKey* add_groupkeys();
  const ::google::protobuf::RepeatedPtrField< ::GroupKey >&
      groupkeys() const;
  // string requestId = 1;
  void clear_requestid() ;
  const std::string& requestid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestid(Arg_&& arg, Args_... args);
  std::string* mutable_requestid();
  PROTOBUF_NODISCARD std::string* release_requestid();
  void set_allocated_requestid(std::string* value);

  private:
  const std::string& _internal_requestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestid(
      const std::string& value);
  std::string* _internal_mutable_requestid();

  public:
  // bytes recipientId = 2;
  void clear_recipientid() ;
  const std::string& recipientid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recipientid(Arg_&& arg, Args_... args);
  std::string* mutable_recipientid();
  PROTOBUF_NODISCARD std::string* release_recipientid();
  void set_allocated_recipientid(std::string* value);

  private:
  const std::string& _internal_recipientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipientid(
      const std::string& value);
  std::string* _internal_mutable_recipientid();

  public:
  // @@protoc_insertion_point(class_scope:GroupKeyResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::GroupKey > groupkeys_;
    ::google::protobuf::internal::ArenaStringPtr requestid_;
    ::google::protobuf::internal::ArenaStringPtr recipientid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class ContentMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ContentMessage) */ {
 public:
  inline ContentMessage() : ContentMessage(nullptr) {}
  ~ContentMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ContentMessage(::google::protobuf::internal::ConstantInitialized);

  inline ContentMessage(const ContentMessage& from)
      : ContentMessage(nullptr, from) {}
  ContentMessage(ContentMessage&& from) noexcept
    : ContentMessage() {
    *this = ::std::move(from);
  }

  inline ContentMessage& operator=(const ContentMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContentMessage& operator=(ContentMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContentMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContentMessage* internal_default_instance() {
    return reinterpret_cast<const ContentMessage*>(
               &_ContentMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ContentMessage& a, ContentMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ContentMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContentMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContentMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContentMessage>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ContentMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ContentMessage";
  }
  protected:
  explicit ContentMessage(::google::protobuf::Arena* arena);
  ContentMessage(::google::protobuf::Arena* arena, const ContentMessage& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
    kGroupKeyIdFieldNumber = 4,
    kNewGroupKeyFieldNumber = 5,
    kContentTypeFieldNumber = 2,
    kEncryptionTypeFieldNumber = 3,
  };
  // bytes content = 1;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* value);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // optional string groupKeyId = 4;
  bool has_groupkeyid() const;
  void clear_groupkeyid() ;
  const std::string& groupkeyid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_groupkeyid(Arg_&& arg, Args_... args);
  std::string* mutable_groupkeyid();
  PROTOBUF_NODISCARD std::string* release_groupkeyid();
  void set_allocated_groupkeyid(std::string* value);

  private:
  const std::string& _internal_groupkeyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupkeyid(
      const std::string& value);
  std::string* _internal_mutable_groupkeyid();

  public:
  // optional .GroupKey newGroupKey = 5;
  bool has_newgroupkey() const;
  void clear_newgroupkey() ;
  const ::GroupKey& newgroupkey() const;
  PROTOBUF_NODISCARD ::GroupKey* release_newgroupkey();
  ::GroupKey* mutable_newgroupkey();
  void set_allocated_newgroupkey(::GroupKey* value);
  void unsafe_arena_set_allocated_newgroupkey(::GroupKey* value);
  ::GroupKey* unsafe_arena_release_newgroupkey();

  private:
  const ::GroupKey& _internal_newgroupkey() const;
  ::GroupKey* _internal_mutable_newgroupkey();

  public:
  // .ContentType contentType = 2;
  void clear_contenttype() ;
  ::ContentType contenttype() const;
  void set_contenttype(::ContentType value);

  private:
  ::ContentType _internal_contenttype() const;
  void _internal_set_contenttype(::ContentType value);

  public:
  // .EncryptionType encryptionType = 3;
  void clear_encryptiontype() ;
  ::EncryptionType encryptiontype() const;
  void set_encryptiontype(::EncryptionType value);

  private:
  ::EncryptionType _internal_encryptiontype() const;
  void _internal_set_encryptiontype(::EncryptionType value);

  public:
  // @@protoc_insertion_point(class_scope:ContentMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr content_;
    ::google::protobuf::internal::ArenaStringPtr groupkeyid_;
    ::GroupKey* newgroupkey_;
    int contenttype_;
    int encryptiontype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class StreamPartitionInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StreamPartitionInfo) */ {
 public:
  inline StreamPartitionInfo() : StreamPartitionInfo(nullptr) {}
  ~StreamPartitionInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamPartitionInfo(::google::protobuf::internal::ConstantInitialized);

  inline StreamPartitionInfo(const StreamPartitionInfo& from)
      : StreamPartitionInfo(nullptr, from) {}
  StreamPartitionInfo(StreamPartitionInfo&& from) noexcept
    : StreamPartitionInfo() {
    *this = ::std::move(from);
  }

  inline StreamPartitionInfo& operator=(const StreamPartitionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamPartitionInfo& operator=(StreamPartitionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamPartitionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamPartitionInfo* internal_default_instance() {
    return reinterpret_cast<const StreamPartitionInfo*>(
               &_StreamPartitionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(StreamPartitionInfo& a, StreamPartitionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamPartitionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamPartitionInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamPartitionInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamPartitionInfo>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StreamPartitionInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "StreamPartitionInfo";
  }
  protected:
  explicit StreamPartitionInfo(::google::protobuf::Arena* arena);
  StreamPartitionInfo(::google::protobuf::Arena* arena, const StreamPartitionInfo& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlLayerNeighborsFieldNumber = 2,
    kContentDeliveryLayerNeighborsFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // repeated .dht.PeerDescriptor controlLayerNeighbors = 2;
  int controllayerneighbors_size() const;
  private:
  int _internal_controllayerneighbors_size() const;

  public:
  void clear_controllayerneighbors() ;
  ::dht::PeerDescriptor* mutable_controllayerneighbors(int index);
  ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >*
      mutable_controllayerneighbors();
  private:
  const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& _internal_controllayerneighbors() const;
  ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* _internal_mutable_controllayerneighbors();
  public:
  const ::dht::PeerDescriptor& controllayerneighbors(int index) const;
  ::dht::PeerDescriptor* add_controllayerneighbors();
  const ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >&
      controllayerneighbors() const;
  // repeated .dht.PeerDescriptor contentDeliveryLayerNeighbors = 3;
  int contentdeliverylayerneighbors_size() const;
  private:
  int _internal_contentdeliverylayerneighbors_size() const;

  public:
  void clear_contentdeliverylayerneighbors() ;
  ::dht::PeerDescriptor* mutable_contentdeliverylayerneighbors(int index);
  ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >*
      mutable_contentdeliverylayerneighbors();
  private:
  const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& _internal_contentdeliverylayerneighbors() const;
  ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* _internal_mutable_contentdeliverylayerneighbors();
  public:
  const ::dht::PeerDescriptor& contentdeliverylayerneighbors(int index) const;
  ::dht::PeerDescriptor* add_contentdeliverylayerneighbors();
  const ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >&
      contentdeliverylayerneighbors() const;
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:StreamPartitionInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor > controllayerneighbors_;
    ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor > contentdeliverylayerneighbors_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class StreamPartHandshakeResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StreamPartHandshakeResponse) */ {
 public:
  inline StreamPartHandshakeResponse() : StreamPartHandshakeResponse(nullptr) {}
  ~StreamPartHandshakeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamPartHandshakeResponse(::google::protobuf::internal::ConstantInitialized);

  inline StreamPartHandshakeResponse(const StreamPartHandshakeResponse& from)
      : StreamPartHandshakeResponse(nullptr, from) {}
  StreamPartHandshakeResponse(StreamPartHandshakeResponse&& from) noexcept
    : StreamPartHandshakeResponse() {
    *this = ::std::move(from);
  }

  inline StreamPartHandshakeResponse& operator=(const StreamPartHandshakeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamPartHandshakeResponse& operator=(StreamPartHandshakeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamPartHandshakeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamPartHandshakeResponse* internal_default_instance() {
    return reinterpret_cast<const StreamPartHandshakeResponse*>(
               &_StreamPartHandshakeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StreamPartHandshakeResponse& a, StreamPartHandshakeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamPartHandshakeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamPartHandshakeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamPartHandshakeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamPartHandshakeResponse>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StreamPartHandshakeResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "StreamPartHandshakeResponse";
  }
  protected:
  explicit StreamPartHandshakeResponse(::google::protobuf::Arena* arena);
  StreamPartHandshakeResponse(::google::protobuf::Arena* arena, const StreamPartHandshakeResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 2,
    kInterleaveTargetDescriptorFieldNumber = 3,
    kAcceptedFieldNumber = 1,
  };
  // string requestId = 2;
  void clear_requestid() ;
  const std::string& requestid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestid(Arg_&& arg, Args_... args);
  std::string* mutable_requestid();
  PROTOBUF_NODISCARD std::string* release_requestid();
  void set_allocated_requestid(std::string* value);

  private:
  const std::string& _internal_requestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestid(
      const std::string& value);
  std::string* _internal_mutable_requestid();

  public:
  // optional .dht.PeerDescriptor interleaveTargetDescriptor = 3;
  bool has_interleavetargetdescriptor() const;
  void clear_interleavetargetdescriptor() ;
  const ::dht::PeerDescriptor& interleavetargetdescriptor() const;
  PROTOBUF_NODISCARD ::dht::PeerDescriptor* release_interleavetargetdescriptor();
  ::dht::PeerDescriptor* mutable_interleavetargetdescriptor();
  void set_allocated_interleavetargetdescriptor(::dht::PeerDescriptor* value);
  void unsafe_arena_set_allocated_interleavetargetdescriptor(::dht::PeerDescriptor* value);
  ::dht::PeerDescriptor* unsafe_arena_release_interleavetargetdescriptor();

  private:
  const ::dht::PeerDescriptor& _internal_interleavetargetdescriptor() const;
  ::dht::PeerDescriptor* _internal_mutable_interleavetargetdescriptor();

  public:
  // bool accepted = 1;
  void clear_accepted() ;
  bool accepted() const;
  void set_accepted(bool value);

  private:
  bool _internal_accepted() const;
  void _internal_set_accepted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:StreamPartHandshakeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr requestid_;
    ::dht::PeerDescriptor* interleavetargetdescriptor_;
    bool accepted_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class StreamMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StreamMessage) */ {
 public:
  inline StreamMessage() : StreamMessage(nullptr) {}
  ~StreamMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamMessage(::google::protobuf::internal::ConstantInitialized);

  inline StreamMessage(const StreamMessage& from)
      : StreamMessage(nullptr, from) {}
  StreamMessage(StreamMessage&& from) noexcept
    : StreamMessage() {
    *this = ::std::move(from);
  }

  inline StreamMessage& operator=(const StreamMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamMessage& operator=(StreamMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamMessage& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kContentMessage = 5,
    kGroupKeyRequest = 6,
    kGroupKeyResponse = 7,
    BODY_NOT_SET = 0,
  };

  static inline const StreamMessage* internal_default_instance() {
    return reinterpret_cast<const StreamMessage*>(
               &_StreamMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StreamMessage& a, StreamMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamMessage>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StreamMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "StreamMessage";
  }
  protected:
  explicit StreamMessage(::google::protobuf::Arena* arena);
  StreamMessage(::google::protobuf::Arena* arena, const StreamMessage& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 3,
    kMessageIdFieldNumber = 1,
    kPreviousMessageRefFieldNumber = 2,
    kSignatureTypeFieldNumber = 4,
    kContentMessageFieldNumber = 5,
    kGroupKeyRequestFieldNumber = 6,
    kGroupKeyResponseFieldNumber = 7,
  };
  // bytes signature = 3;
  void clear_signature() ;
  const std::string& signature() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signature(Arg_&& arg, Args_... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* value);

  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(
      const std::string& value);
  std::string* _internal_mutable_signature();

  public:
  // .MessageID messageId = 1;
  bool has_messageid() const;
  void clear_messageid() ;
  const ::MessageID& messageid() const;
  PROTOBUF_NODISCARD ::MessageID* release_messageid();
  ::MessageID* mutable_messageid();
  void set_allocated_messageid(::MessageID* value);
  void unsafe_arena_set_allocated_messageid(::MessageID* value);
  ::MessageID* unsafe_arena_release_messageid();

  private:
  const ::MessageID& _internal_messageid() const;
  ::MessageID* _internal_mutable_messageid();

  public:
  // optional .MessageRef previousMessageRef = 2;
  bool has_previousmessageref() const;
  void clear_previousmessageref() ;
  const ::MessageRef& previousmessageref() const;
  PROTOBUF_NODISCARD ::MessageRef* release_previousmessageref();
  ::MessageRef* mutable_previousmessageref();
  void set_allocated_previousmessageref(::MessageRef* value);
  void unsafe_arena_set_allocated_previousmessageref(::MessageRef* value);
  ::MessageRef* unsafe_arena_release_previousmessageref();

  private:
  const ::MessageRef& _internal_previousmessageref() const;
  ::MessageRef* _internal_mutable_previousmessageref();

  public:
  // .SignatureType signatureType = 4;
  void clear_signaturetype() ;
  ::SignatureType signaturetype() const;
  void set_signaturetype(::SignatureType value);

  private:
  ::SignatureType _internal_signaturetype() const;
  void _internal_set_signaturetype(::SignatureType value);

  public:
  // .ContentMessage contentMessage = 5;
  bool has_contentmessage() const;
  private:
  bool _internal_has_contentmessage() const;

  public:
  void clear_contentmessage() ;
  const ::ContentMessage& contentmessage() const;
  PROTOBUF_NODISCARD ::ContentMessage* release_contentmessage();
  ::ContentMessage* mutable_contentmessage();
  void set_allocated_contentmessage(::ContentMessage* value);
  void unsafe_arena_set_allocated_contentmessage(::ContentMessage* value);
  ::ContentMessage* unsafe_arena_release_contentmessage();

  private:
  const ::ContentMessage& _internal_contentmessage() const;
  ::ContentMessage* _internal_mutable_contentmessage();

  public:
  // .GroupKeyRequest groupKeyRequest = 6;
  bool has_groupkeyrequest() const;
  private:
  bool _internal_has_groupkeyrequest() const;

  public:
  void clear_groupkeyrequest() ;
  const ::GroupKeyRequest& groupkeyrequest() const;
  PROTOBUF_NODISCARD ::GroupKeyRequest* release_groupkeyrequest();
  ::GroupKeyRequest* mutable_groupkeyrequest();
  void set_allocated_groupkeyrequest(::GroupKeyRequest* value);
  void unsafe_arena_set_allocated_groupkeyrequest(::GroupKeyRequest* value);
  ::GroupKeyRequest* unsafe_arena_release_groupkeyrequest();

  private:
  const ::GroupKeyRequest& _internal_groupkeyrequest() const;
  ::GroupKeyRequest* _internal_mutable_groupkeyrequest();

  public:
  // .GroupKeyResponse groupKeyResponse = 7;
  bool has_groupkeyresponse() const;
  private:
  bool _internal_has_groupkeyresponse() const;

  public:
  void clear_groupkeyresponse() ;
  const ::GroupKeyResponse& groupkeyresponse() const;
  PROTOBUF_NODISCARD ::GroupKeyResponse* release_groupkeyresponse();
  ::GroupKeyResponse* mutable_groupkeyresponse();
  void set_allocated_groupkeyresponse(::GroupKeyResponse* value);
  void unsafe_arena_set_allocated_groupkeyresponse(::GroupKeyResponse* value);
  ::GroupKeyResponse* unsafe_arena_release_groupkeyresponse();

  private:
  const ::GroupKeyResponse& _internal_groupkeyresponse() const;
  ::GroupKeyResponse* _internal_mutable_groupkeyresponse();

  public:
  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:StreamMessage)
 private:
  class _Internal;
  void set_has_contentmessage();
  void set_has_groupkeyrequest();
  void set_has_groupkeyresponse();

  inline bool has_body() const;
  inline void clear_has_body();

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr signature_;
    ::MessageID* messageid_;
    ::MessageRef* previousmessageref_;
    int signaturetype_;
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::ContentMessage* contentmessage_;
      ::GroupKeyRequest* groupkeyrequest_;
      ::GroupKeyResponse* groupkeyresponse_;
    } body_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class NeighborUpdate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NeighborUpdate) */ {
 public:
  inline NeighborUpdate() : NeighborUpdate(nullptr) {}
  ~NeighborUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NeighborUpdate(::google::protobuf::internal::ConstantInitialized);

  inline NeighborUpdate(const NeighborUpdate& from)
      : NeighborUpdate(nullptr, from) {}
  NeighborUpdate(NeighborUpdate&& from) noexcept
    : NeighborUpdate() {
    *this = ::std::move(from);
  }

  inline NeighborUpdate& operator=(const NeighborUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline NeighborUpdate& operator=(NeighborUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NeighborUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const NeighborUpdate* internal_default_instance() {
    return reinterpret_cast<const NeighborUpdate*>(
               &_NeighborUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(NeighborUpdate& a, NeighborUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(NeighborUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NeighborUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NeighborUpdate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NeighborUpdate>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NeighborUpdate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NeighborUpdate";
  }
  protected:
  explicit NeighborUpdate(::google::protobuf::Arena* arena);
  NeighborUpdate(::google::protobuf::Arena* arena, const NeighborUpdate& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNeighborDescriptorsFieldNumber = 3,
    kStreamPartIdFieldNumber = 1,
    kRemoveMeFieldNumber = 2,
  };
  // repeated .dht.PeerDescriptor neighborDescriptors = 3;
  int neighbordescriptors_size() const;
  private:
  int _internal_neighbordescriptors_size() const;

  public:
  void clear_neighbordescriptors() ;
  ::dht::PeerDescriptor* mutable_neighbordescriptors(int index);
  ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >*
      mutable_neighbordescriptors();
  private:
  const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& _internal_neighbordescriptors() const;
  ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* _internal_mutable_neighbordescriptors();
  public:
  const ::dht::PeerDescriptor& neighbordescriptors(int index) const;
  ::dht::PeerDescriptor* add_neighbordescriptors();
  const ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >&
      neighbordescriptors() const;
  // string streamPartId = 1;
  void clear_streampartid() ;
  const std::string& streampartid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_streampartid(Arg_&& arg, Args_... args);
  std::string* mutable_streampartid();
  PROTOBUF_NODISCARD std::string* release_streampartid();
  void set_allocated_streampartid(std::string* value);

  private:
  const std::string& _internal_streampartid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_streampartid(
      const std::string& value);
  std::string* _internal_mutable_streampartid();

  public:
  // bool removeMe = 2;
  void clear_removeme() ;
  bool removeme() const;
  void set_removeme(bool value);

  private:
  bool _internal_removeme() const;
  void _internal_set_removeme(bool value);

  public:
  // @@protoc_insertion_point(class_scope:NeighborUpdate)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor > neighbordescriptors_;
    ::google::protobuf::internal::ArenaStringPtr streampartid_;
    bool removeme_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class InterleaveRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InterleaveRequest) */ {
 public:
  inline InterleaveRequest() : InterleaveRequest(nullptr) {}
  ~InterleaveRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InterleaveRequest(::google::protobuf::internal::ConstantInitialized);

  inline InterleaveRequest(const InterleaveRequest& from)
      : InterleaveRequest(nullptr, from) {}
  InterleaveRequest(InterleaveRequest&& from) noexcept
    : InterleaveRequest() {
    *this = ::std::move(from);
  }

  inline InterleaveRequest& operator=(const InterleaveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterleaveRequest& operator=(InterleaveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterleaveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterleaveRequest* internal_default_instance() {
    return reinterpret_cast<const InterleaveRequest*>(
               &_InterleaveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(InterleaveRequest& a, InterleaveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InterleaveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterleaveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterleaveRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterleaveRequest>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InterleaveRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "InterleaveRequest";
  }
  protected:
  explicit InterleaveRequest(::google::protobuf::Arena* arena);
  InterleaveRequest(::google::protobuf::Arena* arena, const InterleaveRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInterleaveTargetDescriptorFieldNumber = 1,
  };
  // .dht.PeerDescriptor interleaveTargetDescriptor = 1;
  bool has_interleavetargetdescriptor() const;
  void clear_interleavetargetdescriptor() ;
  const ::dht::PeerDescriptor& interleavetargetdescriptor() const;
  PROTOBUF_NODISCARD ::dht::PeerDescriptor* release_interleavetargetdescriptor();
  ::dht::PeerDescriptor* mutable_interleavetargetdescriptor();
  void set_allocated_interleavetargetdescriptor(::dht::PeerDescriptor* value);
  void unsafe_arena_set_allocated_interleavetargetdescriptor(::dht::PeerDescriptor* value);
  ::dht::PeerDescriptor* unsafe_arena_release_interleavetargetdescriptor();

  private:
  const ::dht::PeerDescriptor& _internal_interleavetargetdescriptor() const;
  ::dht::PeerDescriptor* _internal_mutable_interleavetargetdescriptor();

  public:
  // @@protoc_insertion_point(class_scope:InterleaveRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::dht::PeerDescriptor* interleavetargetdescriptor_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class ControlLayerInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ControlLayerInfo) */ {
 public:
  inline ControlLayerInfo() : ControlLayerInfo(nullptr) {}
  ~ControlLayerInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControlLayerInfo(::google::protobuf::internal::ConstantInitialized);

  inline ControlLayerInfo(const ControlLayerInfo& from)
      : ControlLayerInfo(nullptr, from) {}
  ControlLayerInfo(ControlLayerInfo&& from) noexcept
    : ControlLayerInfo() {
    *this = ::std::move(from);
  }

  inline ControlLayerInfo& operator=(const ControlLayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlLayerInfo& operator=(ControlLayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlLayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlLayerInfo* internal_default_instance() {
    return reinterpret_cast<const ControlLayerInfo*>(
               &_ControlLayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ControlLayerInfo& a, ControlLayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlLayerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlLayerInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlLayerInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlLayerInfo>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ControlLayerInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ControlLayerInfo";
  }
  protected:
  explicit ControlLayerInfo(::google::protobuf::Arena* arena);
  ControlLayerInfo(::google::protobuf::Arena* arena, const ControlLayerInfo& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNeighborsFieldNumber = 1,
    kConnectionsFieldNumber = 2,
  };
  // repeated .dht.PeerDescriptor neighbors = 1;
  int neighbors_size() const;
  private:
  int _internal_neighbors_size() const;

  public:
  void clear_neighbors() ;
  ::dht::PeerDescriptor* mutable_neighbors(int index);
  ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >*
      mutable_neighbors();
  private:
  const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& _internal_neighbors() const;
  ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* _internal_mutable_neighbors();
  public:
  const ::dht::PeerDescriptor& neighbors(int index) const;
  ::dht::PeerDescriptor* add_neighbors();
  const ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >&
      neighbors() const;
  // repeated .dht.PeerDescriptor connections = 2;
  int connections_size() const;
  private:
  int _internal_connections_size() const;

  public:
  void clear_connections() ;
  ::dht::PeerDescriptor* mutable_connections(int index);
  ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >*
      mutable_connections();
  private:
  const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& _internal_connections() const;
  ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* _internal_mutable_connections();
  public:
  const ::dht::PeerDescriptor& connections(int index) const;
  ::dht::PeerDescriptor* add_connections();
  const ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor >&
      connections() const;
  // @@protoc_insertion_point(class_scope:ControlLayerInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor > neighbors_;
    ::google::protobuf::RepeatedPtrField< ::dht::PeerDescriptor > connections_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};// -------------------------------------------------------------------

class NodeInfoResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NodeInfoResponse) */ {
 public:
  inline NodeInfoResponse() : NodeInfoResponse(nullptr) {}
  ~NodeInfoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeInfoResponse(::google::protobuf::internal::ConstantInitialized);

  inline NodeInfoResponse(const NodeInfoResponse& from)
      : NodeInfoResponse(nullptr, from) {}
  NodeInfoResponse(NodeInfoResponse&& from) noexcept
    : NodeInfoResponse() {
    *this = ::std::move(from);
  }

  inline NodeInfoResponse& operator=(const NodeInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfoResponse& operator=(NodeInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfoResponse* internal_default_instance() {
    return reinterpret_cast<const NodeInfoResponse*>(
               &_NodeInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(NodeInfoResponse& a, NodeInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfoResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeInfoResponse>(arena);
  }
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeInfoResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NodeInfoResponse";
  }
  protected:
  explicit NodeInfoResponse(::google::protobuf::Arena* arena);
  NodeInfoResponse(::google::protobuf::Arena* arena, const NodeInfoResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamPartitionsFieldNumber = 2,
    kVersionFieldNumber = 4,
    kPeerDescriptorFieldNumber = 1,
    kControlLayerFieldNumber = 3,
  };
  // repeated .StreamPartitionInfo streamPartitions = 2;
  int streampartitions_size() const;
  private:
  int _internal_streampartitions_size() const;

  public:
  void clear_streampartitions() ;
  ::StreamPartitionInfo* mutable_streampartitions(int index);
  ::google::protobuf::RepeatedPtrField< ::StreamPartitionInfo >*
      mutable_streampartitions();
  private:
  const ::google::protobuf::RepeatedPtrField<::StreamPartitionInfo>& _internal_streampartitions() const;
  ::google::protobuf::RepeatedPtrField<::StreamPartitionInfo>* _internal_mutable_streampartitions();
  public:
  const ::StreamPartitionInfo& streampartitions(int index) const;
  ::StreamPartitionInfo* add_streampartitions();
  const ::google::protobuf::RepeatedPtrField< ::StreamPartitionInfo >&
      streampartitions() const;
  // string version = 4;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // .dht.PeerDescriptor peerDescriptor = 1;
  bool has_peerdescriptor() const;
  void clear_peerdescriptor() ;
  const ::dht::PeerDescriptor& peerdescriptor() const;
  PROTOBUF_NODISCARD ::dht::PeerDescriptor* release_peerdescriptor();
  ::dht::PeerDescriptor* mutable_peerdescriptor();
  void set_allocated_peerdescriptor(::dht::PeerDescriptor* value);
  void unsafe_arena_set_allocated_peerdescriptor(::dht::PeerDescriptor* value);
  ::dht::PeerDescriptor* unsafe_arena_release_peerdescriptor();

  private:
  const ::dht::PeerDescriptor& _internal_peerdescriptor() const;
  ::dht::PeerDescriptor* _internal_mutable_peerdescriptor();

  public:
  // optional .ControlLayerInfo controlLayer = 3;
  bool has_controllayer() const;
  void clear_controllayer() ;
  const ::ControlLayerInfo& controllayer() const;
  PROTOBUF_NODISCARD ::ControlLayerInfo* release_controllayer();
  ::ControlLayerInfo* mutable_controllayer();
  void set_allocated_controllayer(::ControlLayerInfo* value);
  void unsafe_arena_set_allocated_controllayer(::ControlLayerInfo* value);
  ::ControlLayerInfo* unsafe_arena_release_controllayer();

  private:
  const ::ControlLayerInfo& _internal_controllayer() const;
  ::ControlLayerInfo* _internal_mutable_controllayer();

  public:
  // @@protoc_insertion_point(class_scope:NodeInfoResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::StreamPartitionInfo > streampartitions_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::dht::PeerDescriptor* peerdescriptor_;
    ::ControlLayerInfo* controllayer_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MessageID

// string streamId = 1;
inline void MessageID::clear_streamid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.streamid_.ClearToEmpty();
}
inline const std::string& MessageID::streamid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MessageID.streamId)
  return _internal_streamid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageID::set_streamid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.streamid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MessageID.streamId)
}
inline std::string* MessageID::mutable_streamid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_streamid();
  // @@protoc_insertion_point(field_mutable:MessageID.streamId)
  return _s;
}
inline const std::string& MessageID::_internal_streamid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.streamid_.Get();
}
inline void MessageID::_internal_set_streamid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.streamid_.Set(value, GetArena());
}
inline std::string* MessageID::_internal_mutable_streamid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.streamid_.Mutable( GetArena());
}
inline std::string* MessageID::release_streamid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MessageID.streamId)
  return _impl_.streamid_.Release();
}
inline void MessageID::set_allocated_streamid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.streamid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.streamid_.IsDefault()) {
          _impl_.streamid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MessageID.streamId)
}

// int32 streamPartition = 2;
inline void MessageID::clear_streampartition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.streampartition_ = 0;
}
inline ::int32_t MessageID::streampartition() const {
  // @@protoc_insertion_point(field_get:MessageID.streamPartition)
  return _internal_streampartition();
}
inline void MessageID::set_streampartition(::int32_t value) {
  _internal_set_streampartition(value);
  // @@protoc_insertion_point(field_set:MessageID.streamPartition)
}
inline ::int32_t MessageID::_internal_streampartition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.streampartition_;
}
inline void MessageID::_internal_set_streampartition(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.streampartition_ = value;
}

// int64 timestamp = 3;
inline void MessageID::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t MessageID::timestamp() const {
  // @@protoc_insertion_point(field_get:MessageID.timestamp)
  return _internal_timestamp();
}
inline void MessageID::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:MessageID.timestamp)
}
inline ::int64_t MessageID::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void MessageID::_internal_set_timestamp(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// int32 sequenceNumber = 4;
inline void MessageID::clear_sequencenumber() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sequencenumber_ = 0;
}
inline ::int32_t MessageID::sequencenumber() const {
  // @@protoc_insertion_point(field_get:MessageID.sequenceNumber)
  return _internal_sequencenumber();
}
inline void MessageID::set_sequencenumber(::int32_t value) {
  _internal_set_sequencenumber(value);
  // @@protoc_insertion_point(field_set:MessageID.sequenceNumber)
}
inline ::int32_t MessageID::_internal_sequencenumber() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequencenumber_;
}
inline void MessageID::_internal_set_sequencenumber(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sequencenumber_ = value;
}

// bytes publisherId = 5;
inline void MessageID::clear_publisherid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.publisherid_.ClearToEmpty();
}
inline const std::string& MessageID::publisherid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MessageID.publisherId)
  return _internal_publisherid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageID::set_publisherid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.publisherid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MessageID.publisherId)
}
inline std::string* MessageID::mutable_publisherid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_publisherid();
  // @@protoc_insertion_point(field_mutable:MessageID.publisherId)
  return _s;
}
inline const std::string& MessageID::_internal_publisherid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.publisherid_.Get();
}
inline void MessageID::_internal_set_publisherid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.publisherid_.Set(value, GetArena());
}
inline std::string* MessageID::_internal_mutable_publisherid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.publisherid_.Mutable( GetArena());
}
inline std::string* MessageID::release_publisherid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MessageID.publisherId)
  return _impl_.publisherid_.Release();
}
inline void MessageID::set_allocated_publisherid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.publisherid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.publisherid_.IsDefault()) {
          _impl_.publisherid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MessageID.publisherId)
}

// string messageChainId = 6;
inline void MessageID::clear_messagechainid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.messagechainid_.ClearToEmpty();
}
inline const std::string& MessageID::messagechainid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MessageID.messageChainId)
  return _internal_messagechainid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageID::set_messagechainid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.messagechainid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MessageID.messageChainId)
}
inline std::string* MessageID::mutable_messagechainid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_messagechainid();
  // @@protoc_insertion_point(field_mutable:MessageID.messageChainId)
  return _s;
}
inline const std::string& MessageID::_internal_messagechainid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.messagechainid_.Get();
}
inline void MessageID::_internal_set_messagechainid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.messagechainid_.Set(value, GetArena());
}
inline std::string* MessageID::_internal_mutable_messagechainid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.messagechainid_.Mutable( GetArena());
}
inline std::string* MessageID::release_messagechainid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MessageID.messageChainId)
  return _impl_.messagechainid_.Release();
}
inline void MessageID::set_allocated_messagechainid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.messagechainid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.messagechainid_.IsDefault()) {
          _impl_.messagechainid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MessageID.messageChainId)
}

// -------------------------------------------------------------------

// MessageRef

// int64 timestamp = 1;
inline void MessageRef::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t MessageRef::timestamp() const {
  // @@protoc_insertion_point(field_get:MessageRef.timestamp)
  return _internal_timestamp();
}
inline void MessageRef::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:MessageRef.timestamp)
}
inline ::int64_t MessageRef::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void MessageRef::_internal_set_timestamp(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// int32 sequenceNumber = 2;
inline void MessageRef::clear_sequencenumber() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sequencenumber_ = 0;
}
inline ::int32_t MessageRef::sequencenumber() const {
  // @@protoc_insertion_point(field_get:MessageRef.sequenceNumber)
  return _internal_sequencenumber();
}
inline void MessageRef::set_sequencenumber(::int32_t value) {
  _internal_set_sequencenumber(value);
  // @@protoc_insertion_point(field_set:MessageRef.sequenceNumber)
}
inline ::int32_t MessageRef::_internal_sequencenumber() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequencenumber_;
}
inline void MessageRef::_internal_set_sequencenumber(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sequencenumber_ = value;
}

// -------------------------------------------------------------------

// StreamMessage

// .MessageID messageId = 1;
inline bool StreamMessage::has_messageid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.messageid_ != nullptr);
  return value;
}
inline void StreamMessage::clear_messageid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.messageid_ != nullptr) _impl_.messageid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MessageID& StreamMessage::_internal_messageid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::MessageID* p = _impl_.messageid_;
  return p != nullptr ? *p : reinterpret_cast<const ::MessageID&>(::_MessageID_default_instance_);
}
inline const ::MessageID& StreamMessage::messageid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:StreamMessage.messageId)
  return _internal_messageid();
}
inline void StreamMessage::unsafe_arena_set_allocated_messageid(::MessageID* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.messageid_);
  }
  _impl_.messageid_ = reinterpret_cast<::MessageID*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StreamMessage.messageId)
}
inline ::MessageID* StreamMessage::release_messageid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MessageID* released = _impl_.messageid_;
  _impl_.messageid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::MessageID* StreamMessage::unsafe_arena_release_messageid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:StreamMessage.messageId)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MessageID* temp = _impl_.messageid_;
  _impl_.messageid_ = nullptr;
  return temp;
}
inline ::MessageID* StreamMessage::_internal_mutable_messageid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.messageid_ == nullptr) {
    auto* p = CreateMaybeMessage<::MessageID>(GetArena());
    _impl_.messageid_ = reinterpret_cast<::MessageID*>(p);
  }
  return _impl_.messageid_;
}
inline ::MessageID* StreamMessage::mutable_messageid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::MessageID* _msg = _internal_mutable_messageid();
  // @@protoc_insertion_point(field_mutable:StreamMessage.messageId)
  return _msg;
}
inline void StreamMessage::set_allocated_messageid(::MessageID* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::MessageID*>(_impl_.messageid_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::MessageID*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.messageid_ = reinterpret_cast<::MessageID*>(value);
  // @@protoc_insertion_point(field_set_allocated:StreamMessage.messageId)
}

// optional .MessageRef previousMessageRef = 2;
inline bool StreamMessage::has_previousmessageref() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.previousmessageref_ != nullptr);
  return value;
}
inline void StreamMessage::clear_previousmessageref() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.previousmessageref_ != nullptr) _impl_.previousmessageref_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::MessageRef& StreamMessage::_internal_previousmessageref() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::MessageRef* p = _impl_.previousmessageref_;
  return p != nullptr ? *p : reinterpret_cast<const ::MessageRef&>(::_MessageRef_default_instance_);
}
inline const ::MessageRef& StreamMessage::previousmessageref() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:StreamMessage.previousMessageRef)
  return _internal_previousmessageref();
}
inline void StreamMessage::unsafe_arena_set_allocated_previousmessageref(::MessageRef* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.previousmessageref_);
  }
  _impl_.previousmessageref_ = reinterpret_cast<::MessageRef*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StreamMessage.previousMessageRef)
}
inline ::MessageRef* StreamMessage::release_previousmessageref() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::MessageRef* released = _impl_.previousmessageref_;
  _impl_.previousmessageref_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::MessageRef* StreamMessage::unsafe_arena_release_previousmessageref() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:StreamMessage.previousMessageRef)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::MessageRef* temp = _impl_.previousmessageref_;
  _impl_.previousmessageref_ = nullptr;
  return temp;
}
inline ::MessageRef* StreamMessage::_internal_mutable_previousmessageref() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.previousmessageref_ == nullptr) {
    auto* p = CreateMaybeMessage<::MessageRef>(GetArena());
    _impl_.previousmessageref_ = reinterpret_cast<::MessageRef*>(p);
  }
  return _impl_.previousmessageref_;
}
inline ::MessageRef* StreamMessage::mutable_previousmessageref() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::MessageRef* _msg = _internal_mutable_previousmessageref();
  // @@protoc_insertion_point(field_mutable:StreamMessage.previousMessageRef)
  return _msg;
}
inline void StreamMessage::set_allocated_previousmessageref(::MessageRef* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::MessageRef*>(_impl_.previousmessageref_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::MessageRef*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.previousmessageref_ = reinterpret_cast<::MessageRef*>(value);
  // @@protoc_insertion_point(field_set_allocated:StreamMessage.previousMessageRef)
}

// bytes signature = 3;
inline void StreamMessage::clear_signature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& StreamMessage::signature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:StreamMessage.signature)
  return _internal_signature();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamMessage::set_signature(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.signature_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:StreamMessage.signature)
}
inline std::string* StreamMessage::mutable_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:StreamMessage.signature)
  return _s;
}
inline const std::string& StreamMessage::_internal_signature() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.signature_.Get();
}
inline void StreamMessage::_internal_set_signature(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.signature_.Set(value, GetArena());
}
inline std::string* StreamMessage::_internal_mutable_signature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.signature_.Mutable( GetArena());
}
inline std::string* StreamMessage::release_signature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:StreamMessage.signature)
  return _impl_.signature_.Release();
}
inline void StreamMessage::set_allocated_signature(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.signature_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signature_.IsDefault()) {
          _impl_.signature_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StreamMessage.signature)
}

// .SignatureType signatureType = 4;
inline void StreamMessage::clear_signaturetype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.signaturetype_ = 0;
}
inline ::SignatureType StreamMessage::signaturetype() const {
  // @@protoc_insertion_point(field_get:StreamMessage.signatureType)
  return _internal_signaturetype();
}
inline void StreamMessage::set_signaturetype(::SignatureType value) {
  _internal_set_signaturetype(value);
  // @@protoc_insertion_point(field_set:StreamMessage.signatureType)
}
inline ::SignatureType StreamMessage::_internal_signaturetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SignatureType>(_impl_.signaturetype_);
}
inline void StreamMessage::_internal_set_signaturetype(::SignatureType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.signaturetype_ = value;
}

// .ContentMessage contentMessage = 5;
inline bool StreamMessage::has_contentmessage() const {
  return body_case() == kContentMessage;
}
inline bool StreamMessage::_internal_has_contentmessage() const {
  return body_case() == kContentMessage;
}
inline void StreamMessage::set_has_contentmessage() {
  _impl_._oneof_case_[0] = kContentMessage;
}
inline void StreamMessage::clear_contentmessage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (body_case() == kContentMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.contentmessage_;
    }
    clear_has_body();
  }
}
inline ::ContentMessage* StreamMessage::release_contentmessage() {
  // @@protoc_insertion_point(field_release:StreamMessage.contentMessage)
  if (body_case() == kContentMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.contentmessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.contentmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ContentMessage& StreamMessage::_internal_contentmessage() const {
  return body_case() == kContentMessage ? *_impl_.body_.contentmessage_ : reinterpret_cast<::ContentMessage&>(::_ContentMessage_default_instance_);
}
inline const ::ContentMessage& StreamMessage::contentmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:StreamMessage.contentMessage)
  return _internal_contentmessage();
}
inline ::ContentMessage* StreamMessage::unsafe_arena_release_contentmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:StreamMessage.contentMessage)
  if (body_case() == kContentMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.contentmessage_;
    _impl_.body_.contentmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamMessage::unsafe_arena_set_allocated_contentmessage(::ContentMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_contentmessage();
    _impl_.body_.contentmessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StreamMessage.contentMessage)
}
inline ::ContentMessage* StreamMessage::_internal_mutable_contentmessage() {
  if (body_case() != kContentMessage) {
    clear_body();
    set_has_contentmessage();
    _impl_.body_.contentmessage_ = CreateMaybeMessage<::ContentMessage>(GetArena());
  }
  return _impl_.body_.contentmessage_;
}
inline ::ContentMessage* StreamMessage::mutable_contentmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ContentMessage* _msg = _internal_mutable_contentmessage();
  // @@protoc_insertion_point(field_mutable:StreamMessage.contentMessage)
  return _msg;
}

// .GroupKeyRequest groupKeyRequest = 6;
inline bool StreamMessage::has_groupkeyrequest() const {
  return body_case() == kGroupKeyRequest;
}
inline bool StreamMessage::_internal_has_groupkeyrequest() const {
  return body_case() == kGroupKeyRequest;
}
inline void StreamMessage::set_has_groupkeyrequest() {
  _impl_._oneof_case_[0] = kGroupKeyRequest;
}
inline void StreamMessage::clear_groupkeyrequest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (body_case() == kGroupKeyRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.groupkeyrequest_;
    }
    clear_has_body();
  }
}
inline ::GroupKeyRequest* StreamMessage::release_groupkeyrequest() {
  // @@protoc_insertion_point(field_release:StreamMessage.groupKeyRequest)
  if (body_case() == kGroupKeyRequest) {
    clear_has_body();
    auto* temp = _impl_.body_.groupkeyrequest_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.groupkeyrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GroupKeyRequest& StreamMessage::_internal_groupkeyrequest() const {
  return body_case() == kGroupKeyRequest ? *_impl_.body_.groupkeyrequest_ : reinterpret_cast<::GroupKeyRequest&>(::_GroupKeyRequest_default_instance_);
}
inline const ::GroupKeyRequest& StreamMessage::groupkeyrequest() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:StreamMessage.groupKeyRequest)
  return _internal_groupkeyrequest();
}
inline ::GroupKeyRequest* StreamMessage::unsafe_arena_release_groupkeyrequest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:StreamMessage.groupKeyRequest)
  if (body_case() == kGroupKeyRequest) {
    clear_has_body();
    auto* temp = _impl_.body_.groupkeyrequest_;
    _impl_.body_.groupkeyrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamMessage::unsafe_arena_set_allocated_groupkeyrequest(::GroupKeyRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_groupkeyrequest();
    _impl_.body_.groupkeyrequest_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StreamMessage.groupKeyRequest)
}
inline ::GroupKeyRequest* StreamMessage::_internal_mutable_groupkeyrequest() {
  if (body_case() != kGroupKeyRequest) {
    clear_body();
    set_has_groupkeyrequest();
    _impl_.body_.groupkeyrequest_ = CreateMaybeMessage<::GroupKeyRequest>(GetArena());
  }
  return _impl_.body_.groupkeyrequest_;
}
inline ::GroupKeyRequest* StreamMessage::mutable_groupkeyrequest() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::GroupKeyRequest* _msg = _internal_mutable_groupkeyrequest();
  // @@protoc_insertion_point(field_mutable:StreamMessage.groupKeyRequest)
  return _msg;
}

// .GroupKeyResponse groupKeyResponse = 7;
inline bool StreamMessage::has_groupkeyresponse() const {
  return body_case() == kGroupKeyResponse;
}
inline bool StreamMessage::_internal_has_groupkeyresponse() const {
  return body_case() == kGroupKeyResponse;
}
inline void StreamMessage::set_has_groupkeyresponse() {
  _impl_._oneof_case_[0] = kGroupKeyResponse;
}
inline void StreamMessage::clear_groupkeyresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (body_case() == kGroupKeyResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.groupkeyresponse_;
    }
    clear_has_body();
  }
}
inline ::GroupKeyResponse* StreamMessage::release_groupkeyresponse() {
  // @@protoc_insertion_point(field_release:StreamMessage.groupKeyResponse)
  if (body_case() == kGroupKeyResponse) {
    clear_has_body();
    auto* temp = _impl_.body_.groupkeyresponse_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.groupkeyresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GroupKeyResponse& StreamMessage::_internal_groupkeyresponse() const {
  return body_case() == kGroupKeyResponse ? *_impl_.body_.groupkeyresponse_ : reinterpret_cast<::GroupKeyResponse&>(::_GroupKeyResponse_default_instance_);
}
inline const ::GroupKeyResponse& StreamMessage::groupkeyresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:StreamMessage.groupKeyResponse)
  return _internal_groupkeyresponse();
}
inline ::GroupKeyResponse* StreamMessage::unsafe_arena_release_groupkeyresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:StreamMessage.groupKeyResponse)
  if (body_case() == kGroupKeyResponse) {
    clear_has_body();
    auto* temp = _impl_.body_.groupkeyresponse_;
    _impl_.body_.groupkeyresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamMessage::unsafe_arena_set_allocated_groupkeyresponse(::GroupKeyResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_groupkeyresponse();
    _impl_.body_.groupkeyresponse_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StreamMessage.groupKeyResponse)
}
inline ::GroupKeyResponse* StreamMessage::_internal_mutable_groupkeyresponse() {
  if (body_case() != kGroupKeyResponse) {
    clear_body();
    set_has_groupkeyresponse();
    _impl_.body_.groupkeyresponse_ = CreateMaybeMessage<::GroupKeyResponse>(GetArena());
  }
  return _impl_.body_.groupkeyresponse_;
}
inline ::GroupKeyResponse* StreamMessage::mutable_groupkeyresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::GroupKeyResponse* _msg = _internal_mutable_groupkeyresponse();
  // @@protoc_insertion_point(field_mutable:StreamMessage.groupKeyResponse)
  return _msg;
}

inline bool StreamMessage::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void StreamMessage::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline StreamMessage::BodyCase StreamMessage::body_case() const {
  return StreamMessage::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ContentMessage

// bytes content = 1;
inline void ContentMessage::clear_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.ClearToEmpty();
}
inline const std::string& ContentMessage::content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ContentMessage.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContentMessage::set_content(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ContentMessage.content)
}
inline std::string* ContentMessage::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:ContentMessage.content)
  return _s;
}
inline const std::string& ContentMessage::_internal_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_.Get();
}
inline void ContentMessage::_internal_set_content(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(value, GetArena());
}
inline std::string* ContentMessage::_internal_mutable_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.content_.Mutable( GetArena());
}
inline std::string* ContentMessage::release_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ContentMessage.content)
  return _impl_.content_.Release();
}
inline void ContentMessage::set_allocated_content(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ContentMessage.content)
}

// .ContentType contentType = 2;
inline void ContentMessage::clear_contenttype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contenttype_ = 0;
}
inline ::ContentType ContentMessage::contenttype() const {
  // @@protoc_insertion_point(field_get:ContentMessage.contentType)
  return _internal_contenttype();
}
inline void ContentMessage::set_contenttype(::ContentType value) {
  _internal_set_contenttype(value);
  // @@protoc_insertion_point(field_set:ContentMessage.contentType)
}
inline ::ContentType ContentMessage::_internal_contenttype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ContentType>(_impl_.contenttype_);
}
inline void ContentMessage::_internal_set_contenttype(::ContentType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.contenttype_ = value;
}

// .EncryptionType encryptionType = 3;
inline void ContentMessage::clear_encryptiontype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.encryptiontype_ = 0;
}
inline ::EncryptionType ContentMessage::encryptiontype() const {
  // @@protoc_insertion_point(field_get:ContentMessage.encryptionType)
  return _internal_encryptiontype();
}
inline void ContentMessage::set_encryptiontype(::EncryptionType value) {
  _internal_set_encryptiontype(value);
  // @@protoc_insertion_point(field_set:ContentMessage.encryptionType)
}
inline ::EncryptionType ContentMessage::_internal_encryptiontype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::EncryptionType>(_impl_.encryptiontype_);
}
inline void ContentMessage::_internal_set_encryptiontype(::EncryptionType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.encryptiontype_ = value;
}

// optional string groupKeyId = 4;
inline bool ContentMessage::has_groupkeyid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ContentMessage::clear_groupkeyid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.groupkeyid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentMessage::groupkeyid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ContentMessage.groupKeyId)
  return _internal_groupkeyid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContentMessage::set_groupkeyid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.groupkeyid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ContentMessage.groupKeyId)
}
inline std::string* ContentMessage::mutable_groupkeyid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_groupkeyid();
  // @@protoc_insertion_point(field_mutable:ContentMessage.groupKeyId)
  return _s;
}
inline const std::string& ContentMessage::_internal_groupkeyid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.groupkeyid_.Get();
}
inline void ContentMessage::_internal_set_groupkeyid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.groupkeyid_.Set(value, GetArena());
}
inline std::string* ContentMessage::_internal_mutable_groupkeyid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.groupkeyid_.Mutable( GetArena());
}
inline std::string* ContentMessage::release_groupkeyid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ContentMessage.groupKeyId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.groupkeyid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.groupkeyid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ContentMessage::set_allocated_groupkeyid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.groupkeyid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.groupkeyid_.IsDefault()) {
          _impl_.groupkeyid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ContentMessage.groupKeyId)
}

// optional .GroupKey newGroupKey = 5;
inline bool ContentMessage::has_newgroupkey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.newgroupkey_ != nullptr);
  return value;
}
inline void ContentMessage::clear_newgroupkey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.newgroupkey_ != nullptr) _impl_.newgroupkey_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GroupKey& ContentMessage::_internal_newgroupkey() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GroupKey* p = _impl_.newgroupkey_;
  return p != nullptr ? *p : reinterpret_cast<const ::GroupKey&>(::_GroupKey_default_instance_);
}
inline const ::GroupKey& ContentMessage::newgroupkey() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ContentMessage.newGroupKey)
  return _internal_newgroupkey();
}
inline void ContentMessage::unsafe_arena_set_allocated_newgroupkey(::GroupKey* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.newgroupkey_);
  }
  _impl_.newgroupkey_ = reinterpret_cast<::GroupKey*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ContentMessage.newGroupKey)
}
inline ::GroupKey* ContentMessage::release_newgroupkey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GroupKey* released = _impl_.newgroupkey_;
  _impl_.newgroupkey_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GroupKey* ContentMessage::unsafe_arena_release_newgroupkey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ContentMessage.newGroupKey)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GroupKey* temp = _impl_.newgroupkey_;
  _impl_.newgroupkey_ = nullptr;
  return temp;
}
inline ::GroupKey* ContentMessage::_internal_mutable_newgroupkey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.newgroupkey_ == nullptr) {
    auto* p = CreateMaybeMessage<::GroupKey>(GetArena());
    _impl_.newgroupkey_ = reinterpret_cast<::GroupKey*>(p);
  }
  return _impl_.newgroupkey_;
}
inline ::GroupKey* ContentMessage::mutable_newgroupkey() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::GroupKey* _msg = _internal_mutable_newgroupkey();
  // @@protoc_insertion_point(field_mutable:ContentMessage.newGroupKey)
  return _msg;
}
inline void ContentMessage::set_allocated_newgroupkey(::GroupKey* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::GroupKey*>(_impl_.newgroupkey_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::GroupKey*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.newgroupkey_ = reinterpret_cast<::GroupKey*>(value);
  // @@protoc_insertion_point(field_set_allocated:ContentMessage.newGroupKey)
}

// -------------------------------------------------------------------

// GroupKeyRequest

// string requestId = 1;
inline void GroupKeyRequest::clear_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.ClearToEmpty();
}
inline const std::string& GroupKeyRequest::requestid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GroupKeyRequest.requestId)
  return _internal_requestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupKeyRequest::set_requestid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GroupKeyRequest.requestId)
}
inline std::string* GroupKeyRequest::mutable_requestid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_requestid();
  // @@protoc_insertion_point(field_mutable:GroupKeyRequest.requestId)
  return _s;
}
inline const std::string& GroupKeyRequest::_internal_requestid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestid_.Get();
}
inline void GroupKeyRequest::_internal_set_requestid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(value, GetArena());
}
inline std::string* GroupKeyRequest::_internal_mutable_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.requestid_.Mutable( GetArena());
}
inline std::string* GroupKeyRequest::release_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GroupKeyRequest.requestId)
  return _impl_.requestid_.Release();
}
inline void GroupKeyRequest::set_allocated_requestid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestid_.IsDefault()) {
          _impl_.requestid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GroupKeyRequest.requestId)
}

// bytes recipientId = 2;
inline void GroupKeyRequest::clear_recipientid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recipientid_.ClearToEmpty();
}
inline const std::string& GroupKeyRequest::recipientid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GroupKeyRequest.recipientId)
  return _internal_recipientid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupKeyRequest::set_recipientid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recipientid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GroupKeyRequest.recipientId)
}
inline std::string* GroupKeyRequest::mutable_recipientid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_recipientid();
  // @@protoc_insertion_point(field_mutable:GroupKeyRequest.recipientId)
  return _s;
}
inline const std::string& GroupKeyRequest::_internal_recipientid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.recipientid_.Get();
}
inline void GroupKeyRequest::_internal_set_recipientid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recipientid_.Set(value, GetArena());
}
inline std::string* GroupKeyRequest::_internal_mutable_recipientid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.recipientid_.Mutable( GetArena());
}
inline std::string* GroupKeyRequest::release_recipientid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GroupKeyRequest.recipientId)
  return _impl_.recipientid_.Release();
}
inline void GroupKeyRequest::set_allocated_recipientid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recipientid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.recipientid_.IsDefault()) {
          _impl_.recipientid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GroupKeyRequest.recipientId)
}

// bytes rsaPublicKey = 3;
inline void GroupKeyRequest::clear_rsapublickey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rsapublickey_.ClearToEmpty();
}
inline const std::string& GroupKeyRequest::rsapublickey() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GroupKeyRequest.rsaPublicKey)
  return _internal_rsapublickey();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupKeyRequest::set_rsapublickey(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rsapublickey_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GroupKeyRequest.rsaPublicKey)
}
inline std::string* GroupKeyRequest::mutable_rsapublickey() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_rsapublickey();
  // @@protoc_insertion_point(field_mutable:GroupKeyRequest.rsaPublicKey)
  return _s;
}
inline const std::string& GroupKeyRequest::_internal_rsapublickey() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rsapublickey_.Get();
}
inline void GroupKeyRequest::_internal_set_rsapublickey(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rsapublickey_.Set(value, GetArena());
}
inline std::string* GroupKeyRequest::_internal_mutable_rsapublickey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.rsapublickey_.Mutable( GetArena());
}
inline std::string* GroupKeyRequest::release_rsapublickey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GroupKeyRequest.rsaPublicKey)
  return _impl_.rsapublickey_.Release();
}
inline void GroupKeyRequest::set_allocated_rsapublickey(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rsapublickey_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rsapublickey_.IsDefault()) {
          _impl_.rsapublickey_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GroupKeyRequest.rsaPublicKey)
}

// repeated string groupKeyIds = 4;
inline int GroupKeyRequest::_internal_groupkeyids_size() const {
  return _internal_groupkeyids().size();
}
inline int GroupKeyRequest::groupkeyids_size() const {
  return _internal_groupkeyids_size();
}
inline void GroupKeyRequest::clear_groupkeyids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.groupkeyids_.Clear();
}
inline std::string* GroupKeyRequest::add_groupkeyids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_groupkeyids()->Add();
  // @@protoc_insertion_point(field_add_mutable:GroupKeyRequest.groupKeyIds)
  return _s;
}
inline const std::string& GroupKeyRequest::groupkeyids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GroupKeyRequest.groupKeyIds)
  return _internal_groupkeyids().Get(index);
}
inline std::string* GroupKeyRequest::mutable_groupkeyids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GroupKeyRequest.groupKeyIds)
  return _internal_mutable_groupkeyids()->Mutable(index);
}
inline void GroupKeyRequest::set_groupkeyids(int index, const std::string& value) {
  _internal_mutable_groupkeyids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:GroupKeyRequest.groupKeyIds)
}
inline void GroupKeyRequest::set_groupkeyids(int index, std::string&& value) {
  _internal_mutable_groupkeyids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:GroupKeyRequest.groupKeyIds)
}
inline void GroupKeyRequest::set_groupkeyids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_groupkeyids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:GroupKeyRequest.groupKeyIds)
}
inline void GroupKeyRequest::set_groupkeyids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_groupkeyids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GroupKeyRequest.groupKeyIds)
}
inline void GroupKeyRequest::set_groupkeyids(int index, absl::string_view value) {
  _internal_mutable_groupkeyids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:GroupKeyRequest.groupKeyIds)
}
inline void GroupKeyRequest::add_groupkeyids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_groupkeyids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:GroupKeyRequest.groupKeyIds)
}
inline void GroupKeyRequest::add_groupkeyids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_groupkeyids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:GroupKeyRequest.groupKeyIds)
}
inline void GroupKeyRequest::add_groupkeyids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_groupkeyids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:GroupKeyRequest.groupKeyIds)
}
inline void GroupKeyRequest::add_groupkeyids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_groupkeyids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:GroupKeyRequest.groupKeyIds)
}
inline void GroupKeyRequest::add_groupkeyids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_groupkeyids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:GroupKeyRequest.groupKeyIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GroupKeyRequest::groupkeyids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GroupKeyRequest.groupKeyIds)
  return _internal_groupkeyids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GroupKeyRequest::mutable_groupkeyids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GroupKeyRequest.groupKeyIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_groupkeyids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GroupKeyRequest::_internal_groupkeyids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.groupkeyids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GroupKeyRequest::_internal_mutable_groupkeyids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.groupkeyids_;
}

// -------------------------------------------------------------------

// GroupKeyResponse

// string requestId = 1;
inline void GroupKeyResponse::clear_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.ClearToEmpty();
}
inline const std::string& GroupKeyResponse::requestid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GroupKeyResponse.requestId)
  return _internal_requestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupKeyResponse::set_requestid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GroupKeyResponse.requestId)
}
inline std::string* GroupKeyResponse::mutable_requestid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_requestid();
  // @@protoc_insertion_point(field_mutable:GroupKeyResponse.requestId)
  return _s;
}
inline const std::string& GroupKeyResponse::_internal_requestid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestid_.Get();
}
inline void GroupKeyResponse::_internal_set_requestid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(value, GetArena());
}
inline std::string* GroupKeyResponse::_internal_mutable_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.requestid_.Mutable( GetArena());
}
inline std::string* GroupKeyResponse::release_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GroupKeyResponse.requestId)
  return _impl_.requestid_.Release();
}
inline void GroupKeyResponse::set_allocated_requestid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestid_.IsDefault()) {
          _impl_.requestid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GroupKeyResponse.requestId)
}

// bytes recipientId = 2;
inline void GroupKeyResponse::clear_recipientid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recipientid_.ClearToEmpty();
}
inline const std::string& GroupKeyResponse::recipientid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GroupKeyResponse.recipientId)
  return _internal_recipientid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupKeyResponse::set_recipientid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recipientid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GroupKeyResponse.recipientId)
}
inline std::string* GroupKeyResponse::mutable_recipientid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_recipientid();
  // @@protoc_insertion_point(field_mutable:GroupKeyResponse.recipientId)
  return _s;
}
inline const std::string& GroupKeyResponse::_internal_recipientid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.recipientid_.Get();
}
inline void GroupKeyResponse::_internal_set_recipientid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recipientid_.Set(value, GetArena());
}
inline std::string* GroupKeyResponse::_internal_mutable_recipientid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.recipientid_.Mutable( GetArena());
}
inline std::string* GroupKeyResponse::release_recipientid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GroupKeyResponse.recipientId)
  return _impl_.recipientid_.Release();
}
inline void GroupKeyResponse::set_allocated_recipientid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recipientid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.recipientid_.IsDefault()) {
          _impl_.recipientid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GroupKeyResponse.recipientId)
}

// repeated .GroupKey groupKeys = 3;
inline int GroupKeyResponse::_internal_groupkeys_size() const {
  return _internal_groupkeys().size();
}
inline int GroupKeyResponse::groupkeys_size() const {
  return _internal_groupkeys_size();
}
inline void GroupKeyResponse::clear_groupkeys() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.groupkeys_.Clear();
}
inline ::GroupKey* GroupKeyResponse::mutable_groupkeys(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GroupKeyResponse.groupKeys)
  return _internal_mutable_groupkeys()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GroupKey>* GroupKeyResponse::mutable_groupkeys()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GroupKeyResponse.groupKeys)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_groupkeys();
}
inline const ::GroupKey& GroupKeyResponse::groupkeys(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GroupKeyResponse.groupKeys)
  return _internal_groupkeys().Get(index);
}
inline ::GroupKey* GroupKeyResponse::add_groupkeys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GroupKey* _add = _internal_mutable_groupkeys()->Add();
  // @@protoc_insertion_point(field_add:GroupKeyResponse.groupKeys)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GroupKey>& GroupKeyResponse::groupkeys() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GroupKeyResponse.groupKeys)
  return _internal_groupkeys();
}
inline const ::google::protobuf::RepeatedPtrField<::GroupKey>&
GroupKeyResponse::_internal_groupkeys() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.groupkeys_;
}
inline ::google::protobuf::RepeatedPtrField<::GroupKey>*
GroupKeyResponse::_internal_mutable_groupkeys() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.groupkeys_;
}

// -------------------------------------------------------------------

// GroupKey

// string id = 1;
inline void GroupKey::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GroupKey::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GroupKey.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupKey::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GroupKey.id)
}
inline std::string* GroupKey::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:GroupKey.id)
  return _s;
}
inline const std::string& GroupKey::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void GroupKey::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* GroupKey::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* GroupKey::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GroupKey.id)
  return _impl_.id_.Release();
}
inline void GroupKey::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GroupKey.id)
}

// bytes data = 2;
inline void GroupKey::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& GroupKey::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GroupKey.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GroupKey::set_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GroupKey.data)
}
inline std::string* GroupKey::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:GroupKey.data)
  return _s;
}
inline const std::string& GroupKey::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_.Get();
}
inline void GroupKey::_internal_set_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_.Set(value, GetArena());
}
inline std::string* GroupKey::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* GroupKey::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GroupKey.data)
  return _impl_.data_.Release();
}
inline void GroupKey::set_allocated_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GroupKey.data)
}

// -------------------------------------------------------------------

// StreamPartHandshakeRequest

// string streamPartId = 1;
inline void StreamPartHandshakeRequest::clear_streampartid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.streampartid_.ClearToEmpty();
}
inline const std::string& StreamPartHandshakeRequest::streampartid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:StreamPartHandshakeRequest.streamPartId)
  return _internal_streampartid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamPartHandshakeRequest::set_streampartid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.streampartid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:StreamPartHandshakeRequest.streamPartId)
}
inline std::string* StreamPartHandshakeRequest::mutable_streampartid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_streampartid();
  // @@protoc_insertion_point(field_mutable:StreamPartHandshakeRequest.streamPartId)
  return _s;
}
inline const std::string& StreamPartHandshakeRequest::_internal_streampartid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.streampartid_.Get();
}
inline void StreamPartHandshakeRequest::_internal_set_streampartid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.streampartid_.Set(value, GetArena());
}
inline std::string* StreamPartHandshakeRequest::_internal_mutable_streampartid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.streampartid_.Mutable( GetArena());
}
inline std::string* StreamPartHandshakeRequest::release_streampartid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:StreamPartHandshakeRequest.streamPartId)
  return _impl_.streampartid_.Release();
}
inline void StreamPartHandshakeRequest::set_allocated_streampartid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.streampartid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.streampartid_.IsDefault()) {
          _impl_.streampartid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StreamPartHandshakeRequest.streamPartId)
}

// string requestId = 2;
inline void StreamPartHandshakeRequest::clear_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.ClearToEmpty();
}
inline const std::string& StreamPartHandshakeRequest::requestid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:StreamPartHandshakeRequest.requestId)
  return _internal_requestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamPartHandshakeRequest::set_requestid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:StreamPartHandshakeRequest.requestId)
}
inline std::string* StreamPartHandshakeRequest::mutable_requestid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_requestid();
  // @@protoc_insertion_point(field_mutable:StreamPartHandshakeRequest.requestId)
  return _s;
}
inline const std::string& StreamPartHandshakeRequest::_internal_requestid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestid_.Get();
}
inline void StreamPartHandshakeRequest::_internal_set_requestid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(value, GetArena());
}
inline std::string* StreamPartHandshakeRequest::_internal_mutable_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.requestid_.Mutable( GetArena());
}
inline std::string* StreamPartHandshakeRequest::release_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:StreamPartHandshakeRequest.requestId)
  return _impl_.requestid_.Release();
}
inline void StreamPartHandshakeRequest::set_allocated_requestid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestid_.IsDefault()) {
          _impl_.requestid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StreamPartHandshakeRequest.requestId)
}

// optional bytes concurrentHandshakeNodeId = 3;
inline bool StreamPartHandshakeRequest::has_concurrenthandshakenodeid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StreamPartHandshakeRequest::clear_concurrenthandshakenodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.concurrenthandshakenodeid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StreamPartHandshakeRequest::concurrenthandshakenodeid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:StreamPartHandshakeRequest.concurrentHandshakeNodeId)
  return _internal_concurrenthandshakenodeid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamPartHandshakeRequest::set_concurrenthandshakenodeid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.concurrenthandshakenodeid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:StreamPartHandshakeRequest.concurrentHandshakeNodeId)
}
inline std::string* StreamPartHandshakeRequest::mutable_concurrenthandshakenodeid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_concurrenthandshakenodeid();
  // @@protoc_insertion_point(field_mutable:StreamPartHandshakeRequest.concurrentHandshakeNodeId)
  return _s;
}
inline const std::string& StreamPartHandshakeRequest::_internal_concurrenthandshakenodeid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.concurrenthandshakenodeid_.Get();
}
inline void StreamPartHandshakeRequest::_internal_set_concurrenthandshakenodeid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.concurrenthandshakenodeid_.Set(value, GetArena());
}
inline std::string* StreamPartHandshakeRequest::_internal_mutable_concurrenthandshakenodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.concurrenthandshakenodeid_.Mutable( GetArena());
}
inline std::string* StreamPartHandshakeRequest::release_concurrenthandshakenodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:StreamPartHandshakeRequest.concurrentHandshakeNodeId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.concurrenthandshakenodeid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.concurrenthandshakenodeid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StreamPartHandshakeRequest::set_allocated_concurrenthandshakenodeid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.concurrenthandshakenodeid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.concurrenthandshakenodeid_.IsDefault()) {
          _impl_.concurrenthandshakenodeid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StreamPartHandshakeRequest.concurrentHandshakeNodeId)
}

// repeated bytes neighborNodeIds = 4;
inline int StreamPartHandshakeRequest::_internal_neighbornodeids_size() const {
  return _internal_neighbornodeids().size();
}
inline int StreamPartHandshakeRequest::neighbornodeids_size() const {
  return _internal_neighbornodeids_size();
}
inline void StreamPartHandshakeRequest::clear_neighbornodeids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.neighbornodeids_.Clear();
}
inline std::string* StreamPartHandshakeRequest::add_neighbornodeids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_neighbornodeids()->Add();
  // @@protoc_insertion_point(field_add_mutable:StreamPartHandshakeRequest.neighborNodeIds)
  return _s;
}
inline const std::string& StreamPartHandshakeRequest::neighbornodeids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:StreamPartHandshakeRequest.neighborNodeIds)
  return _internal_neighbornodeids().Get(index);
}
inline std::string* StreamPartHandshakeRequest::mutable_neighbornodeids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:StreamPartHandshakeRequest.neighborNodeIds)
  return _internal_mutable_neighbornodeids()->Mutable(index);
}
inline void StreamPartHandshakeRequest::set_neighbornodeids(int index, const std::string& value) {
  _internal_mutable_neighbornodeids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:StreamPartHandshakeRequest.neighborNodeIds)
}
inline void StreamPartHandshakeRequest::set_neighbornodeids(int index, std::string&& value) {
  _internal_mutable_neighbornodeids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:StreamPartHandshakeRequest.neighborNodeIds)
}
inline void StreamPartHandshakeRequest::set_neighbornodeids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_neighbornodeids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:StreamPartHandshakeRequest.neighborNodeIds)
}
inline void StreamPartHandshakeRequest::set_neighbornodeids(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_neighbornodeids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:StreamPartHandshakeRequest.neighborNodeIds)
}
inline void StreamPartHandshakeRequest::set_neighbornodeids(int index, absl::string_view value) {
  _internal_mutable_neighbornodeids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:StreamPartHandshakeRequest.neighborNodeIds)
}
inline void StreamPartHandshakeRequest::add_neighbornodeids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_neighbornodeids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:StreamPartHandshakeRequest.neighborNodeIds)
}
inline void StreamPartHandshakeRequest::add_neighbornodeids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_neighbornodeids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:StreamPartHandshakeRequest.neighborNodeIds)
}
inline void StreamPartHandshakeRequest::add_neighbornodeids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_neighbornodeids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:StreamPartHandshakeRequest.neighborNodeIds)
}
inline void StreamPartHandshakeRequest::add_neighbornodeids(const void* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_neighbornodeids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:StreamPartHandshakeRequest.neighborNodeIds)
}
inline void StreamPartHandshakeRequest::add_neighbornodeids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_neighbornodeids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:StreamPartHandshakeRequest.neighborNodeIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StreamPartHandshakeRequest::neighbornodeids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:StreamPartHandshakeRequest.neighborNodeIds)
  return _internal_neighbornodeids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StreamPartHandshakeRequest::mutable_neighbornodeids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:StreamPartHandshakeRequest.neighborNodeIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_neighbornodeids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StreamPartHandshakeRequest::_internal_neighbornodeids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.neighbornodeids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StreamPartHandshakeRequest::_internal_mutable_neighbornodeids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.neighbornodeids_;
}

// optional bytes interleaveNodeId = 5;
inline bool StreamPartHandshakeRequest::has_interleavenodeid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StreamPartHandshakeRequest::clear_interleavenodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interleavenodeid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StreamPartHandshakeRequest::interleavenodeid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:StreamPartHandshakeRequest.interleaveNodeId)
  return _internal_interleavenodeid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamPartHandshakeRequest::set_interleavenodeid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.interleavenodeid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:StreamPartHandshakeRequest.interleaveNodeId)
}
inline std::string* StreamPartHandshakeRequest::mutable_interleavenodeid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_interleavenodeid();
  // @@protoc_insertion_point(field_mutable:StreamPartHandshakeRequest.interleaveNodeId)
  return _s;
}
inline const std::string& StreamPartHandshakeRequest::_internal_interleavenodeid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interleavenodeid_.Get();
}
inline void StreamPartHandshakeRequest::_internal_set_interleavenodeid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.interleavenodeid_.Set(value, GetArena());
}
inline std::string* StreamPartHandshakeRequest::_internal_mutable_interleavenodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.interleavenodeid_.Mutable( GetArena());
}
inline std::string* StreamPartHandshakeRequest::release_interleavenodeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:StreamPartHandshakeRequest.interleaveNodeId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.interleavenodeid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.interleavenodeid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StreamPartHandshakeRequest::set_allocated_interleavenodeid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.interleavenodeid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.interleavenodeid_.IsDefault()) {
          _impl_.interleavenodeid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StreamPartHandshakeRequest.interleaveNodeId)
}

// -------------------------------------------------------------------

// StreamPartHandshakeResponse

// bool accepted = 1;
inline void StreamPartHandshakeResponse::clear_accepted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accepted_ = false;
}
inline bool StreamPartHandshakeResponse::accepted() const {
  // @@protoc_insertion_point(field_get:StreamPartHandshakeResponse.accepted)
  return _internal_accepted();
}
inline void StreamPartHandshakeResponse::set_accepted(bool value) {
  _internal_set_accepted(value);
  // @@protoc_insertion_point(field_set:StreamPartHandshakeResponse.accepted)
}
inline bool StreamPartHandshakeResponse::_internal_accepted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.accepted_;
}
inline void StreamPartHandshakeResponse::_internal_set_accepted(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.accepted_ = value;
}

// string requestId = 2;
inline void StreamPartHandshakeResponse::clear_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.ClearToEmpty();
}
inline const std::string& StreamPartHandshakeResponse::requestid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:StreamPartHandshakeResponse.requestId)
  return _internal_requestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamPartHandshakeResponse::set_requestid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:StreamPartHandshakeResponse.requestId)
}
inline std::string* StreamPartHandshakeResponse::mutable_requestid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_requestid();
  // @@protoc_insertion_point(field_mutable:StreamPartHandshakeResponse.requestId)
  return _s;
}
inline const std::string& StreamPartHandshakeResponse::_internal_requestid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestid_.Get();
}
inline void StreamPartHandshakeResponse::_internal_set_requestid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestid_.Set(value, GetArena());
}
inline std::string* StreamPartHandshakeResponse::_internal_mutable_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.requestid_.Mutable( GetArena());
}
inline std::string* StreamPartHandshakeResponse::release_requestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:StreamPartHandshakeResponse.requestId)
  return _impl_.requestid_.Release();
}
inline void StreamPartHandshakeResponse::set_allocated_requestid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestid_.IsDefault()) {
          _impl_.requestid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StreamPartHandshakeResponse.requestId)
}

// optional .dht.PeerDescriptor interleaveTargetDescriptor = 3;
inline bool StreamPartHandshakeResponse::has_interleavetargetdescriptor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.interleavetargetdescriptor_ != nullptr);
  return value;
}
inline const ::dht::PeerDescriptor& StreamPartHandshakeResponse::_internal_interleavetargetdescriptor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dht::PeerDescriptor* p = _impl_.interleavetargetdescriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::dht::PeerDescriptor&>(::dht::_PeerDescriptor_default_instance_);
}
inline const ::dht::PeerDescriptor& StreamPartHandshakeResponse::interleavetargetdescriptor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:StreamPartHandshakeResponse.interleaveTargetDescriptor)
  return _internal_interleavetargetdescriptor();
}
inline void StreamPartHandshakeResponse::unsafe_arena_set_allocated_interleavetargetdescriptor(::dht::PeerDescriptor* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.interleavetargetdescriptor_);
  }
  _impl_.interleavetargetdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StreamPartHandshakeResponse.interleaveTargetDescriptor)
}
inline ::dht::PeerDescriptor* StreamPartHandshakeResponse::release_interleavetargetdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dht::PeerDescriptor* released = _impl_.interleavetargetdescriptor_;
  _impl_.interleavetargetdescriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dht::PeerDescriptor* StreamPartHandshakeResponse::unsafe_arena_release_interleavetargetdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:StreamPartHandshakeResponse.interleaveTargetDescriptor)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dht::PeerDescriptor* temp = _impl_.interleavetargetdescriptor_;
  _impl_.interleavetargetdescriptor_ = nullptr;
  return temp;
}
inline ::dht::PeerDescriptor* StreamPartHandshakeResponse::_internal_mutable_interleavetargetdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.interleavetargetdescriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::dht::PeerDescriptor>(GetArena());
    _impl_.interleavetargetdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(p);
  }
  return _impl_.interleavetargetdescriptor_;
}
inline ::dht::PeerDescriptor* StreamPartHandshakeResponse::mutable_interleavetargetdescriptor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::PeerDescriptor* _msg = _internal_mutable_interleavetargetdescriptor();
  // @@protoc_insertion_point(field_mutable:StreamPartHandshakeResponse.interleaveTargetDescriptor)
  return _msg;
}
inline void StreamPartHandshakeResponse::set_allocated_interleavetargetdescriptor(::dht::PeerDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.interleavetargetdescriptor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.interleavetargetdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:StreamPartHandshakeResponse.interleaveTargetDescriptor)
}

// -------------------------------------------------------------------

// InterleaveRequest

// .dht.PeerDescriptor interleaveTargetDescriptor = 1;
inline bool InterleaveRequest::has_interleavetargetdescriptor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.interleavetargetdescriptor_ != nullptr);
  return value;
}
inline const ::dht::PeerDescriptor& InterleaveRequest::_internal_interleavetargetdescriptor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dht::PeerDescriptor* p = _impl_.interleavetargetdescriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::dht::PeerDescriptor&>(::dht::_PeerDescriptor_default_instance_);
}
inline const ::dht::PeerDescriptor& InterleaveRequest::interleavetargetdescriptor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InterleaveRequest.interleaveTargetDescriptor)
  return _internal_interleavetargetdescriptor();
}
inline void InterleaveRequest::unsafe_arena_set_allocated_interleavetargetdescriptor(::dht::PeerDescriptor* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.interleavetargetdescriptor_);
  }
  _impl_.interleavetargetdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InterleaveRequest.interleaveTargetDescriptor)
}
inline ::dht::PeerDescriptor* InterleaveRequest::release_interleavetargetdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dht::PeerDescriptor* released = _impl_.interleavetargetdescriptor_;
  _impl_.interleavetargetdescriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dht::PeerDescriptor* InterleaveRequest::unsafe_arena_release_interleavetargetdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:InterleaveRequest.interleaveTargetDescriptor)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dht::PeerDescriptor* temp = _impl_.interleavetargetdescriptor_;
  _impl_.interleavetargetdescriptor_ = nullptr;
  return temp;
}
inline ::dht::PeerDescriptor* InterleaveRequest::_internal_mutable_interleavetargetdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.interleavetargetdescriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::dht::PeerDescriptor>(GetArena());
    _impl_.interleavetargetdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(p);
  }
  return _impl_.interleavetargetdescriptor_;
}
inline ::dht::PeerDescriptor* InterleaveRequest::mutable_interleavetargetdescriptor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::PeerDescriptor* _msg = _internal_mutable_interleavetargetdescriptor();
  // @@protoc_insertion_point(field_mutable:InterleaveRequest.interleaveTargetDescriptor)
  return _msg;
}
inline void InterleaveRequest::set_allocated_interleavetargetdescriptor(::dht::PeerDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.interleavetargetdescriptor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.interleavetargetdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:InterleaveRequest.interleaveTargetDescriptor)
}

// -------------------------------------------------------------------

// InterleaveResponse

// bool accepted = 1;
inline void InterleaveResponse::clear_accepted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accepted_ = false;
}
inline bool InterleaveResponse::accepted() const {
  // @@protoc_insertion_point(field_get:InterleaveResponse.accepted)
  return _internal_accepted();
}
inline void InterleaveResponse::set_accepted(bool value) {
  _internal_set_accepted(value);
  // @@protoc_insertion_point(field_set:InterleaveResponse.accepted)
}
inline bool InterleaveResponse::_internal_accepted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.accepted_;
}
inline void InterleaveResponse::_internal_set_accepted(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.accepted_ = value;
}

// -------------------------------------------------------------------

// LeaveStreamPartNotice

// string streamPartId = 1;
inline void LeaveStreamPartNotice::clear_streampartid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.streampartid_.ClearToEmpty();
}
inline const std::string& LeaveStreamPartNotice::streampartid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:LeaveStreamPartNotice.streamPartId)
  return _internal_streampartid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LeaveStreamPartNotice::set_streampartid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.streampartid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:LeaveStreamPartNotice.streamPartId)
}
inline std::string* LeaveStreamPartNotice::mutable_streampartid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_streampartid();
  // @@protoc_insertion_point(field_mutable:LeaveStreamPartNotice.streamPartId)
  return _s;
}
inline const std::string& LeaveStreamPartNotice::_internal_streampartid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.streampartid_.Get();
}
inline void LeaveStreamPartNotice::_internal_set_streampartid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.streampartid_.Set(value, GetArena());
}
inline std::string* LeaveStreamPartNotice::_internal_mutable_streampartid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.streampartid_.Mutable( GetArena());
}
inline std::string* LeaveStreamPartNotice::release_streampartid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:LeaveStreamPartNotice.streamPartId)
  return _impl_.streampartid_.Release();
}
inline void LeaveStreamPartNotice::set_allocated_streampartid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.streampartid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.streampartid_.IsDefault()) {
          _impl_.streampartid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LeaveStreamPartNotice.streamPartId)
}

// bool isEntryPoint = 2;
inline void LeaveStreamPartNotice::clear_isentrypoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.isentrypoint_ = false;
}
inline bool LeaveStreamPartNotice::isentrypoint() const {
  // @@protoc_insertion_point(field_get:LeaveStreamPartNotice.isEntryPoint)
  return _internal_isentrypoint();
}
inline void LeaveStreamPartNotice::set_isentrypoint(bool value) {
  _internal_set_isentrypoint(value);
  // @@protoc_insertion_point(field_set:LeaveStreamPartNotice.isEntryPoint)
}
inline bool LeaveStreamPartNotice::_internal_isentrypoint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.isentrypoint_;
}
inline void LeaveStreamPartNotice::_internal_set_isentrypoint(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.isentrypoint_ = value;
}

// -------------------------------------------------------------------

// NeighborUpdate

// string streamPartId = 1;
inline void NeighborUpdate::clear_streampartid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.streampartid_.ClearToEmpty();
}
inline const std::string& NeighborUpdate::streampartid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NeighborUpdate.streamPartId)
  return _internal_streampartid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NeighborUpdate::set_streampartid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.streampartid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NeighborUpdate.streamPartId)
}
inline std::string* NeighborUpdate::mutable_streampartid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_streampartid();
  // @@protoc_insertion_point(field_mutable:NeighborUpdate.streamPartId)
  return _s;
}
inline const std::string& NeighborUpdate::_internal_streampartid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.streampartid_.Get();
}
inline void NeighborUpdate::_internal_set_streampartid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.streampartid_.Set(value, GetArena());
}
inline std::string* NeighborUpdate::_internal_mutable_streampartid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.streampartid_.Mutable( GetArena());
}
inline std::string* NeighborUpdate::release_streampartid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NeighborUpdate.streamPartId)
  return _impl_.streampartid_.Release();
}
inline void NeighborUpdate::set_allocated_streampartid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.streampartid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.streampartid_.IsDefault()) {
          _impl_.streampartid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NeighborUpdate.streamPartId)
}

// bool removeMe = 2;
inline void NeighborUpdate::clear_removeme() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.removeme_ = false;
}
inline bool NeighborUpdate::removeme() const {
  // @@protoc_insertion_point(field_get:NeighborUpdate.removeMe)
  return _internal_removeme();
}
inline void NeighborUpdate::set_removeme(bool value) {
  _internal_set_removeme(value);
  // @@protoc_insertion_point(field_set:NeighborUpdate.removeMe)
}
inline bool NeighborUpdate::_internal_removeme() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.removeme_;
}
inline void NeighborUpdate::_internal_set_removeme(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.removeme_ = value;
}

// repeated .dht.PeerDescriptor neighborDescriptors = 3;
inline int NeighborUpdate::_internal_neighbordescriptors_size() const {
  return _internal_neighbordescriptors().size();
}
inline int NeighborUpdate::neighbordescriptors_size() const {
  return _internal_neighbordescriptors_size();
}
inline ::dht::PeerDescriptor* NeighborUpdate::mutable_neighbordescriptors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:NeighborUpdate.neighborDescriptors)
  return _internal_mutable_neighbordescriptors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* NeighborUpdate::mutable_neighbordescriptors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NeighborUpdate.neighborDescriptors)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_neighbordescriptors();
}
inline const ::dht::PeerDescriptor& NeighborUpdate::neighbordescriptors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NeighborUpdate.neighborDescriptors)
  return _internal_neighbordescriptors().Get(index);
}
inline ::dht::PeerDescriptor* NeighborUpdate::add_neighbordescriptors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dht::PeerDescriptor* _add = _internal_mutable_neighbordescriptors()->Add();
  // @@protoc_insertion_point(field_add:NeighborUpdate.neighborDescriptors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& NeighborUpdate::neighbordescriptors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NeighborUpdate.neighborDescriptors)
  return _internal_neighbordescriptors();
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>&
NeighborUpdate::_internal_neighbordescriptors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.neighbordescriptors_;
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>*
NeighborUpdate::_internal_mutable_neighbordescriptors() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.neighbordescriptors_;
}

// -------------------------------------------------------------------

// ProxyConnectionRequest

// .ProxyDirection direction = 1;
inline void ProxyConnectionRequest::clear_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.direction_ = 0;
}
inline ::ProxyDirection ProxyConnectionRequest::direction() const {
  // @@protoc_insertion_point(field_get:ProxyConnectionRequest.direction)
  return _internal_direction();
}
inline void ProxyConnectionRequest::set_direction(::ProxyDirection value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:ProxyConnectionRequest.direction)
}
inline ::ProxyDirection ProxyConnectionRequest::_internal_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ProxyDirection>(_impl_.direction_);
}
inline void ProxyConnectionRequest::_internal_set_direction(::ProxyDirection value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.direction_ = value;
}

// bytes userId = 2;
inline void ProxyConnectionRequest::clear_userid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& ProxyConnectionRequest::userid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ProxyConnectionRequest.userId)
  return _internal_userid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProxyConnectionRequest::set_userid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.userid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ProxyConnectionRequest.userId)
}
inline std::string* ProxyConnectionRequest::mutable_userid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:ProxyConnectionRequest.userId)
  return _s;
}
inline const std::string& ProxyConnectionRequest::_internal_userid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.userid_.Get();
}
inline void ProxyConnectionRequest::_internal_set_userid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.userid_.Set(value, GetArena());
}
inline std::string* ProxyConnectionRequest::_internal_mutable_userid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.userid_.Mutable( GetArena());
}
inline std::string* ProxyConnectionRequest::release_userid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProxyConnectionRequest.userId)
  return _impl_.userid_.Release();
}
inline void ProxyConnectionRequest::set_allocated_userid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.userid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.userid_.IsDefault()) {
          _impl_.userid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProxyConnectionRequest.userId)
}

// -------------------------------------------------------------------

// ProxyConnectionResponse

// bool accepted = 1;
inline void ProxyConnectionResponse::clear_accepted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accepted_ = false;
}
inline bool ProxyConnectionResponse::accepted() const {
  // @@protoc_insertion_point(field_get:ProxyConnectionResponse.accepted)
  return _internal_accepted();
}
inline void ProxyConnectionResponse::set_accepted(bool value) {
  _internal_set_accepted(value);
  // @@protoc_insertion_point(field_set:ProxyConnectionResponse.accepted)
}
inline bool ProxyConnectionResponse::_internal_accepted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.accepted_;
}
inline void ProxyConnectionResponse::_internal_set_accepted(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.accepted_ = value;
}

// -------------------------------------------------------------------

// TemporaryConnectionRequest

// -------------------------------------------------------------------

// TemporaryConnectionResponse

// bool accepted = 1;
inline void TemporaryConnectionResponse::clear_accepted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accepted_ = false;
}
inline bool TemporaryConnectionResponse::accepted() const {
  // @@protoc_insertion_point(field_get:TemporaryConnectionResponse.accepted)
  return _internal_accepted();
}
inline void TemporaryConnectionResponse::set_accepted(bool value) {
  _internal_set_accepted(value);
  // @@protoc_insertion_point(field_set:TemporaryConnectionResponse.accepted)
}
inline bool TemporaryConnectionResponse::_internal_accepted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.accepted_;
}
inline void TemporaryConnectionResponse::_internal_set_accepted(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.accepted_ = value;
}

// -------------------------------------------------------------------

// CloseTemporaryConnection

// -------------------------------------------------------------------

// StreamPartitionInfo

// string id = 1;
inline void StreamPartitionInfo::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& StreamPartitionInfo::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:StreamPartitionInfo.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamPartitionInfo::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:StreamPartitionInfo.id)
}
inline std::string* StreamPartitionInfo::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:StreamPartitionInfo.id)
  return _s;
}
inline const std::string& StreamPartitionInfo::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void StreamPartitionInfo::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* StreamPartitionInfo::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* StreamPartitionInfo::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:StreamPartitionInfo.id)
  return _impl_.id_.Release();
}
inline void StreamPartitionInfo::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StreamPartitionInfo.id)
}

// repeated .dht.PeerDescriptor controlLayerNeighbors = 2;
inline int StreamPartitionInfo::_internal_controllayerneighbors_size() const {
  return _internal_controllayerneighbors().size();
}
inline int StreamPartitionInfo::controllayerneighbors_size() const {
  return _internal_controllayerneighbors_size();
}
inline ::dht::PeerDescriptor* StreamPartitionInfo::mutable_controllayerneighbors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:StreamPartitionInfo.controlLayerNeighbors)
  return _internal_mutable_controllayerneighbors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* StreamPartitionInfo::mutable_controllayerneighbors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:StreamPartitionInfo.controlLayerNeighbors)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_controllayerneighbors();
}
inline const ::dht::PeerDescriptor& StreamPartitionInfo::controllayerneighbors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:StreamPartitionInfo.controlLayerNeighbors)
  return _internal_controllayerneighbors().Get(index);
}
inline ::dht::PeerDescriptor* StreamPartitionInfo::add_controllayerneighbors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dht::PeerDescriptor* _add = _internal_mutable_controllayerneighbors()->Add();
  // @@protoc_insertion_point(field_add:StreamPartitionInfo.controlLayerNeighbors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& StreamPartitionInfo::controllayerneighbors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:StreamPartitionInfo.controlLayerNeighbors)
  return _internal_controllayerneighbors();
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>&
StreamPartitionInfo::_internal_controllayerneighbors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.controllayerneighbors_;
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>*
StreamPartitionInfo::_internal_mutable_controllayerneighbors() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.controllayerneighbors_;
}

// repeated .dht.PeerDescriptor contentDeliveryLayerNeighbors = 3;
inline int StreamPartitionInfo::_internal_contentdeliverylayerneighbors_size() const {
  return _internal_contentdeliverylayerneighbors().size();
}
inline int StreamPartitionInfo::contentdeliverylayerneighbors_size() const {
  return _internal_contentdeliverylayerneighbors_size();
}
inline ::dht::PeerDescriptor* StreamPartitionInfo::mutable_contentdeliverylayerneighbors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:StreamPartitionInfo.contentDeliveryLayerNeighbors)
  return _internal_mutable_contentdeliverylayerneighbors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* StreamPartitionInfo::mutable_contentdeliverylayerneighbors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:StreamPartitionInfo.contentDeliveryLayerNeighbors)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_contentdeliverylayerneighbors();
}
inline const ::dht::PeerDescriptor& StreamPartitionInfo::contentdeliverylayerneighbors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:StreamPartitionInfo.contentDeliveryLayerNeighbors)
  return _internal_contentdeliverylayerneighbors().Get(index);
}
inline ::dht::PeerDescriptor* StreamPartitionInfo::add_contentdeliverylayerneighbors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dht::PeerDescriptor* _add = _internal_mutable_contentdeliverylayerneighbors()->Add();
  // @@protoc_insertion_point(field_add:StreamPartitionInfo.contentDeliveryLayerNeighbors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& StreamPartitionInfo::contentdeliverylayerneighbors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:StreamPartitionInfo.contentDeliveryLayerNeighbors)
  return _internal_contentdeliverylayerneighbors();
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>&
StreamPartitionInfo::_internal_contentdeliverylayerneighbors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.contentdeliverylayerneighbors_;
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>*
StreamPartitionInfo::_internal_mutable_contentdeliverylayerneighbors() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.contentdeliverylayerneighbors_;
}

// -------------------------------------------------------------------

// ControlLayerInfo

// repeated .dht.PeerDescriptor neighbors = 1;
inline int ControlLayerInfo::_internal_neighbors_size() const {
  return _internal_neighbors().size();
}
inline int ControlLayerInfo::neighbors_size() const {
  return _internal_neighbors_size();
}
inline ::dht::PeerDescriptor* ControlLayerInfo::mutable_neighbors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ControlLayerInfo.neighbors)
  return _internal_mutable_neighbors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* ControlLayerInfo::mutable_neighbors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ControlLayerInfo.neighbors)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_neighbors();
}
inline const ::dht::PeerDescriptor& ControlLayerInfo::neighbors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ControlLayerInfo.neighbors)
  return _internal_neighbors().Get(index);
}
inline ::dht::PeerDescriptor* ControlLayerInfo::add_neighbors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dht::PeerDescriptor* _add = _internal_mutable_neighbors()->Add();
  // @@protoc_insertion_point(field_add:ControlLayerInfo.neighbors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& ControlLayerInfo::neighbors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ControlLayerInfo.neighbors)
  return _internal_neighbors();
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>&
ControlLayerInfo::_internal_neighbors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.neighbors_;
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>*
ControlLayerInfo::_internal_mutable_neighbors() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.neighbors_;
}

// repeated .dht.PeerDescriptor connections = 2;
inline int ControlLayerInfo::_internal_connections_size() const {
  return _internal_connections().size();
}
inline int ControlLayerInfo::connections_size() const {
  return _internal_connections_size();
}
inline ::dht::PeerDescriptor* ControlLayerInfo::mutable_connections(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ControlLayerInfo.connections)
  return _internal_mutable_connections()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>* ControlLayerInfo::mutable_connections()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ControlLayerInfo.connections)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_connections();
}
inline const ::dht::PeerDescriptor& ControlLayerInfo::connections(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ControlLayerInfo.connections)
  return _internal_connections().Get(index);
}
inline ::dht::PeerDescriptor* ControlLayerInfo::add_connections() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::dht::PeerDescriptor* _add = _internal_mutable_connections()->Add();
  // @@protoc_insertion_point(field_add:ControlLayerInfo.connections)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>& ControlLayerInfo::connections() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ControlLayerInfo.connections)
  return _internal_connections();
}
inline const ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>&
ControlLayerInfo::_internal_connections() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.connections_;
}
inline ::google::protobuf::RepeatedPtrField<::dht::PeerDescriptor>*
ControlLayerInfo::_internal_mutable_connections() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.connections_;
}

// -------------------------------------------------------------------

// NodeInfoRequest

// -------------------------------------------------------------------

// NodeInfoResponse

// .dht.PeerDescriptor peerDescriptor = 1;
inline bool NodeInfoResponse::has_peerdescriptor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.peerdescriptor_ != nullptr);
  return value;
}
inline const ::dht::PeerDescriptor& NodeInfoResponse::_internal_peerdescriptor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dht::PeerDescriptor* p = _impl_.peerdescriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::dht::PeerDescriptor&>(::dht::_PeerDescriptor_default_instance_);
}
inline const ::dht::PeerDescriptor& NodeInfoResponse::peerdescriptor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NodeInfoResponse.peerDescriptor)
  return _internal_peerdescriptor();
}
inline void NodeInfoResponse::unsafe_arena_set_allocated_peerdescriptor(::dht::PeerDescriptor* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.peerdescriptor_);
  }
  _impl_.peerdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NodeInfoResponse.peerDescriptor)
}
inline ::dht::PeerDescriptor* NodeInfoResponse::release_peerdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dht::PeerDescriptor* released = _impl_.peerdescriptor_;
  _impl_.peerdescriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dht::PeerDescriptor* NodeInfoResponse::unsafe_arena_release_peerdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NodeInfoResponse.peerDescriptor)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dht::PeerDescriptor* temp = _impl_.peerdescriptor_;
  _impl_.peerdescriptor_ = nullptr;
  return temp;
}
inline ::dht::PeerDescriptor* NodeInfoResponse::_internal_mutable_peerdescriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.peerdescriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::dht::PeerDescriptor>(GetArena());
    _impl_.peerdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(p);
  }
  return _impl_.peerdescriptor_;
}
inline ::dht::PeerDescriptor* NodeInfoResponse::mutable_peerdescriptor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dht::PeerDescriptor* _msg = _internal_mutable_peerdescriptor();
  // @@protoc_insertion_point(field_mutable:NodeInfoResponse.peerDescriptor)
  return _msg;
}
inline void NodeInfoResponse::set_allocated_peerdescriptor(::dht::PeerDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.peerdescriptor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.peerdescriptor_ = reinterpret_cast<::dht::PeerDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:NodeInfoResponse.peerDescriptor)
}

// repeated .StreamPartitionInfo streamPartitions = 2;
inline int NodeInfoResponse::_internal_streampartitions_size() const {
  return _internal_streampartitions().size();
}
inline int NodeInfoResponse::streampartitions_size() const {
  return _internal_streampartitions_size();
}
inline void NodeInfoResponse::clear_streampartitions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.streampartitions_.Clear();
}
inline ::StreamPartitionInfo* NodeInfoResponse::mutable_streampartitions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:NodeInfoResponse.streamPartitions)
  return _internal_mutable_streampartitions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::StreamPartitionInfo>* NodeInfoResponse::mutable_streampartitions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NodeInfoResponse.streamPartitions)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_streampartitions();
}
inline const ::StreamPartitionInfo& NodeInfoResponse::streampartitions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NodeInfoResponse.streamPartitions)
  return _internal_streampartitions().Get(index);
}
inline ::StreamPartitionInfo* NodeInfoResponse::add_streampartitions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::StreamPartitionInfo* _add = _internal_mutable_streampartitions()->Add();
  // @@protoc_insertion_point(field_add:NodeInfoResponse.streamPartitions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::StreamPartitionInfo>& NodeInfoResponse::streampartitions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NodeInfoResponse.streamPartitions)
  return _internal_streampartitions();
}
inline const ::google::protobuf::RepeatedPtrField<::StreamPartitionInfo>&
NodeInfoResponse::_internal_streampartitions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.streampartitions_;
}
inline ::google::protobuf::RepeatedPtrField<::StreamPartitionInfo>*
NodeInfoResponse::_internal_mutable_streampartitions() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.streampartitions_;
}

// optional .ControlLayerInfo controlLayer = 3;
inline bool NodeInfoResponse::has_controllayer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.controllayer_ != nullptr);
  return value;
}
inline void NodeInfoResponse::clear_controllayer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.controllayer_ != nullptr) _impl_.controllayer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ControlLayerInfo& NodeInfoResponse::_internal_controllayer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ControlLayerInfo* p = _impl_.controllayer_;
  return p != nullptr ? *p : reinterpret_cast<const ::ControlLayerInfo&>(::_ControlLayerInfo_default_instance_);
}
inline const ::ControlLayerInfo& NodeInfoResponse::controllayer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NodeInfoResponse.controlLayer)
  return _internal_controllayer();
}
inline void NodeInfoResponse::unsafe_arena_set_allocated_controllayer(::ControlLayerInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controllayer_);
  }
  _impl_.controllayer_ = reinterpret_cast<::ControlLayerInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NodeInfoResponse.controlLayer)
}
inline ::ControlLayerInfo* NodeInfoResponse::release_controllayer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ControlLayerInfo* released = _impl_.controllayer_;
  _impl_.controllayer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ControlLayerInfo* NodeInfoResponse::unsafe_arena_release_controllayer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NodeInfoResponse.controlLayer)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ControlLayerInfo* temp = _impl_.controllayer_;
  _impl_.controllayer_ = nullptr;
  return temp;
}
inline ::ControlLayerInfo* NodeInfoResponse::_internal_mutable_controllayer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.controllayer_ == nullptr) {
    auto* p = CreateMaybeMessage<::ControlLayerInfo>(GetArena());
    _impl_.controllayer_ = reinterpret_cast<::ControlLayerInfo*>(p);
  }
  return _impl_.controllayer_;
}
inline ::ControlLayerInfo* NodeInfoResponse::mutable_controllayer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ControlLayerInfo* _msg = _internal_mutable_controllayer();
  // @@protoc_insertion_point(field_mutable:NodeInfoResponse.controlLayer)
  return _msg;
}
inline void NodeInfoResponse::set_allocated_controllayer(::ControlLayerInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ControlLayerInfo*>(_impl_.controllayer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::ControlLayerInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.controllayer_ = reinterpret_cast<::ControlLayerInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:NodeInfoResponse.controlLayer)
}

// string version = 4;
inline void NodeInfoResponse::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.ClearToEmpty();
}
inline const std::string& NodeInfoResponse::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NodeInfoResponse.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeInfoResponse::set_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NodeInfoResponse.version)
}
inline std::string* NodeInfoResponse::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:NodeInfoResponse.version)
  return _s;
}
inline const std::string& NodeInfoResponse::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_.Get();
}
inline void NodeInfoResponse::_internal_set_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(value, GetArena());
}
inline std::string* NodeInfoResponse::_internal_mutable_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* NodeInfoResponse::release_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NodeInfoResponse.version)
  return _impl_.version_.Release();
}
inline void NodeInfoResponse::set_allocated_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NodeInfoResponse.version)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::ContentType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ContentType>() {
  return ::ContentType_descriptor();
}
template <>
struct is_proto_enum<::EncryptionType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::EncryptionType>() {
  return ::EncryptionType_descriptor();
}
template <>
struct is_proto_enum<::SignatureType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::SignatureType>() {
  return ::SignatureType_descriptor();
}
template <>
struct is_proto_enum<::ProxyDirection> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ProxyDirection>() {
  return ::ProxyDirection_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_packages_2fnetwork_2fprotos_2fNetworkRpc_2eproto_2epb_2eh
