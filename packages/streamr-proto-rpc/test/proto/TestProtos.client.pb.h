// generated by the protocol buffer streamr pluging. DO NOT EDIT!
// generated from protobuf file "TestProtos.proto"

#ifndef STREAMR_PROTORPC_TESTPROTOS_CLIENT_PB_H
#define STREAMR_PROTORPC_TESTPROTOS_CLIENT_PB_H

#include <folly/coro/Task.h>
#include <chrono>
#include <optional>
#include "TestProtos.pb.h" // NOLINT
#include "streamr-proto-rpc/RpcCommunicator.hpp"


namespace streamr::protorpc {
using streamr::protorpc::RpcCommunicator;
template <typename CallContextType>
class DhtRpcServiceClient {
private:
RpcCommunicator<CallContextType>& communicator;
public:
    explicit DhtRpcServiceClient(RpcCommunicator<CallContextType>& communicator) : communicator(communicator) {}
    folly::coro::Task<ClosestPeersResponse> getClosestPeers(ClosestPeersRequest&& request, CallContextType&& callContext, std::optional<std::chrono::milliseconds> timeout = std::nullopt) {
        return communicator.template request<ClosestPeersResponse, ClosestPeersRequest>("getClosestPeers", std::move(request), std::move(callContext), timeout);
    }
    folly::coro::Task<PingResponse> ping(PingRequest&& request, CallContextType&& callContext, std::optional<std::chrono::milliseconds> timeout = std::nullopt) {
        return communicator.template request<PingResponse, PingRequest>("ping", std::move(request), std::move(callContext), timeout);
    }
    folly::coro::Task<RouteMessageAck> routeMessage(RouteMessageWrapper&& request, CallContextType&& callContext, std::optional<std::chrono::milliseconds> timeout = std::nullopt) {
        return communicator.template request<RouteMessageAck, RouteMessageWrapper>("routeMessage", std::move(request), std::move(callContext), timeout);
    }
}; // class DhtRpcServiceClient
template <typename CallContextType>
class OptionalServiceClient {
private:
RpcCommunicator<CallContextType>& communicator;
public:
    explicit OptionalServiceClient(RpcCommunicator<CallContextType>& communicator) : communicator(communicator) {}
    folly::coro::Task<OptionalResponse> getOptional(OptionalRequest&& request, CallContextType&& callContext, std::optional<std::chrono::milliseconds> timeout = std::nullopt) {
        return communicator.template request<OptionalResponse, OptionalRequest>("getOptional", std::move(request), std::move(callContext), timeout);
    }
}; // class OptionalServiceClient
}; // namespace streamr::protorpc

#endif // STREAMR_PROTORPC_TESTPROTOS_CLIENT_PB_H

