#ifndef STREAMER_PROTORPC_PLUGIN_CODE_GENERATOR_HPP
#define STREAMER_PROTORPC_PLUGIN_CODE_GENERATOR_HPP

#include <algorithm>
#include <cctype>
#include <sstream>
#include <string>
#include <google/protobuf/compiler/code_generator.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/zero_copy_stream.h>
#include "streamr-proto-rpc/StreamPrinter.hpp"

namespace streamr::protorpc {

class PluginCodeGenerator : public google::protobuf::compiler::CodeGenerator {
public:
    PluginCodeGenerator() = default;
    ~PluginCodeGenerator() override = default;

    bool Generate(
        const google::protobuf::FileDescriptor* file,
        const std::string& parameter,
        google::protobuf::compiler::GeneratorContext* generatorContext,
        std::string* error) const override {
        return GenerateHeader(file, parameter, generatorContext, error);
    }

    uint64_t GetSupportedFeatures() const override { // NOLINT
        // Indicate that this code generator supports proto3 optional fields.
        // (Note: don't release your code generator with this flag set until you
        // have actually added and tested your proto3 support!)
        return FEATURE_PROTO3_OPTIONAL;
    }

private:
    [[nodiscard]] std::string toUpperCase(const std::string& str) const {
        std::string result = str;
        std::transform(result.begin(), result.end(), result.begin(), ::toupper);
        return result;
    }

    [[nodiscard]] std::string getFilenameWithoutExtension(
        const std::string& filepath) const {
        // Find the last directory separator
        size_t lastSlash = filepath.find_last_of("/\\");
        std::string filename = filepath.substr(lastSlash + 1);

        // Find the last dot in the filename
        size_t lastDot = filename.find_last_of('.');
        if (lastDot == std::string::npos) {
            return filename; // No extension found
        }
        return filename.substr(0, lastDot);
    }

    bool GenerateHeader( // NOLINT
        const google::protobuf::FileDescriptor* file,
        const std::string& /* parameter */,
        google::protobuf::compiler::GeneratorContext* generatorContext,
        std::string* /* error */) const {
        const std::string& protoFilename = file->name();
        const std::string protoFilenameWe =
            this->getFilenameWithoutExtension(protoFilename);
        const std::string headerFilename = protoFilenameWe + ".client.hpp";
        const std::string headerGuard =
            "STREAMR_PROTORPC_" + toUpperCase(protoFilenameWe) + "_CLIENT_HPP";

        std::stringstream ss;

        ss << "// generated by the protocol buffer streamr pluging. DO NOT EDIT!\n";
        ss << "// generated from protobuf file \"" << protoFilename << "\"\n";
        ss << "\n";
        ss << "#ifndef " << headerGuard << "\n";
        ss << "#define " << headerGuard << "\n";
        ss << "\n";
        ss << "namespace streamr::protorpc {\n";

        // for each services
        int numServices = file->service_count();
        for (int i = 0; i < numServices; i++) {
            const google::protobuf::ServiceDescriptor* service =
                file->service(i);
            const std::string serviceFullname = service->full_name();
            const std::string& serviceName = service->name();

            ss << "  class " << serviceName << " {\n";
            ss << "    public:\n";
            ss << "    \n";
            // for each methods
            int numMethods = service->method_count();
            for (int j = 0; j < numMethods; j++) {
                const google::protobuf::MethodDescriptor* method =
                    service->method(j);
                const std::string methodFullname = method->full_name();
                const std::string& methodName = method->name();

                const google::protobuf::Descriptor* methodInput =
                    method->input_type();
                const std::string methodInputFullname =
                    methodInput->full_name();
                const std::string& methodInputName = methodInput->name();

                const google::protobuf::Descriptor* methodOutput =
                    method->output_type();
                const std::string methodOutputFullname =
                    methodOutput->full_name();
                const std::string& methodOutputName = methodOutput->name();

                ss << "       virtual folly::task<" + methodOutputName + "> "
                   << methodName << "(const " << methodInputName
                   << "& request) = 0;\n";
            }
            ss << "  }; // class " << serviceName << "\n";
        }

        ss << "}; //namespace " << file->package() << "\n";
        ss << "\n";
        ss << "#endif //" << headerGuard << "\n";
        // output to header file
        google::protobuf::io::ZeroCopyOutputStream* stream =
            generatorContext->Open(headerFilename);
        StreamPrinter printer(
            stream); // StreamPrinter takes ownership of the Stream
        const std::string buffer = ss.str();
        printer.print(
            reinterpret_cast<const unsigned char*>(buffer.c_str()),
            std::ssize(buffer));
        return true;
    }

    bool GenerateSource( // NOLINT
        const google::protobuf::FileDescriptor* /* file */,
        const std::string& /* parameter */,
        google::protobuf::compiler::GeneratorContext* /* generator_context */,
        std::string* /* error */) const {
        return true;
    }
};
}; // namespace streamr::protorpc
#endif // PROTOBUF_STREAMR_PLUGIN_PLUGIN_CODE_GENERATOR_HPP