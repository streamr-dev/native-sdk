#ifndef STREAMER_PROTORPC_PLUGIN_CODE_GENERATOR_HPP
#define STREAMER_PROTORPC_PLUGIN_CODE_GENERATOR_HPP

#include <algorithm>
#include <cctype>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <google/protobuf/compiler/code_generator.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/zero_copy_stream.h>
#include "protobuf-streamr-plugin/StreamPrinter.hpp"

namespace streamr::protorpc {

class PluginCodeGenerator : public google::protobuf::compiler::CodeGenerator {
public:
    PluginCodeGenerator() = default;
    ~PluginCodeGenerator() override = default;

    bool Generate(
        const google::protobuf::FileDescriptor* file,
        const std::string& parameter,
        google::protobuf::compiler::GeneratorContext* generator_context,
        std::string* error) const override {
        return GenerateHeader(file, parameter, generator_context, error);
    }

private:
    std::string toUpperCase(const std::string& str) const {
        std::string result = str;
        std::transform(result.begin(), result.end(), result.begin(), ::toupper);
        return result;
    }

    std::string getFilenameWithoutExtension(const std::string& filepath) const {
        // Find the last directory separator
        size_t lastSlash = filepath.find_last_of("/\\");
        std::string filename = filepath.substr(lastSlash + 1);

        // Find the last dot in the filename
        size_t lastDot = filename.find_last_of('.');
        if (lastDot == std::string::npos) {
            return filename; // No extension found
        }
        return filename.substr(0, lastDot);
    }

    bool GenerateHeader( // NOLINT
        const google::protobuf::FileDescriptor* file,
        const std::string& parameter,
        google::protobuf::compiler::GeneratorContext* generator_context,
        std::string* error) const {
        const std::string& proto_filename = file->name();
        const std::string proto_filename_we =
            this->getFilenameWithoutExtension(proto_filename);
        const std::string header_filename = proto_filename_we + ".hpp";
        const std::string header_guard =
            "_" + toUpperCase(proto_filename_we) + "_HPP";

        std::stringstream ss;

        ss << "// generated by the protocol buffer streamr pluging. DO NOT EDIT!\n";
        ss << "// generated from protobuf file \"" << proto_filename << "\"\n";
        ss << "\n";
        ss << "#ifndef " << header_guard << "\n";
        ss << "#define " << header_guard << "\n";
        ss << "\n";
        ss << "#include \"" << proto_filename_we << ".pb.h\"\n";
        ss << "\n";
        ss << "#include \"pbop/Status.h\"\n";
        ss << "#include \"pbop/Service.h\"\n";
        ss << "#include \"pbop/Connection.h\"\n";
        ss << "\n";
        ss << "#include <string>\n";
        ss << "\n";
        ss << "namespace " << file->package() << " {\n";

        // for each services
        int num_services = file->service_count();
        for (int i = 0; i < num_services; i++) {
            const google::protobuf::ServiceDescriptor* service =
                file->service(i);
            const std::string service_fullname = service->full_name();
            const std::string& service_name = service->name();

            ss << "  class " << service_name << " {\n";
            ss << "    public:\n";
            ss << "    \n";
            ss << "    class StubInterface {\n";
            ss << "    public:\n";
            ss << "      virtual ~StubInterface() {}\n";
            // for each methods
            int num_methods = service->method_count();
            for (int j = 0; j < num_methods; j++) {
                const google::protobuf::MethodDescriptor* method =
                    service->method(j);
                const std::string method_fullname = method->full_name();
                const std::string& method_name = method->name();

                const google::protobuf::Descriptor* method_input =
                    method->input_type();
                const std::string method_input_fullname =
                    method_input->full_name();
                const std::string& method_input_name = method_input->name();

                const google::protobuf::Descriptor* method_output =
                    method->output_type();
                const std::string method_output_fullname =
                    method_output->full_name();
                const std::string& method_output_name = method_output->name();

                ss << "      virtual pbop::Status " << method_name << "(const "
                   << method_input_name << " & request, " << method_output_name
                   << " & response) = 0;\n";
            }
            ss << "    }; // class StubInterface\n";
            ss << "  \n";
            ss << "    class Client : public virtual StubInterface {\n";
            ss << "    public:\n";
            ss << "      Client(pbop::Connection * connection);\n";
            ss << "      virtual ~Client();\n";

            // for each methods
            for (int j = 0; j < num_methods; j++) {
                const google::protobuf::MethodDescriptor* method =
                    service->method(j);
                const std::string method_fullname = method->full_name();
                const std::string& method_name = method->name();

                const google::protobuf::Descriptor* method_input =
                    method->input_type();
                const std::string method_input_fullname =
                    method_input->full_name();
                const std::string& method_input_name = method_input->name();

                const google::protobuf::Descriptor* method_output =
                    method->output_type();
                const std::string method_output_fullname =
                    method_output->full_name();
                const std::string& method_output_name = method_output->name();

                ss << "      virtual pbop::Status " << method_name << "(const "
                   << method_input_name << " & request, " << method_output_name
                   << " & response);\n";
            }
            ss << "    private:\n";
            ss << "      pbop::Status ProcessCall(const char * name, const ::google::protobuf::Message & request, ::google::protobuf::Message & response);\n";
            ss << "      pbop::Connection * connection_;\n";
            ss << "    }; // class Client\n";
            ss << "    \n";
            ss << "    class Service : public virtual StubInterface, public virtual pbop::Service {\n";
            ss << "    public:\n";
            ss << "      Service();\n";
            ss << "      virtual ~Service();\n";
            ss << "      virtual const char * GetPackageName() const;\n";
            ss << "      virtual const char * GetServiceName() const;\n";
            ss << "      virtual const char ** GetFunctionIdentifiers() const;\n";
            ss << "      virtual pbop::Status InvokeMethod(const size_t & index, const std::string & input, std::string & output);\n";

            // for each methods
            for (int j = 0; j < num_methods; j++) {
                const google::protobuf::MethodDescriptor* method =
                    service->method(j);
                const std::string method_fullname = method->full_name();
                const std::string& method_name = method->name();

                const google::protobuf::Descriptor* method_input =
                    method->input_type();
                const std::string method_input_fullname =
                    method_input->full_name();
                const std::string& method_input_name = method_input->name();

                const google::protobuf::Descriptor* method_output =
                    method->output_type();
                const std::string method_output_fullname =
                    method_output->full_name();
                const std::string& method_output_name = method_output->name();

                ss << "      inline pbop::Status " << method_name << "(const "
                   << method_input_name << " & request, " << method_output_name
                   << " & response) { return pbop::Status::Factory::NotImplemented(__FUNCTION__); }\n";
            }
            ss << "    };  // class Service\n";
            ss << "  \n";
            ss << "  }; // class " << service_name << "\n";
        }

        ss << "}; //namespace " << file->package() << "\n";
        ss << "\n";
        ss << "#endif //" << header_guard << "\n";
 std::cout << ss.str() << std::endl;
/*
        // output to header file
        google::protobuf::io::ZeroCopyOutputStream* stream =
            generator_context->Open(header_filename.c_str());
        StreamPrinter printer(
            stream); // StreamPrinter takes ownership of the Stream
        const std::string buffer = ss.str();
        printer.print(
            reinterpret_cast<const unsigned char*>(buffer.c_str()),
            buffer.size());
            */
        return true;
    }

    bool GenerateSource( // NOLINT
        const google::protobuf::FileDescriptor* /* file */,
        const std::string& /* parameter */,
        google::protobuf::compiler::GeneratorContext* /* generator_context */,
        std::string* /* error */) const {
        return true;
    }
};
}; // namespace streamrprotorpc
#endif // PROTOBUF_STREAMR_PLUGIN_PLUGIN_CODE_GENERATOR_HPP